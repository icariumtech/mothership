---
phase: 04-npc-portrait-system
plan: 03
type: execute
wave: 2
depends_on:
  - "04-01"
  - "04-02"
files_modified:
  - src/components/gm/EncounterPanel.tsx
  - src/components/domain/encounter/NPCPortraitOverlay.tsx
  - src/components/domain/encounter/NPCPortraitCard.tsx
  - src/components/domain/encounter/NPCPortraitOverlay.css
  - src/entries/SharedConsole.tsx
autonomous: true
requirements:
  - PORT-01
  - PORT-02
  - PORT-03
  - PORT-04
  - PORT-05

must_haves:
  truths:
    - "GM console shows NPC PORTRAITS section in EncounterPanel when encounter is active — lists all NPCs with SHOW/DISMISS toggle buttons"
    - "Clicking a toggle button calls encounterApi.togglePortrait and updates button state immediately (optimistic)"
    - "Player terminal renders NPCPortraitOverlay when encounter_active_portraits is non-empty in polled data"
    - "Each portrait card reveals with flicker → clip-path wipe from top → name typewriter in that order"
    - "Multiple portraits tile horizontally side by side with flex layout"
    - "CRT scanline overlay and chamfered panel border are visible on each portrait card"
    - "Removing a portrait plays a fade-out before unmounting"
  artifacts:
    - path: "src/components/gm/EncounterPanel.tsx"
      provides: "NPC portrait toggle section with SHOW/DISMISS buttons"
      contains: "NPC PORTRAITS"
    - path: "src/components/domain/encounter/NPCPortraitOverlay.tsx"
      provides: "Fixed-position overlay container for portrait cards"
      min_lines: 40
    - path: "src/components/domain/encounter/NPCPortraitCard.tsx"
      provides: "Single portrait card with CRT animation state machine"
      min_lines: 80
    - path: "src/components/domain/encounter/NPCPortraitOverlay.css"
      provides: "All portrait overlay, card, and animation styles"
      contains: "portrait-flicker"
    - path: "src/entries/SharedConsole.tsx"
      provides: "NPCPortraitOverlay rendered in ENCOUNTER view"
      contains: "NPCPortraitOverlay"
  key_links:
    - from: "src/entries/SharedConsole.tsx"
      to: "src/components/domain/encounter/NPCPortraitOverlay.tsx"
      via: "rendered inside ENCOUNTER view block when encounter_active_portraits is non-empty"
      pattern: "NPCPortraitOverlay"
    - from: "src/components/domain/encounter/NPCPortraitOverlay.tsx"
      to: "src/components/domain/encounter/NPCPortraitCard.tsx"
      via: "maps encounter_active_portraits to NPCPortraitCard with key={npcId}"
      pattern: "NPCPortraitCard"
    - from: "src/components/gm/EncounterPanel.tsx"
      to: "src/services/encounterApi.ts:togglePortrait"
      via: "handleTogglePortrait callback on button click"
      pattern: "togglePortrait"
---

<objective>
Build all frontend components for the NPC portrait system: the GM console trigger section in EncounterPanel, the NPCPortraitOverlay and NPCPortraitCard terminal-side components with full CRT animation, and wiring in SharedConsole.

Purpose: This is the visual and interactive heart of Phase 4. The GM gets NPC toggle buttons contextual to the encounter view; players see atmospheric portrait overlays with CRT reveal animations.

Output: Updated EncounterPanel.tsx, new NPCPortraitOverlay.tsx, new NPCPortraitCard.tsx, new NPCPortraitOverlay.css, updated SharedConsole.tsx.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-npc-portrait-system/04-CONTEXT.md
@.planning/phases/04-npc-portrait-system/04-RESEARCH.md
@.planning/phases/04-npc-portrait-system/04-01-SUMMARY.md
@.planning/phases/04-npc-portrait-system/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NPC portrait toggle section to EncounterPanel</name>
  <files>src/components/gm/EncounterPanel.tsx</files>
  <action>
    In src/components/gm/EncounterPanel.tsx, add the NPC PORTRAITS card section after the ROOM VISIBILITY card (at the bottom of the return JSX, before the closing `</>`).

    The section should only render when `isActive` is true (same condition as the rest of the panel).

    **NPC sourcing:** EncounterPanel already receives `activeView` as a prop. Derive the NPC list directly from it — no new prop, no INITIAL_DATA, no API call:
    ```tsx
    const npcs = Object.values(activeView?.encounter_npc_data || {});
    ```
    This uses the same polled data that drives the rest of the panel and stays fresh automatically.

    **Implementation steps:**

    1. `encounterApi` is already imported. No new imports needed for NPC sourcing.

    2. Inside the component body, derive NPCs and active portrait IDs:
       ```tsx
       const npcs = Object.values(activeView?.encounter_npc_data || {});
       const activePortraits = activeView?.encounter_active_portraits || [];
       ```

    3. Add handler:
       ```tsx
       const handleTogglePortrait = useCallback(async (npcId: string) => {
         try {
           await encounterApi.togglePortrait(npcId);
           onViewUpdate();
         } catch (err) {
           console.error('Error toggling portrait:', err);
           messageApi.error('Failed to toggle portrait');
         }
       }, [onViewUpdate, messageApi]);
       ```

    4. Add the NPC PORTRAITS card after the ROOM VISIBILITY card:
       ```tsx
       {/* NPC Portraits Card */}
       <Card
         size="small"
         title={<Text style={{ color: '#5a7a7a' }}>NPC PORTRAITS</Text>}
         style={{ marginBottom: 16, background: '#1a1a1a' }}
         bodyStyle={{ padding: 12 }}
       >
         {npcs.length === 0 ? (
           <Text type="secondary" style={{ fontSize: 11 }}>No NPCs in campaign data</Text>
         ) : (
           <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
             {npcs.map(npc => {
               const isPortraitActive = activePortraits.includes(npc.id);
               return (
                 <div
                   key={npc.id}
                   style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}
                 >
                   <Text style={{ fontSize: 12 }}>{npc.name}</Text>
                   <Button
                     size="small"
                     type={isPortraitActive ? 'primary' : 'default'}
                     style={isPortraitActive ? { background: '#8b7355', borderColor: '#8b7355' } : {}}
                     onClick={() => handleTogglePortrait(npc.id)}
                   >
                     {isPortraitActive ? 'DISMISS' : 'SHOW'}
                   </Button>
                 </div>
               );
             })}
           </div>
         )}
       </Card>
       ```

    **Important:** The `encounter_active_portraits` and `encounter_npc_data` fields in the `ActiveView` type in gmConsole.ts were added in Plan 02. They are already typed correctly on `activeView`. No changes to GMConsole or any parent component are needed.
  </action>
  <verify>
    ```bash
    cd /home/gjohnson/mothership/charon && npm run typecheck 2>&1 | head -30
    grep -n "NPC PORTRAITS\|handleTogglePortrait\|activePortraits" /home/gjohnson/mothership/charon/src/components/gm/EncounterPanel.tsx
    ```
    No TypeScript errors. NPC PORTRAITS section exists in EncounterPanel.
  </verify>
  <done>
    - NPC PORTRAITS Card section renders in EncounterPanel when isActive
    - Each NPC has a SHOW/DISMISS button that reflects encounter_active_portraits state
    - handleTogglePortrait calls encounterApi.togglePortrait then onViewUpdate
    - TypeScript clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Build NPCPortraitCard, NPCPortraitOverlay, CSS, and wire into SharedConsole</name>
  <files>
    src/components/domain/encounter/NPCPortraitCard.tsx
    src/components/domain/encounter/NPCPortraitOverlay.tsx
    src/components/domain/encounter/NPCPortraitOverlay.css
    src/entries/SharedConsole.tsx
  </files>
  <action>
    **Step A: Create NPCPortraitOverlay.css**

    Create `src/components/domain/encounter/NPCPortraitOverlay.css` with all styles:

    ```css
    /* Portrait overlay container — sits above encounter map, below scanline */
    .portrait-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 100;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Dimmed backdrop — semi-transparent so map is still visible below */
    .portrait-overlay-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      transition: opacity 300ms ease;
    }

    /* Tray that holds portrait cards side by side */
    .portrait-overlay-tray {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: row;
      gap: 24px;
      justify-content: center;
      align-items: flex-end;
    }

    /* Individual portrait card */
    .portrait-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: auto;
    }

    /* Image wrapper — clip-path animation applied here (not on img for Safari compat) */
    .portrait-image-wrapper {
      position: relative;
      width: 220px;
      height: 300px;
      overflow: hidden;
    }

    .portrait-image-wrapper.phase-flicker {
      animation: portrait-flicker 280ms steps(1) forwards;
    }

    .portrait-image-wrapper.phase-wipe {
      clip-path: inset(0 0 100% 0);
      animation: portrait-wipe 650ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    .portrait-image-wrapper.phase-stable,
    .portrait-image-wrapper.phase-typing,
    .portrait-image-wrapper.phase-done {
      clip-path: inset(0 0 0% 0);
    }

    .portrait-image-wrapper.phase-dismissing {
      animation: portrait-dismiss 280ms ease-out forwards;
    }

    /* Portrait image fills wrapper */
    .portrait-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* Placeholder shown when no portrait image available */
    .portrait-placeholder {
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4a6b6b;
      font-size: 48px;
      font-family: 'Cascadia Code', monospace;
    }

    /* CRT scanline + vignette overlay on portrait image */
    .portrait-image-wrapper::after {
      content: '';
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          to bottom,
          transparent,
          transparent 2px,
          rgba(0, 0, 0, 0.12) 2px,
          rgba(0, 0, 0, 0.12) 4px
        ),
        radial-gradient(ellipse at center, transparent 40%, rgba(0, 0, 0, 0.55) 100%);
      pointer-events: none;
      z-index: 1;
    }

    /* NPC name below image — amber terminal style */
    .portrait-name {
      margin-top: 10px;
      font-family: 'Cascadia Code', 'Courier New', monospace;
      font-size: 14px;
      letter-spacing: 2px;
      color: #c4a96a;
      text-transform: uppercase;
      text-align: center;
      min-height: 20px;
    }

    /* Keyframes */
    @keyframes portrait-flicker {
      0%   { opacity: 1; }
      15%  { opacity: 0; }
      30%  { opacity: 1; }
      50%  { opacity: 0; }
      65%  { opacity: 1; }
      80%  { opacity: 0; }
      100% { opacity: 1; }
    }

    @keyframes portrait-wipe {
      from { clip-path: inset(0 0 100% 0); }
      to   { clip-path: inset(0 0 0% 0); }
    }

    @keyframes portrait-dismiss {
      from { opacity: 1; transform: scale(1); }
      to   { opacity: 0; transform: scale(0.92); }
    }
    ```

    **Step B: Create NPCPortraitCard.tsx**

    Create `src/components/domain/encounter/NPCPortraitCard.tsx`:

    ```tsx
    import { useState, useEffect, useRef } from 'react';
    import { Panel } from '@components/ui/Panel';
    import './NPCPortraitOverlay.css';

    type AnimPhase = 'flicker' | 'wipe' | 'stable' | 'typing' | 'done' | 'dismissing';

    interface NPCPortraitCardProps {
      npcId: string;
      name: string;
      portrait: string;  // URL path or empty string
      isDismissing: boolean;  // parent signals card is leaving
      onDismissed: (npcId: string) => void;  // called when fade-out completes
    }

    export function NPCPortraitCard({ npcId, name, portrait, isDismissing, onDismissed }: NPCPortraitCardProps) {
      const [animPhase, setAnimPhase] = useState<AnimPhase>('flicker');
      const [displayedName, setDisplayedName] = useState('');
      const nameTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);

      // Mount animation sequence: flicker → wipe → stable → typing → done
      useEffect(() => {
        let cancelled = false;

        const runSequence = async () => {
          // Phase 1: Flicker (280ms matches CSS animation)
          setAnimPhase('flicker');
          await new Promise(r => setTimeout(r, 280));
          if (cancelled) return;

          // Phase 2: Wipe (650ms matches CSS animation)
          setAnimPhase('wipe');
          await new Promise(r => setTimeout(r, 650));
          if (cancelled) return;

          // Phase 3: Stable — image fully visible
          setAnimPhase('stable');
          await new Promise(r => setTimeout(r, 200));
          if (cancelled) return;

          // Phase 4: Typing — name reveals character by character
          setAnimPhase('typing');
        };

        runSequence();
        return () => { cancelled = true; };
      }, []); // run once on mount

      // Typewriter for name
      useEffect(() => {
        if (animPhase !== 'typing') return;

        let i = 0;
        setDisplayedName('');

        nameTimerRef.current = setInterval(() => {
          i++;
          setDisplayedName(name.slice(0, i));
          if (i >= name.length) {
            clearInterval(nameTimerRef.current!);
            nameTimerRef.current = null;
            setAnimPhase('done');
          }
        }, 55); // ~55ms per character — deliberate pace

        return () => {
          if (nameTimerRef.current) {
            clearInterval(nameTimerRef.current);
            nameTimerRef.current = null;
          }
        };
      }, [animPhase, name]);

      // Dismiss animation: play fade-out then notify parent
      useEffect(() => {
        if (!isDismissing) return;

        setAnimPhase('dismissing');
        const timer = setTimeout(() => {
          onDismissed(npcId);
        }, 300); // matches portrait-dismiss animation duration

        return () => clearTimeout(timer);
      }, [isDismissing, npcId, onDismissed]);

      const imageWrapperClass = `portrait-image-wrapper phase-${animPhase}`;

      return (
        <div className="portrait-card">
          <div style={{ border: '1px solid #4a6b6b' }}>
            <Panel
              chamferCorners={['tl', 'tr', 'bl', 'br']}
              chamferSize={12}
              padding={6}
            >
              <div className={imageWrapperClass}>
                {portrait ? (
                  <img
                    src={portrait}
                    alt={name}
                    className="portrait-image"
                    draggable={false}
                  />
                ) : (
                  <div className="portrait-placeholder">?</div>
                )}
              </div>
            </Panel>
          </div>
          <div className="portrait-name">{displayedName}</div>
        </div>
      );
    }
    ```

    **Step C: Create NPCPortraitOverlay.tsx**

    Create `src/components/domain/encounter/NPCPortraitOverlay.tsx`:

    ```tsx
    import { useState, useCallback } from 'react';
    import { NPCPortraitCard } from './NPCPortraitCard';
    import './NPCPortraitOverlay.css';

    interface NpcData {
      id: string;
      name: string;
      portrait: string;
    }

    interface NPCPortraitOverlayProps {
      activePortraitIds: string[];
      npcData: { [id: string]: NpcData };
    }

    export function NPCPortraitOverlay({ activePortraitIds, npcData }: NPCPortraitOverlayProps) {
      // Track IDs that are in the process of being dismissed (fade-out playing)
      const [dismissingIds, setDismissingIds] = useState<Set<string>>(new Set());

      // When poll removes an ID and it's not already dismissing, mark it for dismiss animation
      // We show dismissing cards even after they leave activePortraitIds
      const [localIds, setLocalIds] = useState<string[]>(activePortraitIds);

      // Sync local IDs — add new ones immediately, mark removed ones as dismissing
      const prevIdsRef = useState<string[]>(activePortraitIds)[0];

      // Simple sync: maintain a local set that includes currently-displayed plus dismissing IDs
      // When activePortraitIds changes, find newly removed IDs and mark them dismissing
      // New IDs get added immediately to localIds

      // Use a ref to track previous IDs without triggering extra renders
      const [displayedIds, setDisplayedIds] = useState<string[]>(activePortraitIds);

      const handleNewIds = useCallback((newIds: string[], oldIds: string[]) => {
        const removed = oldIds.filter(id => !newIds.includes(id));
        const added = newIds.filter(id => !oldIds.includes(id));

        if (removed.length > 0) {
          setDismissingIds(prev => {
            const next = new Set(prev);
            removed.forEach(id => next.add(id));
            return next;
          });
          // Keep removed IDs in displayedIds until their animation completes
          setDisplayedIds(prev => {
            const withAdded = [...prev, ...added.filter(id => !prev.includes(id))];
            return withAdded;
          });
        } else if (added.length > 0) {
          setDisplayedIds(prev => [...prev, ...added.filter(id => !prev.includes(id))]);
        }
      }, []);

      // Track previous activePortraitIds to detect changes
      const [prevIds, setPrevIds] = useState<string[]>(activePortraitIds);
      if (JSON.stringify(prevIds) !== JSON.stringify(activePortraitIds)) {
        setPrevIds(activePortraitIds);
        handleNewIds(activePortraitIds, prevIds);
      }

      const handleDismissed = useCallback((npcId: string) => {
        // Remove from displayed and dismissing sets
        setDisplayedIds(prev => prev.filter(id => id !== npcId));
        setDismissingIds(prev => {
          const next = new Set(prev);
          next.delete(npcId);
          return next;
        });
      }, []);

      if (displayedIds.length === 0) return null;

      return (
        <div className="portrait-overlay">
          <div className="portrait-overlay-backdrop" />
          <div className="portrait-overlay-tray">
            {displayedIds.map(npcId => {
              const npc = npcData[npcId];
              if (!npc) return null;
              return (
                <NPCPortraitCard
                  key={npcId}
                  npcId={npcId}
                  name={npc.name}
                  portrait={npc.portrait || ''}
                  isDismissing={dismissingIds.has(npcId)}
                  onDismissed={handleDismissed}
                />
              );
            })}
          </div>
        </div>
      );
    }
    ```

    Note: The `useState` comparison pattern for detecting prop changes is not idiomatic React. A simpler and correct approach is to use `useEffect` to detect changes in `activePortraitIds`. Refactor NPCPortraitOverlay to use `useEffect` instead:

    ```tsx
    import { useState, useCallback, useEffect, useRef } from 'react';

    // ... interfaces same as above ...

    export function NPCPortraitOverlay({ activePortraitIds, npcData }: NPCPortraitOverlayProps) {
      const [displayedIds, setDisplayedIds] = useState<string[]>(activePortraitIds);
      const [dismissingIds, setDismissingIds] = useState<Set<string>>(new Set());
      const prevIdsRef = useRef<string[]>(activePortraitIds);

      useEffect(() => {
        const prevIds = prevIdsRef.current;
        const removed = prevIds.filter(id => !activePortraitIds.includes(id));
        const added = activePortraitIds.filter(id => !prevIds.includes(id));

        if (removed.length > 0) {
          setDismissingIds(prev => {
            const next = new Set(prev);
            removed.forEach(id => next.add(id));
            return next;
          });
        }

        if (added.length > 0) {
          setDisplayedIds(prev => {
            const withAdded = [...prev.filter(id => !removed.includes(id) || dismissingIds.has(id))];
            added.forEach(id => { if (!withAdded.includes(id)) withAdded.push(id); });
            return withAdded;
          });
        }

        prevIdsRef.current = activePortraitIds;
      }, [activePortraitIds]);

      const handleDismissed = useCallback((npcId: string) => {
        setDisplayedIds(prev => prev.filter(id => id !== npcId));
        setDismissingIds(prev => {
          const next = new Set(prev);
          next.delete(npcId);
          return next;
        });
      }, []);

      if (displayedIds.length === 0) return null;

      return (
        <div className="portrait-overlay">
          <div className="portrait-overlay-backdrop" />
          <div className="portrait-overlay-tray">
            {displayedIds.map(npcId => {
              const npc = npcData[npcId];
              if (!npc) return null;
              return (
                <NPCPortraitCard
                  key={npcId}
                  npcId={npcId}
                  name={npc.name}
                  portrait={npc.portrait || ''}
                  isDismissing={dismissingIds.has(npcId)}
                  onDismissed={handleDismissed}
                />
              );
            })}
          </div>
        </div>
      );
    }
    ```

    **Step D: Wire NPCPortraitOverlay into SharedConsole.tsx**

    In `src/entries/SharedConsole.tsx`:

    1. Import NPCPortraitOverlay at the top (after other encounter imports):
       ```tsx
       import { NPCPortraitOverlay } from '@components/domain/encounter/NPCPortraitOverlay';
       ```

    2. In the JSX return, inside the ENCOUNTER view block (currently around line 964-979), add NPCPortraitOverlay after EncounterView:
       ```tsx
       {/* ENCOUNTER view - clean display for player terminal */}
       {viewType === 'ENCOUNTER' && (
         <>
           <EncounterView
             locationSlug={activeView?.location_slug || null}
             locationType={activeView?.location_type || null}
             locationData={activeView?.location_data || null}
             encounterLevel={activeView?.encounter_level}
             totalDecks={activeView?.encounter_total_decks}
             deckName={activeView?.encounter_deck_name}
             roomVisibility={activeView?.encounter_room_visibility}
             doorStatus={activeView?.encounter_door_status}
             tokens={encounterTokens}
             isGM={false}
             onTokenMove={handleTokenMove}
           />
           {/* NPC Portrait overlay — shown when GM has active portraits */}
           {(activeView?.encounter_active_portraits?.length ?? 0) > 0 && (
             <NPCPortraitOverlay
               activePortraitIds={activeView?.encounter_active_portraits || []}
               npcData={activeView?.encounter_npc_data || {}}
             />
           )}
         </>
       )}
       ```

       Note: The existing `{viewType === 'ENCOUNTER' && (<EncounterView .../>)}` is a single JSX expression. Wrap it in a fragment `<>...</>` to add NPCPortraitOverlay alongside it.

  </action>
  <verify>
    ```bash
    cd /home/gjohnson/mothership/charon && npm run typecheck 2>&1 | head -40
    npm run build 2>&1 | tail -20
    ```
    Check for TypeScript errors and build errors. Verify new files exist:
    ```bash
    ls /home/gjohnson/mothership/charon/src/components/domain/encounter/NPC*
    grep -n "NPCPortraitOverlay" /home/gjohnson/mothership/charon/src/entries/SharedConsole.tsx
    grep -n "NPC PORTRAITS" /home/gjohnson/mothership/charon/src/components/gm/EncounterPanel.tsx
    ```
  </verify>
  <done>
    - NPCPortraitCard.tsx exists with flicker→wipe→stable→typing→done animation state machine
    - NPCPortraitOverlay.tsx exists with dismiss animation support using useEffect + useRef pattern
    - NPCPortraitOverlay.css exists with all keyframes (portrait-flicker, portrait-wipe, portrait-dismiss)
    - EncounterPanel.tsx has NPC PORTRAITS section with SHOW/DISMISS buttons
    - SharedConsole.tsx renders NPCPortraitOverlay when encounter_active_portraits is non-empty
    - npm run typecheck passes, npm run build succeeds
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` — zero errors
2. `npm run build` — succeeds
3. Files exist: `src/components/domain/encounter/NPCPortraitOverlay.tsx`, `NPCPortraitCard.tsx`, `NPCPortraitOverlay.css`
4. `grep -n "NPCPortraitOverlay" src/entries/SharedConsole.tsx` — import and render both present
5. `grep -n "NPC PORTRAITS" src/components/gm/EncounterPanel.tsx` — section header present
6. `grep -n "portrait-flicker\|portrait-wipe\|portrait-dismiss" src/components/domain/encounter/NPCPortraitOverlay.css` — all three keyframes present
</verification>

<success_criteria>
- GM console NPC PORTRAITS section visible when encounter is active
- SHOW/DISMISS buttons reflect encounter_active_portraits state
- NPCPortraitOverlay renders at z-index 100 (above encounter map, below scanline)
- CRT flicker animation plays on mount (CSS keyframe)
- Clip-path wipe reveals portrait image top-to-bottom
- Name types out character by character after image reveals
- Multiple portraits tile horizontally with flex layout
- Removing a portrait triggers fade-out before unmounting
- CRT scanline and vignette overlay visible on each portrait via CSS ::after pseudo-element
- Chamfered Panel border wraps each portrait
- Build succeeds, TypeScript clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-npc-portrait-system/04-03-SUMMARY.md` with what was built, key file paths modified, and any decisions made during implementation (especially Panel prop names used, dismiss animation approach, and how NPCPortraitOverlay sync works).
</output>
