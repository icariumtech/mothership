<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MOTHERSHIP TERMINAL</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        /* V2-1 Color Palette */
        :root {
            --color-teal: #4a6b6b;
            --color-teal-bright: #5a7a7a;
            --color-amber: #8b7355;
            --color-amber-bright: #9a8065;
            --color-bg-primary: #0a0a0a;
            --color-bg-secondary: #1a1a1a;
            --color-bg-panel: #1a2525;
            --color-bg-panel-dark: #0f1515;
            --color-text-primary: #9a9a9a;
            --color-text-secondary: #7a7a7a;
            --color-text-muted: #5a5a5a;
            --color-border-main: #4a6b6b;
            --color-border-subtle: #2a3a3a;
            --color-active: #8b7355;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000; /* Black to match star map canvas */
            color: var(--color-text-primary);
            font-family: 'Cascadia Code', 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Scanline overlay - covers entire screen */
        .scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        /* ===================
           STANDBY VIEW
           =================== */
        .standby-view {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            background-color: #2b2b2b; /* Charcoal background */
        }

        .standby-logo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .standby-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 96px;
            font-weight: 900;
            letter-spacing: 16px;
            color: #e0e0e0;
            text-align: center;
            opacity: 0.9;
            animation: aggressiveGlitch 3s infinite;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            /* CSS variables for random glitch direction */
            --glitch-x1: -35px;
            --glitch-y1: 0px;
            --glitch-x2: 30px;
            --glitch-y2: 0px;
            --glitch-x3: -20px;
            --glitch-y3: 0px;
        }

        .standby-subtitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 8px;
            color: #8b7355;
            text-align: center;
            opacity: 0.8;
            text-shadow: 0 0 15px rgba(139, 115, 85, 0.4);
            animation: aggressiveGlitch 3s infinite;
            animation-delay: 1.5s; /* Offset by half cycle so it glitches at different time */
            /* CSS variables for random glitch direction */
            --glitch-x1: -35px;
            --glitch-y1: 0px;
            --glitch-x2: 30px;
            --glitch-y2: 0px;
            --glitch-x3: -20px;
            --glitch-y3: 0px;
        }

        /* Aggressive random glitch effect with motion blur */
        @keyframes aggressiveGlitch {
            0%, 88%, 90%, 92%, 100% {
                transform: translate(0, 0) skewX(0deg);
                filter: brightness(1) blur(0px);
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            }
            89% {
                transform: translate(var(--glitch-x1), var(--glitch-y1)) skewX(-5deg);
                filter: brightness(1.3) contrast(1.2) blur(1.5px);
                text-shadow:
                    -5px 0 10px rgba(255, 0, 0, 0.5),
                    5px 0 10px rgba(0, 255, 255, 0.5),
                    -10px 0 15px rgba(255, 0, 0, 0.3),
                    -15px 0 20px rgba(255, 0, 0, 0.2),
                    -20px 0 25px rgba(255, 0, 0, 0.1);
            }
            89.5% {
                transform: translate(var(--glitch-x2), var(--glitch-y2)) skewX(5deg);
                filter: brightness(0.7) contrast(1.5) blur(1.5px);
                text-shadow:
                    5px 0 10px rgba(0, 255, 0, 0.5),
                    -5px 0 10px rgba(255, 0, 255, 0.5),
                    10px 0 15px rgba(0, 255, 0, 0.3),
                    15px 0 20px rgba(0, 255, 0, 0.2),
                    20px 0 25px rgba(0, 255, 0, 0.1);
            }
            91% {
                transform: translate(var(--glitch-x3), var(--glitch-y3)) skewX(3deg);
                filter: brightness(1.4) blur(1px);
                text-shadow:
                    0 0 30px rgba(255, 255, 255, 0.6),
                    -10px 0 20px rgba(255, 255, 255, 0.3),
                    -15px 0 25px rgba(255, 255, 255, 0.2);
            }
        }

        /* Random text blocks that appear around the screen */
        .text-block {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: white;
            white-space: pre-line;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 6s ease-in-out forwards;
            mask-image: radial-gradient(ellipse 100% 100% at 50% 50%, black 30%, transparent 80%);
            -webkit-mask-image: radial-gradient(ellipse 100% 100% at 50% 50%, black 30%, transparent 80%);
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            80% {
                opacity: 0.7;
            }
            100% {
                opacity: 0;
            }
        }

        /* ===================
           CAMPAIGN DASHBOARD VIEW
           =================== */
        .campaign-dashboard {
            width: 100vw;
            height: 100vh;
            background-color: transparent; /* Transparent to show star map */
            display: grid;
            grid-template-columns: 275px 1fr 275px;
            grid-template-rows: 52px 1fr 120px;
            grid-template-areas:
                "top-left top-center top-right"
                "left center right"
                "bottom-left bottom-center bottom-right";
            gap: 30px;
        }

        /* Top Panel - centered 1/4 width */
        .dashboard-top {
            grid-area: top-center;
            width: 25vw;
            justify-self: center;
            background-color: var(--color-bg-panel);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;

            /* Chamfer bottom-left and bottom-right corners */
            clip-path: polygon(
                0 0, 100% 0,
                100% calc(100% - 12px), calc(100% - 12px) 100%,
                12px 100%, 0 calc(100% - 12px)
            );

            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        /* Diagonal corner lines for top panel */
        .dashboard-top::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .dashboard-top::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .dashboard-top-content {
            color: var(--color-teal);
            font-size: 18px;
            letter-spacing: 3px;
        }

        /* Left Panel - CREW */
        .dashboard-left {
            grid-area: left;
            background-color: var(--color-bg-panel);
            position: relative;
            display: flex;
            flex-direction: column;

            /* Chamfer top-right and bottom-right corners */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0,
                100% 12px, 100% calc(100% - 12px),
                calc(100% - 12px) 100%, 0 100%
            );

            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .dashboard-left::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .dashboard-left::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* Right Panel - MISSIONS */
        .dashboard-right {
            grid-area: right;
            background-color: var(--color-bg-panel);
            position: relative;
            display: flex;
            flex-direction: column;

            /* Chamfer top-left and bottom-left corners */
            clip-path: polygon(
                12px 0, 100% 0,
                100% 100%, 12px 100%,
                0 calc(100% - 12px), 0 12px
            );

            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .dashboard-right::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .dashboard-right::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* Bottom Panel - spans full width */
        .dashboard-bottom {
            grid-area: bottom-left / bottom-left / bottom-right / span 3;
            background-color: var(--color-bg-panel);
            position: relative;
            display: flex;
            flex-direction: column;

            /* Chamfer top-left and top-right corners */
            clip-path: polygon(
                0 12px, 12px 0,
                calc(100% - 12px) 0, 100% 12px,
                100% 100%, 0 100%
            );

            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .dashboard-bottom::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .dashboard-bottom::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* Panel Headers */
        .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 13px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 10px 5px 10px;
            border-bottom: 1px solid var(--color-border-subtle);
        }

        /* Adjust h3 borders to avoid diagonal corners */
        .dashboard-left .dashboard-panel-header h3 {
            padding-right: 22px; /* 10px base + 12px for corner */
        }

        .dashboard-right .dashboard-panel-header h3 {
            padding-left: 22px; /* 10px base + 12px for corner */
        }

        .dashboard-bottom .dashboard-panel-header h3 {
            padding-left: 22px; /* 10px base + 12px for corner */
            padding-right: 22px; /* 10px base + 12px for corner */
        }

        /* Panel Content Areas */
        .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px 12px 12px 12px;
            margin-bottom: 2px;
            margin-left: 2px;
            margin-right: 5px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            color: var(--color-text-primary);
            font-size: 12px;
            line-height: 1.6;
        }

        /* Scrollbar styling for dashboard panels - floating style */
        .dashboard-panel-content::-webkit-scrollbar {
            width: 10px;
        }

        .dashboard-panel-content::-webkit-scrollbar-track {
            background: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            border: none;
            margin-top: 2px;
            margin-bottom: 2px;
        }

        .dashboard-panel-content::-webkit-scrollbar-thumb {
            background: #0f1515;
            border: 1px solid #4a6b6b;
        }

        .dashboard-panel-content::-webkit-scrollbar-thumb:hover {
            background: #1a2525;
        }

        .dashboard-panel-content::-webkit-scrollbar-button {
            display: none;
        }

        /* ===================
           ENCOUNTER MAP VIEW
           =================== */
        .map-view {
            width: 100vw;
            height: 100vh;
            background-color: var(--color-bg-primary);
            padding: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .map-header {
            color: var(--color-teal);
            font-size: 20px;
            letter-spacing: 3px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--color-border-main);
        }

        .map-info-bar {
            display: flex;
            justify-content: space-between;
            color: var(--color-text-secondary);
            font-size: 11px;
            letter-spacing: 1px;
            padding-bottom: 10px;
        }

        .map-container {
            flex: 1;
            background-color: var(--color-bg-panel-dark);
            border: 2px solid var(--color-border-main);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            clip-path: polygon(
                12px 0, 100% 0, 100% calc(100% - 12px),
                calc(100% - 12px) 100%, 0 100%, 0 12px
            );
            position: relative;
        }

        .map-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .no-map-message {
            color: var(--color-text-muted);
            font-size: 14px;
            letter-spacing: 2px;
            text-align: center;
        }

        /* Corner diagonal lines for angular panels */
        .map-container::before,
        .map-container::after,
        .dashboard-panel::before,
        .dashboard-panel::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .map-container::before {
            top: 0;
            left: 0;
        }

        .map-container::after {
            bottom: 0;
            right: 0;
        }

        /* 3D Star Map Background */
        #starmap-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;  /* Background layer */
            background-color: #000000;
        }

        /* Ensure all view content is above the star map */
        .standby-view,
        .campaign-dashboard,
        .map-container,
        .terminal-view {
            position: relative;
            z-index: 10;
        }

        .scanline-overlay {
            z-index: 100;  /* Scanlines on top of everything */
        }
    </style>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
    <!-- 3D Star Map Background Canvas -->
    <canvas id="starmap-canvas"></canvas>

    <!-- Scanline overlay covers entire screen -->
    <div class="scanline-overlay"></div>

    <!-- STANDBY VIEW -->
    {% if active_view.view_type == 'STANDBY' %}
    <div class="standby-view" id="standby-container">
        <div class="standby-logo">
            <div class="standby-text" data-text="MOTHERSHIP">MOTHERSHIP</div>
            <div class="standby-subtitle">The Outer Veil</div>
        </div>
    </div>

    <script>
    // Randomize glitch direction on each animation iteration
    (function() {
        const mainText = document.querySelector('.standby-text');
        const subtitle = document.querySelector('.standby-subtitle');

        function randomizeGlitchDirection(element) {
            // Random displacement between -35px and 35px
            const x1 = (Math.random() * 70 - 35).toFixed(0);
            const y1 = (Math.random() * 40 - 20).toFixed(0); // Less vertical range
            const x2 = (Math.random() * 60 - 30).toFixed(0);
            const y2 = (Math.random() * 40 - 20).toFixed(0);
            const x3 = (Math.random() * 40 - 20).toFixed(0);
            const y3 = (Math.random() * 30 - 15).toFixed(0);

            element.style.setProperty('--glitch-x1', `${x1}px`);
            element.style.setProperty('--glitch-y1', `${y1}px`);
            element.style.setProperty('--glitch-x2', `${x2}px`);
            element.style.setProperty('--glitch-y2', `${y2}px`);
            element.style.setProperty('--glitch-x3', `${x3}px`);
            element.style.setProperty('--glitch-y3', `${y3}px`);
        }

        // Randomize on animation iteration (each time animation completes a cycle)
        if (mainText) {
            mainText.addEventListener('animationiteration', () => {
                randomizeGlitchDirection(mainText);
            });
            // Randomize on load
            randomizeGlitchDirection(mainText);
        }

        if (subtitle) {
            subtitle.addEventListener('animationiteration', () => {
                randomizeGlitchDirection(subtitle);
            });
            // Randomize on load
            randomizeGlitchDirection(subtitle);
        }
    })();

    // Random text blocks generator for STANDBY view
    (function() {
        const container = document.getElementById('standby-container');
        if (!container) return;

        // Track active blocks for collision detection
        const activeBlocks = [];

        // Individual line snippets (will be randomly combined)
        const lineSnippets = [
            'SYSTEM ONLINE', 'ALL SYSTEMS NOMINAL', 'STANDBY MODE', 'AWAITING ORDERS',
            'QUANTUM FLUX DETECTED', 'STABILIZING FIELD', 'NEURAL INTERFACE ACTIVE',
            'SYNAPTIC LINK STABLE', 'BIOMETRIC SCAN COMPLETE', 'IDENTITY CONFIRMED',
            'HULL INTEGRITY: 98%', 'MINOR BREACH SEALED', 'LIFE SUPPORT: NOMINAL',
            'O2 LEVELS: OPTIMAL', 'REACTOR CORE: STABLE', 'POWER OUTPUT: 100%',
            'NAVIGATION READY', 'COORDINATES LOCKED', 'COMMS ARRAY: ONLINE',
            'SIGNAL STRENGTH: FULL', 'SENSOR SWEEP: CLEAR', 'NO CONTACTS DETECTED',
            'ENGINES: IDLE', 'FUEL: 87%', 'CARGO BAY: SECURE', 'CONTAINMENT HOLDING',
            'ATMOSPHERIC PRESSURE: STABLE', 'GRAVITY: 1.0G', 'SCANNING...',
            'ANALYSIS IN PROGRESS', 'PROCESSING...', 'DECRYPTING DATA',
            'INITIALIZING...', 'BOOT SEQUENCE ACTIVE', 'CRYO BAY: EMPTY',
            'ALL PODS DORMANT', 'MEDICAL: STANDBY', 'AUTO-DOC READY',
            'WEAPONS: OFFLINE', 'SAFETY PROTOCOLS ENGAGED', 'SHIELDS: CHARGING',
            '42% CAPACITY', 'JUMP DRIVE: READY', 'FTL AVAILABLE',
            'RADIATION LEVELS: SAFE', 'DOSE: 0.3 mSv', 'TARGETING SYSTEMS: OFFLINE',
            'PEACE MODE ACTIVE', 'DRONE BAY: SEALED', '3 UNITS READY',
            'MINING LASER: STANDBY', 'CAPACITOR CHARGED', 'EMERGENCY BEACON: ACTIVE',
            'BROADCASTING SOS', 'WARP CORE: STABLE', 'CONTAINMENT AT 100%',
            'AIRLOCK STATUS: SECURE', 'PRESSURE NOMINAL', 'LABORATORY: SEALED',
            'QUARANTINE ACTIVE', 'BRIDGE ACCESS: GRANTED', 'WELCOME COMMANDER',
            'UNKNOWN SIGNAL DETECTED', 'TRACKING SOURCE', 'HEAT SIGNATURE: ANOMALOUS',
            'INVESTIGATING', 'PROXIMITY ALERT', 'OBJECT AT 200M',
            'SYSTEM DIAGNOSTICS COMPLETE', 'NO ERRORS FOUND', 'FIRMWARE UPDATE AVAILABLE',
            'VERSION 3.7.2', 'BACKUP POWER: 100%', 'BATTERIES FULL',
            'WASTE RECYCLING: ACTIVE', 'EFFICIENCY: 94%', 'FOOD STORES: ADEQUATE',
            '142 DAYS REMAINING', 'WATER PURIFICATION: ONLINE', 'RESERVES: 89%',
            'SUIT TELEMETRY: NOMINAL', 'ALL CREW ACCOUNTED FOR', 'BLACK BOX: RECORDING',
            'FLIGHT DATA LOGGED', 'AUTO-PILOT: ENGAGED', 'COURSE LOCKED',
            'STELLAR CARTOGRAPHY', 'MAP UPDATE: 99%', 'ANOMALY DETECTED',
            'CLASSIFICATION: UNKNOWN', 'TEMPORAL DRIFT: MINIMAL', 'CHRONOMETER SYNCED',
            'EXOTIC MATTER: DETECTED', 'ANALYSIS PENDING', 'VOID EXPOSURE: MINIMAL',
            'CREW SAFETY: GREEN', 'DARK MATTER READINGS', 'THRESHOLD EXCEEDED',
            'SUBSPACE INTERFERENCE', 'COMPENSATING', 'ALIEN ARTIFACT DETECTED',
            'ORIGIN: UNKNOWN', 'DISTRESS CALL RECEIVED', 'INVESTIGATING TRANSMISSION'
        ];

        function getRandomLines() {
            // Random number of lines (1-4)
            const lineCount = Math.floor(Math.random() * 4) + 1;
            const selectedLines = [];

            // Pick random lines without repetition
            const availableLines = [...lineSnippets];
            for (let i = 0; i < lineCount; i++) {
                const randomIndex = Math.floor(Math.random() * availableLines.length);
                selectedLines.push('> ' + availableLines[randomIndex]);
                availableLines.splice(randomIndex, 1);
            }

            return selectedLines.join('\n');
        }

        function checkCollision(x, y, width, height) {
            // Check if this position overlaps with any existing blocks
            for (const block of activeBlocks) {
                if (!(x + width < block.x ||
                      x > block.x + block.width ||
                      y + height < block.y ||
                      y > block.y + block.height)) {
                    return true; // Collision detected
                }
            }
            return false;
        }

        function findSafePosition(width, height) {
            const maxAttempts = 50;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Random position (avoid center where main title is)
                let x = Math.random() * 80 + 10; // 10-90%
                let y = Math.random() * 80 + 10; // 10-90%

                // Avoid center area (30-70% range - larger exclusion zone)
                if (x > 30 && x < 70 && y > 30 && y < 70) {
                    // Push to edges if in center
                    if (Math.random() > 0.5) {
                        x = x < 50 ? x - 35 : x + 35;
                    } else {
                        y = y < 50 ? y - 35 : y + 35;
                    }
                }

                // Check collision
                if (!checkCollision(x, y, width, height)) {
                    return { x, y };
                }
            }

            // If we can't find a safe spot, return null
            return null;
        }

        function createTextBlock() {
            const text = getRandomLines();

            // Estimate size (rough approximation)
            const lineCount = text.split('\n').length;
            const maxLineLength = Math.max(...text.split('\n').map(line => line.length));
            const estimatedWidth = maxLineLength * 0.6; // Rough % of viewport width
            const estimatedHeight = lineCount * 2; // Rough % of viewport height

            // Find safe position
            const position = findSafePosition(estimatedWidth, estimatedHeight);
            if (!position) {
                // If no safe position found, skip this block
                return;
            }

            const block = document.createElement('div');
            block.className = 'text-block';
            block.style.left = position.x + '%';
            block.style.top = position.y + '%';

            container.appendChild(block);

            // Track this block
            const blockData = {
                element: block,
                x: position.x,
                y: position.y,
                width: estimatedWidth,
                height: estimatedHeight
            };
            activeBlocks.push(blockData);

            // Type out text character by character
            let currentText = '';
            let charIndex = 0;

            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    currentText += text[charIndex];
                    block.textContent = currentText;
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                }
            }, 50); // 50ms per character

            // Remove after fade animation completes
            setTimeout(() => {
                block.remove();
                // Remove from active blocks array
                const index = activeBlocks.indexOf(blockData);
                if (index > -1) {
                    activeBlocks.splice(index, 1);
                }
            }, 6000);
        }

        // Create text blocks at random intervals
        function spawnTextBlocks() {
            createTextBlock();

            // Schedule next block (random interval between 400ms and 1000ms - faster spawning)
            const nextDelay = Math.random() * 600 + 400;
            setTimeout(spawnTextBlocks, nextDelay);
        }

        // Start spawning after a short delay
        setTimeout(spawnTextBlocks, 500);
    })();
    </script>

    <!-- CAMPAIGN DASHBOARD VIEW -->
    {% elif active_view.view_type == 'CAMPAIGN_DASHBOARD' %}
    <div class="campaign-dashboard">
        <!-- Top Panel -->
        <div class="dashboard-top">
            <div class="dashboard-top-content">THE OUTER VEIL CAMPAIGN</div>
        </div>

        <!-- Left Panel - CREW -->
        <div class="dashboard-left">
            <div class="dashboard-panel-header">
                <h3>CREW</h3>
            </div>
            <div class="dashboard-panel-content">
                <p>&gt; Dr. Elena Vasquez - Science Officer</p>
                <p>&gt; Marcus "Wrench" Chen - Engineer</p>
                <p>&gt; Lt. Sarah Kim - Security</p>
                <p>&gt; Alex Novak - Pilot</p>
            </div>
        </div>

        <!-- Right Panel - MISSIONS -->
        <div class="dashboard-right">
            <div class="dashboard-panel-header">
                <h3>MISSIONS</h3>
            </div>
            <div class="dashboard-panel-content">
                <p style="margin-bottom: 10px;">&gt; [ACTIVE] Station Prometheus</p>
                <p style="margin-bottom: 10px;">&gt; [PENDING] Cargo Retrieval</p>
                <p style="margin-bottom: 10px;">&gt; [COMPLETED] Colony Supply Run</p>
            </div>
        </div>

        <!-- Bottom Panel -->
        <div class="dashboard-bottom">
            <div class="dashboard-panel-header">
                <h3>SHIP STATUS - USCSS MORRIGAN</h3>
            </div>
            <div class="dashboard-panel-content">
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px;">
                    <div>
                        <p>&gt; HULL: 100%</p>
                        <p>&gt; ENGINES: NOMINAL</p>
                    </div>
                    <div>
                        <p>&gt; LIFE SUPPORT: OK</p>
                        <p>&gt; O2 RESERVES: 94%</p>
                    </div>
                    <div>
                        <p>&gt; FUEL: 78%</p>
                        <p>&gt; POWER: STABLE</p>
                    </div>
                    <div>
                        <p>&gt; WEAPONS: OFFLINE</p>
                        <p>&gt; SHIELDS: CHARGING</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ENCOUNTER MAP VIEW -->
    {% elif active_view.view_type == 'ENCOUNTER_MAP' and location_data %}
    <div class="map-view">
        <div class="map-header">{{ location_data.name|upper }}</div>
        <div class="map-info-bar">
            <span>LOCATION: {{ location_data.coordinates|default:"UNKNOWN" }}</span>
            <span>TYPE: {{ location_data.type|default:"UNKNOWN"|upper }}</span>
            <span>STATUS: {{ location_data.status|default:"UNKNOWN"|upper }}</span>
        </div>
        <div class="map-container">
            {% if location_data.map.image_path %}
                <img src="/data/{{ location_data.map.image_path }}" alt="{{ location_data.map.name }}" class="map-image">
            {% else %}
                <div class="no-map-message">
                    <p>&gt; NO MAP AVAILABLE</p>
                    <p>&gt; {{ location_data.name|upper }}</p>
                </div>
            {% endif %}
        </div>
    </div>

    <!-- FALLBACK -->
    {% else %}
    <div class="standby-view">
        <div class="no-map-message">
            <p>&gt; TERMINAL STANDBY</p>
            <p>&gt; NO ACTIVE VIEW</p>
        </div>
    </div>
    {% endif %}

    <!-- Auto-refresh script -->
    <script>
    (function() {
        let currentViewState = {
            location_slug: '{{ active_view.location_slug|default:"" }}',
            view_type: '{{ active_view.view_type }}',
            view_slug: '{{ active_view.view_slug|default:"" }}',
            updated_at: '{{ active_view.updated_at|date:"Y-m-d H:i:s" }}'
        };

        function checkForViewChanges() {
            fetch('/api/active-view/')
                .then(response => response.json())
                .then(data => {
                    // Check if view has changed
                    if (data.location_slug !== currentViewState.location_slug ||
                        data.view_type !== currentViewState.view_type ||
                        data.view_slug !== currentViewState.view_slug) {

                        console.log('View changed - reloading');
                        window.location.reload();
                    }

                    // Update current state
                    currentViewState = {
                        location_slug: data.location_slug,
                        view_type: data.view_type,
                        view_slug: data.view_slug,
                        updated_at: data.updated_at
                    };
                })
                .catch(error => {
                    console.error('Error checking active view:', error);
                });
        }

        // Poll every 2 seconds
        setInterval(checkForViewChanges, 2000);
    })();
    </script>

    <!-- 3D Star Map Initialization -->
    <script>
    (function() {
        // Get the canvas
        const canvas = document.getElementById('starmap-canvas');
        if (!canvas) return;

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Array to store stars for animation
        const stars = [];

        // Create camera
        const camera = new THREE.PerspectiveCamera(
            75,  // FOV
            window.innerWidth / window.innerHeight,  // Aspect ratio
            0.1,  // Near plane
            1000  // Far plane
        );
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Create renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
        scene.add(ambientLight);

        // Create a simple starburst texture (like in the reference image)
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const centerX = 64;
            const centerY = 64;

            // Draw bright center core with glow
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            coreGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = coreGradient;
            ctx.fillRect(0, 0, 128, 128);

            // Draw simple 4-point cross
            ctx.globalCompositeOperation = 'lighter';
            drawSpike(ctx, centerX, centerY, 0, 50, 3);      // North
            drawSpike(ctx, centerX, centerY, 90, 50, 3);     // East
            drawSpike(ctx, centerX, centerY, 180, 50, 3);    // South
            drawSpike(ctx, centerX, centerY, 270, 50, 3);    // West

            // Apply blur for soft glow
            ctx.filter = 'blur(2px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';

            return new THREE.CanvasTexture(canvas);
        }

        // Helper function to draw a spike/ray
        function drawSpike(ctx, x, y, angle, length, width) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((angle * Math.PI) / 180);

            const gradient = ctx.createLinearGradient(0, 0, 0, length);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-width, length);
            ctx.lineTo(width, length);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Create the star texture once for reuse
        const starTexture = createStarTexture();

        // Create background star field using sprites (same texture as main stars)
        const starFieldCount = 5000;  // Number of background stars
        const backgroundStars = [];

        for (let i = 0; i < starFieldCount; i++) {
            // Random position in a large sphere
            const radius = 150 + Math.random() * 300;  // Distance from center
            const theta = Math.random() * Math.PI * 2;  // Horizontal angle
            const phi = Math.acos(2 * Math.random() - 1);  // Vertical angle (uniform distribution)

            const position = new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Create sprite with starburst texture
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,  // Random opacity 0.4-0.8
                blending: THREE.AdditiveBlending
            });

            const sprite = new THREE.Sprite(spriteMaterial);

            // Random size variation (smaller than main stars)
            const size = 0.5 + Math.random() * 1.5;  // Size 0.5 to 2.0
            sprite.scale.set(size, size, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            // Store for potential animation
            sprite.userData.baseOpacity = sprite.material.opacity;
            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

            scene.add(sprite);
            backgroundStars.push(sprite);
        }

        function createStar(size, position) {
            // Just use a sprite - no sphere core
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size * 6, size * 6, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            // Store sprite reference for animation
            sprite.userData.baseOpacity = 0.9;
            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

            return sprite;
        }

        // Load star map data and create stars
        fetch('/api/star-map/')
            .then(response => response.json())
            .then(data => {
                console.log('Star map data loaded:', data);

                // Create stars from data
                if (data.systems) {
                    data.systems.forEach(system => {
                        const position = new THREE.Vector3(
                            system.position[0],
                            system.position[1],
                            system.position[2]
                        );

                        const star = createStar(system.size || 1, position);

                        star.userData = {
                            name: system.name,
                            type: system.type
                        };

                        scene.add(star);

                        // Store star for animation
                        stars.push(star);

                        // Add point light at star position for subtle illumination
                        const starLight = new THREE.PointLight(0xFFFFFF, 0.3, 40);  // Pure white
                        starLight.position.copy(position);
                        scene.add(starLight);
                    });

                    console.log(`Loaded ${stars.length} stars for pulsing animation`);
                }

                // Create connection routes
                if (data.routes) {
                    const systemPositions = {};
                    data.systems.forEach(sys => {
                        systemPositions[sys.name] = sys.position;
                    });

                    data.routes.forEach(route => {
                        const fromPos = systemPositions[route.from];
                        const toPos = systemPositions[route.to];

                        if (fromPos && toPos) {
                            // Create start and end points
                            const start = new THREE.Vector3(fromPos[0], fromPos[1], fromPos[2]);
                            const end = new THREE.Vector3(toPos[0], toPos[1], toPos[2]);

                            // Calculate direction and distance
                            const direction = end.clone().sub(start);
                            const distance = direction.length();
                            direction.normalize();

                            // Shorten the line on both ends so it doesn't reach star centers
                            // Move start point away from star by 8 units
                            // Move end point away from star by 8 units
                            const offset = 8;
                            const shortenedStart = start.clone().add(direction.clone().multiplyScalar(offset));
                            const shortenedEnd = end.clone().sub(direction.clone().multiplyScalar(offset));

                            // Only create route if there's enough distance after shortening
                            if (distance > offset * 2) {
                                // Create a curve from start to end (full length for gradient)
                                const curve = new THREE.LineCurve3(start, end);

                                // Create tube geometry with more segments for smooth fade
                                const segments = 64;  // More segments for smooth gradient
                                const tubeGeometry = new THREE.TubeGeometry(
                                    curve,
                                    segments,  // Segments along the length
                                    0.3,       // Tube radius (thickness)
                                    8,         // Radial segments (smoothness)
                                    false      // Not closed
                                );

                                // Add vertex alpha values for fade effect
                                const positions = tubeGeometry.attributes.position;
                                const alphas = [];
                                const fadeDistance = 15;  // Distance over which to fade (in units)

                                // Calculate alpha for each vertex
                                for (let i = 0; i < positions.count; i++) {
                                    const vertex = new THREE.Vector3(
                                        positions.getX(i),
                                        positions.getY(i),
                                        positions.getZ(i)
                                    );

                                    // Calculate distance from both ends
                                    const distFromStart = vertex.distanceTo(start);
                                    const distFromEnd = vertex.distanceTo(end);

                                    // Calculate alpha from both ends (handles overlapping fades)
                                    let alphaFromStart = 1.0;
                                    let alphaFromEnd = 1.0;

                                    if (distFromStart < fadeDistance) {
                                        alphaFromStart = distFromStart / fadeDistance;
                                    }
                                    if (distFromEnd < fadeDistance) {
                                        alphaFromEnd = distFromEnd / fadeDistance;
                                    }

                                    // Use the minimum (most transparent) alpha
                                    const alpha = Math.min(alphaFromStart, alphaFromEnd);

                                    alphas.push(alpha);
                                }

                                tubeGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

                                // Custom shader material for vertex alpha
                                const material = new THREE.ShaderMaterial({
                                    uniforms: {
                                        color: { value: new THREE.Color(route.color || 0x5a7a9a) }
                                    },
                                    vertexShader: `
                                        attribute float alpha;
                                        varying float vAlpha;
                                        void main() {
                                            vAlpha = alpha;
                                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                        }
                                    `,
                                    fragmentShader: `
                                        uniform vec3 color;
                                        varying float vAlpha;
                                        void main() {
                                            gl_FragColor = vec4(color, vAlpha);
                                        }
                                    `,
                                    transparent: true,
                                    depthWrite: false
                                });

                                const tube = new THREE.Mesh(tubeGeometry, material);
                                scene.add(tube);
                            }
                        }
                    });
                }

                // Create nebulae clouds
                if (data.nebulae) {
                    // Create soft cloud texture for nebula particles (diffuse, no bright center)
                    function createNebulaTexture() {
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');

                        // Create soft gradient (visible but not too bright at center)
                        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');    // Soft center
                        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');  // Mid region
                        gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');  // Fade
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');    // Transparent edge

                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 64, 64);

                        return new THREE.CanvasTexture(canvas);
                    }

                    const nebulaTexture = createNebulaTexture();
                    const nebulaParticles = [];  // Store for animation

                    data.nebulae.forEach(nebula => {
                        const position = new THREE.Vector3(
                            nebula.position[0],
                            nebula.position[1],
                            nebula.position[2]
                        );

                        // Create spherical shell of particles
                        // Target radius for bright expansion front
                        const targetRadius = nebula.size * 0.85;
                        const shellThickness = nebula.size * 0.25;

                        for (let i = 0; i < nebula.particle_count; i++) {
                            // Random point on sphere using uniform distribution
                            const theta = Math.random() * Math.PI * 2;  // Azimuth: 0 to 2
                            const phi = Math.acos(2 * Math.random() - 1);  // Elevation: 0 to  (uniform)

                            // Distance from center (concentrated around target radius)
                            const radiusOffset = (Math.random() - 0.5) * shellThickness;
                            const radius = targetRadius + radiusOffset;

                            // Convert spherical to Cartesian coordinates
                            const x = radius * Math.sin(phi) * Math.cos(theta);
                            const y = radius * Math.sin(phi) * Math.sin(theta);
                            const z = radius * Math.cos(phi);

                            const particlePos = new THREE.Vector3(
                                position.x + x,
                                position.y + y,
                                position.z + z
                            );

                            // Particles closer to target radius are brighter (expansion front)
                            const distanceFromFront = Math.abs(radiusOffset);
                            const brightnessFactor = 1.0 - (distanceFromFront / (shellThickness / 2));
                            const particleOpacity = nebula.opacity * Math.max(0.3, brightnessFactor) * (0.6 + Math.random() * 0.4);

                            const spriteMaterial = new THREE.SpriteMaterial({
                                map: nebulaTexture,
                                color: nebula.color,
                                transparent: true,
                                opacity: particleOpacity,
                                blending: THREE.AdditiveBlending,
                                depthWrite: false
                            });

                            const sprite = new THREE.Sprite(spriteMaterial);

                            // Vary particle size
                            const size = (nebula.size / 5) * (0.5 + Math.random() * 0.8);
                            sprite.scale.set(size, size, 1);
                            sprite.position.copy(particlePos);

                            // Store metadata for animation
                            sprite.userData.nebulaType = nebula.type;
                            sprite.userData.baseOpacity = particleOpacity;
                            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

                            scene.add(sprite);
                            nebulaParticles.push(sprite);
                        }
                    });
                }

                console.log('Star map rendered');
            })
            .catch(error => {
                console.error('Error loading star map:', error);
            });

        // Animation loop with star pulsing
        function animate() {
            requestAnimationFrame(animate);

            // Pulse stars
            const time = Date.now() * 0.001; // Time in seconds
            stars.forEach(star => {
                if (star.userData.sprite) {
                    // Pulse between 0.4 and 1.0 opacity using sine wave (more dramatic)
                    const pulseSpeed = 2.0; // Speed of pulsing (faster)
                    const pulseAmount = 0.3; // How much to pulse (30% variation)
                    const pulse = Math.sin(time * pulseSpeed + star.userData.pulseOffset) * pulseAmount;

                    // Set opacity between 0.4 and 1.0
                    const newOpacity = 0.7 + pulse;
                    star.userData.sprite.material.opacity = Math.max(0.4, Math.min(1.0, newOpacity));
                }
            });

            // Animate nebula particles based on type
            if (typeof nebulaParticles !== 'undefined') {
                nebulaParticles.forEach(particle => {
                    const type = particle.userData.nebulaType;

                    if (type === 'emission') {
                        // Emission nebulae: Gentle pulsing (flickering ionized gas)
                        const pulseSpeed = 0.5;  // Slow pulse
                        const pulseAmount = 0.15;  // Subtle variation (15%)
                        const pulse = Math.sin(time * pulseSpeed + particle.userData.pulseOffset) * pulseAmount;
                        particle.material.opacity = particle.userData.baseOpacity * (1.0 + pulse);

                    } else if (type === 'planetary') {
                        // Planetary nebulae: Slow rotation around center
                        const angle = time * particle.userData.rotationSpeed;
                        const currentOffset = particle.position.clone().sub(particle.userData.nebulaCenter);
                        const distance = currentOffset.length();

                        // Rotate around Y-axis
                        const rotatedX = currentOffset.x * Math.cos(angle * 0.1) - currentOffset.z * Math.sin(angle * 0.1);
                        const rotatedZ = currentOffset.x * Math.sin(angle * 0.1) + currentOffset.z * Math.cos(angle * 0.1);

                        particle.position.set(
                            particle.userData.nebulaCenter.x + rotatedX,
                            particle.userData.nebulaCenter.y + currentOffset.y,
                            particle.userData.nebulaCenter.z + rotatedZ
                        );

                    } else if (type === 'reflection') {
                        // Reflection nebulae: Very subtle shimmer
                        const pulseSpeed = 0.3;
                        const pulseAmount = 0.08;  // Very subtle (8%)
                        const pulse = Math.sin(time * pulseSpeed + particle.userData.pulseOffset) * pulseAmount;
                        particle.material.opacity = particle.userData.baseOpacity * (1.0 + pulse);
                    }
                    // Dark nebulae: No animation (static dust clouds)
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Track where camera is looking (center point for rotation)
        const lookAtTarget = new THREE.Vector3(0, 0, 0);

        // Simple mouse wheel zoom
        let zoomSpeed = 5;      // Units to zoom per scroll
        let minDistance = 20;   // Minimum distance from center
        let maxDistance = 300;  // Maximum distance from center

        window.addEventListener('wheel', (event) => {
            event.preventDefault();

            // Calculate direction from camera to target
            const direction = lookAtTarget.clone().sub(camera.position).normalize();
            const currentDistance = camera.position.distanceTo(lookAtTarget);

            // Zoom in or out
            if (event.deltaY < 0) {
                // Zoom in
                const newDistance = currentDistance - zoomSpeed;
                if (newDistance >= minDistance) {
                    camera.position.add(direction.multiplyScalar(zoomSpeed));
                }
            } else {
                // Zoom out
                const newDistance = currentDistance + zoomSpeed;
                if (newDistance <= maxDistance) {
                    camera.position.add(direction.multiplyScalar(-zoomSpeed));
                }
            }
        }, { passive: false });

        // Touch pinch zoom (for mobile/tablet)
        let lastTouchDistance = 0;

        canvas.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            }
        });

        canvas.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();

                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const distance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                const delta = lastTouchDistance - distance;
                lastTouchDistance = distance;

                // Apply zoom
                if (delta > 0) {
                    // Pinch in (zoom out)
                    camera.position.z = Math.min(camera.position.z + zoomSpeed * 0.5, maxZoom);
                } else if (delta < 0) {
                    // Pinch out (zoom in)
                    camera.position.z = Math.max(camera.position.z - zoomSpeed * 0.5, minZoom);
                }
            }
        }, { passive: false });

        // Mouse and touch rotation controls
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let rotateSpeed = 0.005;

        // Mouse rotation
        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) {  // Left click only
                isDragging = true;
                previousPosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;

            const deltaX = event.clientX - previousPosition.x;
            const deltaY = event.clientY - previousPosition.y;

            // Rotate camera around center
            const offset = camera.position.clone().sub(lookAtTarget);
            const radius = offset.length();

            // Convert to spherical coordinates
            let theta = Math.atan2(offset.x, offset.z);
            let phi = Math.acos(offset.y / radius);

            // Update angles
            theta -= deltaX * rotateSpeed;
            phi -= deltaY * rotateSpeed;

            // Clamp phi to prevent flipping
            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            // Convert back to cartesian
            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            camera.position.copy(lookAtTarget).add(offset);
            camera.lookAt(lookAtTarget);

            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch rotation (single finger drag)
        let isTouching = false;

        canvas.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isTouching = true;
                previousPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        });

        canvas.addEventListener('touchmove', (event) => {
            if (isTouching && event.touches.length === 1) {
                event.preventDefault();

                const touch = event.touches[0];
                const deltaX = touch.clientX - previousPosition.x;
                const deltaY = touch.clientY - previousPosition.y;

                // Same rotation logic as mouse
                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / radius);

                theta -= deltaX * rotateSpeed;
                phi -= deltaY * rotateSpeed;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);

                previousPosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isTouching = false;
        });
    })();
    </script>
</body>
</html>
