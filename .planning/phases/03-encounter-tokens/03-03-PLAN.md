---
phase: 03-encounter-tokens
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/gm/TokenPalette.tsx
  - src/components/gm/TokenPalette.css
  - src/components/gm/EncounterPanel.tsx
  - src/components/domain/encounter/Token.tsx
  - src/components/domain/encounter/EncounterMapRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "GM can select a token type and name, then place it on the map"
    - "GM can drag tokens to new grid positions with snap-to-grid behavior"
    - "GM can change token status (wounded, dead, panicked, stunned, hidden)"
    - "GM can remove tokens from the encounter map"
    - "Token position changes persist to server and appear on player terminal"
  artifacts:
    - path: "src/components/gm/TokenPalette.tsx"
      provides: "Token type selector, name input, placed token list with status/remove controls"
      contains: "TokenPalette"
    - path: "src/components/gm/TokenPalette.css"
      provides: "Styling for token palette matching GM Console aesthetic"
      contains: "token-palette"
    - path: "src/components/gm/EncounterPanel.tsx"
      provides: "Extended encounter panel with token controls section"
      contains: "TokenPalette"
  key_links:
    - from: "src/components/gm/TokenPalette.tsx"
      to: "src/services/encounterApi.ts"
      via: "placeToken, removeToken, setTokenStatus API calls"
      pattern: "encounterApi\\.(placeToken|removeToken|setTokenStatus)"
    - from: "src/components/gm/EncounterPanel.tsx"
      to: "src/components/gm/TokenPalette.tsx"
      via: "TokenPalette component rendered in encounter controls"
      pattern: "<TokenPalette"
    - from: "src/components/domain/encounter/Token.tsx"
      to: "src/services/encounterApi.ts"
      via: "moveToken API call on drag end (GM mode)"
      pattern: "encounterApi\\.moveToken|onTokenMove"
---

<objective>
GM Console token controls and drag-to-move functionality on encounter maps.

Purpose: Give the GM the ability to place, move, remove, and set status on encounter tokens during gameplay from the GM Console interface.
Output: TokenPalette component in GM Console, drag-to-move on encounter map (GM only), full token lifecycle management.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-encounter-tokens/03-RESEARCH.md
@.planning/phases/03-encounter-tokens/03-01-SUMMARY.md
@src/components/gm/EncounterPanel.tsx
@src/components/domain/encounter/EncounterMapRenderer.tsx
@src/components/domain/encounter/Token.tsx
@src/services/encounterApi.ts
@src/types/encounterMap.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TokenPalette GM component with placement, status, and removal</name>
  <files>src/components/gm/TokenPalette.tsx, src/components/gm/TokenPalette.css, src/components/gm/EncounterPanel.tsx</files>
  <action>
1. Create `TokenPalette.tsx` with two sections: **Place New Token** and **Active Tokens**.

   **Place New Token section:**
   - Row of 4 type buttons (Player, NPC, Creature, Object) using Ant Design Button with amber highlight for selected type. Store selected type in useState.
   - Text input for token name (Ant Design Input, placeholder "Token name").
   - "PLACE TOKEN" button (Ant Design Button, type="primary", amber styled). On click:
     - Validate name is not empty (show message.warning if empty)
     - Call `encounterApi.placeToken(selectedType, tokenName, 0, 0)` to place at grid origin (0,0). GM will drag to final position.
     - On success: clear name input, call `onTokensChange(response.tokens)` callback
     - On error: show message.error

   **Active Tokens section:**
   - List (Ant Design List) of placed tokens from `tokens` prop (TokenState)
   - Each list item shows:
     - Colored dot matching token type (8px circle, inline CSS with type color)
     - Token name
     - Token grid position as "(x, y)" in muted text
     - Status tag buttons: Row of small toggle buttons for each status (wounded, dead, panicked, stunned, hidden). Each button toggles that status on/off. Use Ant Design Tag with checkable behavior. On toggle: call `encounterApi.setTokenStatus(tokenId, newStatusArray)`, then `onTokensChange(response.tokens)`.
     - Remove button: Small red "X" button. On click: call `encounterApi.removeToken(tokenId)`, then `onTokensChange(response.tokens)`.

   Props interface:
   ```typescript
   interface TokenPaletteProps {
     tokens: TokenState;
     onTokensChange: (tokens: TokenState) => void;
     isActive: boolean; // Disable when not in ENCOUNTER view
   }
   ```

2. Create `TokenPalette.css`:
   - `.token-palette` - padding, spacing
   - `.token-palette__type-btn--active` - amber background/border (#8b7355)
   - `.token-palette__token-dot` - 8px inline circle with type color
   - `.token-palette__status-tags` - flex wrap, gap: 4px
   - `.token-palette__status-tag--active` - amber border highlight
   - Match existing EncounterPanel card styling (dark background #1a1a1a, teal headers #5a7a7a)

3. Extend `EncounterPanel.tsx`:
   - Import TokenPalette and TokenState type
   - Add `tokens` state: `useState<TokenState>({})`
   - Add `onTokensChange` callback that updates local tokens state AND calls `onViewUpdate()` (triggers parent re-poll)
   - Sync tokens from `activeView`: Add useEffect that reads `activeView` polling data. Since tokens are in ActiveView, the GM Console's existing polling already includes them. Extract encounter_tokens from the GM Console's active view poll response.
   - Add a new Card section titled "TOKENS" (matching DECK LEVEL and ROOM VISIBILITY card styling) below the MAP PREVIEW card, containing `<TokenPalette>`.
   - Only show the TOKENS card when `isActive && hasEncounterMap` (same condition as other cards).

   For the GM Console's active view data, check how `activeView` prop is typed in EncounterPanel. It uses the `ActiveView` type from `@/types/gmConsole`. Since Plan 01 added `encounter_tokens` to that type, access it as `activeView?.encounter_tokens || {}`.

   Wire the useEffect to sync: when `activeView?.encounter_tokens` changes, update local `tokens` state.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Verify TokenPalette component exists and is imported in EncounterPanel. Check that all encounterApi functions are called correctly by searching for their usage.
  </verify>
  <done>GM Console shows TOKENS card in EncounterPanel with type selector, name input, and place button. Active tokens list shows each token with status toggles and remove button. Token state syncs from activeView polling.</done>
</task>

<task type="auto">
  <name>Task 2: Drag-to-move tokens on encounter map (GM mode)</name>
  <files>src/components/domain/encounter/Token.tsx, src/components/domain/encounter/EncounterMapRenderer.tsx</files>
  <action>
1. Extend `Token.tsx` to support dragging when `draggable` prop is true:

   Add props: `draggable?: boolean`, `onMove?: (x: number, y: number) => void`

   Implement native SVG drag using mousedown/mousemove/mouseup pattern from research:

   a. On mouseDown (when draggable):
      - `e.stopPropagation()` to prevent map pan
      - Set `isDragging` state to true
      - Get SVG element reference: `(e.target as SVGElement).ownerSVGElement`
      - Convert mouse clientX/clientY to SVG coordinates using `svg.createSVGPoint()` and `svg.getScreenCTM()?.inverse()` via `matrixTransform`
      - Store drag offset (mouse SVG position minus token's current SVG position)
      - Change cursor to 'grabbing'

   b. On mouseMove (global window listener, only when isDragging):
      - Convert mouse position to SVG coordinates (same transform method)
      - Calculate raw grid position: `(svgX - offsetX) / unitSize`, `(svgY - offsetY) / unitSize`
      - Snap to grid: `Math.round(rawX)`, `Math.round(rawY)`
      - Clamp to non-negative: `Math.max(0, snappedX)`, `Math.max(0, snappedY)`
      - Call `onMove(snappedX, snappedY)` for optimistic local update

   c. On mouseUp (global window listener):
      - Set isDragging to false
      - Remove global listeners (cleanup in useEffect)

   d. Add visual feedback: when isDragging, add class `encounter-map__token--dragging` (CSS: opacity 0.7, cursor: grabbing)

   e. Set cursor to 'grab' when draggable and not dragging

   Use `useRef` for the `<g>` element to find ownerSVGElement. Use `useEffect` with cleanup for global mouse listeners (add on drag start, remove on drag end).

   IMPORTANT: Store the SVG element ref at drag start time (not from the g ref, which may not have ownerSVGElement). Use `(e.currentTarget as SVGGElement).ownerSVGElement` in onMouseDown.

2. Extend `EncounterMapRenderer.tsx` for GM drag mode:

   Add props: `isGM?: boolean`, `onTokenMove?: (tokenId: string, x: number, y: number) => void`

   Pass to TokenLayer: `isGM` determines whether Token components get `draggable={true}`.

   Update TokenLayer to accept and pass through `isGM` and `onTokenMove` props.

   In TokenLayer, for each Token: `draggable={isGM}`, `onMove={isGM ? (x, y) => onTokenMove?.(tokenId, x, y) : undefined}`

   The `onTokenMove` callback in the GM Console flow should:
   - Optimistically update local token state (move token to new position immediately)
   - Debounce the API call: use a 300ms debounce on `encounterApi.moveToken()` to avoid flooding the server during drag. The immediate local update makes it feel responsive.

   Wire this in EncounterPanel: The MapPreview component already renders an EncounterMapRenderer. Add `isGM={true}` and `onTokenMove` handler to that MapPreview's EncounterMapRenderer. The handler should:
   - Update local tokens state optimistically
   - Debounce call to `encounterApi.moveToken(tokenId, x, y)`

   NOTE: The MapPreview component in EncounterPanel needs to pass through tokens and token handlers to its internal EncounterMapRenderer. Check MapPreview.tsx and extend its props to accept `tokens`, `isGM`, and `onTokenMove`.
  </action>
  <verify>
Run `npm run typecheck` to confirm no TypeScript errors. Run `npm run build` to verify production build. Verify Token.tsx has mouseDown handler with stopPropagation. Verify EncounterMapRenderer passes isGM and onTokenMove to TokenLayer.
  </verify>
  <done>GM can drag tokens on the encounter map preview in GM Console. Tokens snap to grid cells during drag. Position updates are debounced (300ms) and sent to the server. Local state updates optimistically for responsive feel. Players see updated positions on next poll cycle.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- `npm run build` succeeds
- TokenPalette appears in EncounterPanel with place/status/remove controls
- Token drag works in GM map preview with grid snapping
- Drag events don't propagate to map pan handler
- Token moves call encounterApi.moveToken with debouncing
- Status changes persist via encounterApi.setTokenStatus
</verification>

<success_criteria>
- GM can select token type and name, then place a token via the palette
- Placed tokens appear in the Active Tokens list with status toggles and remove button
- GM can toggle wound/dead/panicked/stunned/hidden statuses on individual tokens
- GM can remove tokens from the encounter map
- GM can drag tokens in the map preview with snap-to-grid behavior
- Dragging tokens does not pan the map
- Token position changes are debounced and persisted to the server
- Players see all token changes on their next poll cycle (2 seconds)
</success_criteria>

<output>
After completion, create `.planning/phases/03-encounter-tokens/03-03-SUMMARY.md`
</output>
