---
phase: 03-encounter-tokens
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/domain/encounter/TokenLayer.tsx
  - src/components/domain/encounter/Token.tsx
  - src/components/domain/encounter/TokenStatusOverlay.tsx
  - src/components/domain/encounter/TokenPopup.tsx
  - src/components/domain/encounter/EncounterMapRenderer.tsx
  - src/components/domain/encounter/EncounterMapRenderer.css
  - src/components/domain/encounter/EncounterView.tsx
  - src/components/domain/encounter/EncounterMapDisplay.tsx
  - src/entries/SharedConsole.tsx
autonomous: true

must_haves:
  truths:
    - "Tokens render as circular images clipped to round shape on the encounter map"
    - "Tokens without images show colored circle with initial as fallback"
    - "Token type is visually distinguished by colored glow (amber=player, teal=NPC, burgundy=creature, gray=object)"
    - "Token label shows initial by default, full name on hover"
    - "Status indicators (wounded, dead, panicked) display as overlays on tokens"
    - "Players only see tokens in revealed rooms"
    - "Player terminal polls and displays token updates via existing 2-second polling"
    - "Clicking a placed token shows inline popup with name, status, and remove button"
  artifacts:
    - path: "src/components/domain/encounter/TokenLayer.tsx"
      provides: "SVG group rendering all tokens with visibility filtering"
      contains: "TokenLayer"
    - path: "src/components/domain/encounter/Token.tsx"
      provides: "Individual token with circular image, glow, label, drag support"
      contains: "Token"
    - path: "src/components/domain/encounter/TokenStatusOverlay.tsx"
      provides: "Status indicator overlays (wounded dot, dead X, panicked ring)"
      contains: "TokenStatusOverlay"
    - path: "src/components/domain/encounter/TokenPopup.tsx"
      provides: "Inline popup near token with name, status toggles, remove button"
      contains: "TokenPopup"
    - path: "src/components/domain/encounter/EncounterMapRenderer.tsx"
      provides: "Extended with token layer, token props, and popup management"
      contains: "TokenLayer"
    - path: "src/entries/SharedConsole.tsx"
      provides: "Passes encounter_tokens from polling to EncounterView"
      contains: "encounter_tokens"
  key_links:
    - from: "src/entries/SharedConsole.tsx"
      to: "src/components/domain/encounter/EncounterView.tsx"
      via: "encounter_tokens prop from polling data"
      pattern: "encounter_tokens"
    - from: "src/components/domain/encounter/EncounterMapRenderer.tsx"
      to: "src/components/domain/encounter/TokenLayer.tsx"
      via: "TokenLayer rendered as SVG group above rooms"
      pattern: "<TokenLayer"
    - from: "src/components/domain/encounter/TokenLayer.tsx"
      to: "src/components/domain/encounter/Token.tsx"
      via: "Maps token state to Token components"
      pattern: "<Token"
---

<objective>
Token rendering on the encounter map: circular image tokens with type-colored glows, status overlays, inline popup, room-based visibility filtering, and player polling integration.

Purpose: Players and GM can see tokens on the encounter map. Tokens are per user decision: circular with clipped images, colored glow/shadow for type distinction, initial label by default with full name on hover, status indicators as overlays. Players only see tokens in revealed rooms.

Output: TokenLayer, Token, TokenStatusOverlay, TokenPopup components integrated into EncounterMapRenderer, with polling wire-up in SharedConsole.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-encounter-tokens/03-CONTEXT.md
@.planning/phases/03-encounter-tokens/03-RESEARCH.md
@.planning/phases/03-encounter-tokens/03-01-SUMMARY.md
@src/components/domain/encounter/EncounterMapRenderer.tsx
@src/components/domain/encounter/EncounterMapRenderer.css
@src/components/domain/encounter/EncounterView.tsx
@src/components/domain/encounter/EncounterMapDisplay.tsx
@src/entries/SharedConsole.tsx
@src/types/encounterMap.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Token, TokenStatusOverlay, TokenPopup, and TokenLayer components</name>
  <files>
    src/components/domain/encounter/Token.tsx
    src/components/domain/encounter/TokenStatusOverlay.tsx
    src/components/domain/encounter/TokenPopup.tsx
    src/components/domain/encounter/TokenLayer.tsx
    src/components/domain/encounter/EncounterMapRenderer.css
  </files>
  <action>
1. Create `src/components/domain/encounter/Token.tsx`:
   - Props: `id`, `data: TokenData`, `unitSize: number`, `draggable?: boolean`, `selected?: boolean`, `onSelect?: (id) => void`, `onDragStart?: (id, e) => void`
   - Calculate center position: `x * unitSize + unitSize / 2`, `y * unitSize + unitSize / 2`
   - Token radius: `unitSize * 0.4` (80% of cell per user decision)
   - Render as SVG `<g>` with transform to center position
   - **Circular image token (per user decision):** Use SVG `<clipPath>` with `<circle>` to clip image to round shape. Inside the clip, render `<image>` with the token's `image_url` (href attribute). Size image to fill the circle (width/height = tokenRadius * 2). Each token needs a unique clipPath id (use `token-clip-${id}`).
   - **Fallback for no image:** If `image_url` is empty, render a filled `<circle>` with the type-based color instead of an image. Add the initial letter as `<text>` centered in the circle.
   - **Type-colored glow/shadow (per user decision):** Render a slightly larger circle behind the token with SVG `<filter>` for glow effect. Colors: amber (#8b7355) for player, teal (#4a6b6b) for NPC, burgundy (#6b4a4a) for creature, gray (#5a5a5a) for object. Use `<feGaussianBlur>` with stdDeviation 3-4 to create soft glow on a circle slightly larger than the token. Define one filter per type in a `<defs>` block.
   - **Label (per user decision):** Show first initial by default below the token. On hover, show full name. Use two `<text>` elements: one with class `encounter-map__token-label--initial` showing first character of name, one with class `encounter-map__token-label--full` showing full name. Toggle via CSS hover.
   - Include `<TokenStatusOverlay>` component for status display
   - On mousedown: if draggable, call `onDragStart(id, e)` and `e.stopPropagation()` to prevent map panning
   - On click: call `onSelect(id)` to toggle popup
   - Cursor: `grab` when draggable, `pointer` otherwise
   - Add `data-token-id={id}` attribute
   - Add className based on type: `encounter-map__token encounter-map__token--${data.type}`
   - If `data.status.includes('hidden')`, add `encounter-map__token--hidden` class

2. Create `src/components/domain/encounter/TokenStatusOverlay.tsx`:
   - Props: `status: TokenStatus[]`, `tokenRadius: number`
   - Render status indicators positioned around the token perimeter:
     - `wounded`: Small red dot (#8b5555) radius 3px at top-right (cx=tokenRadius*0.7, cy=-tokenRadius*0.7), with CSS pulse animation class `status-indicator--wounded`
     - `dead`: Red X across the entire token (two diagonal lines from -tokenRadius to +tokenRadius), semi-transparent (opacity 0.7), stroke #8b5555 strokeWidth 3
     - `panicked`: Dashed amber ring (#8b7355) around the token (circle with r=tokenRadius+3, fill none, strokeDasharray="4 4"), with CSS pulse animation class `status-indicator--panicked`
     - `stunned`: Blue-gray dot (#5a6a7a) radius 3px at top-left (cx=-tokenRadius*0.7, cy=-tokenRadius*0.7)
   - Each indicator wrapped in `<g>` with appropriate className

3. Create `src/components/domain/encounter/TokenPopup.tsx`:
   - Props: `tokenId: string`, `data: TokenData`, `unitSize: number`, `position: {x: number, y: number}` (center of token in SVG coords), `onClose: () => void`, `onRemove?: (id: string) => void`, `onStatusToggle?: (id: string, status: TokenStatus) => void`, `isGM?: boolean`
   - Render as SVG `<foreignObject>` positioned near the token:
     - x = position.x + unitSize * 0.6 (offset right of token)
     - y = position.y - 70 (centered vertically)
     - width = 160, height = auto (use 180 as estimate)
   - Content (HTML div inside foreignObject):
     - Header: Token name in bold, type label in muted text
     - Status section: Current statuses displayed as small colored tags
     - If isGM: Status toggle buttons for wound/panick/stun (small buttons, toggle on click calling `onStatusToggle(tokenId, statusName)`)
     - If isGM: "REMOVE" button (red-ish, calls `onRemove(tokenId)`)
     - Close "X" button in top-right corner
   - Style: background #1a1a1a, border 1px solid #4a6b6b, border-radius 4px, padding 8px, font-family Cascadia Code, font-size 11px, color #9a9a9a
   - Prevent click events from propagating to map

4. Create `src/components/domain/encounter/TokenLayer.tsx`:
   - Props: `tokens: TokenState`, `unitSize: number`, `roomVisibility?: RoomVisibilityState`, `isGM?: boolean`, `onTokenMove?: (id: string, x: number, y: number) => void`, `onTokenRemove?: (id: string) => void`, `onTokenStatusToggle?: (id: string, status: TokenStatus) => void`, `selectedTokenId?: string | null`, `onTokenSelect?: (id: string | null) => void`
   - **Visibility filtering (per user decision):** Filter tokens based on room visibility:
     - If `isGM` is true: show ALL tokens (GM sees everything including tokens in hidden rooms)
     - If not GM (player view): only show tokens where the token's `room_id` is empty (unassigned) OR `roomVisibility[token.room_id] !== false`
   - Render `<g className="encounter-map__token-layer">` containing:
     - All visible Token components via `Object.entries(filteredTokens).map()`
     - TokenPopup for the selectedTokenId (if a token is selected)
   - Handle token selection: clicking a token toggles it as selected, clicking elsewhere deselects
   - Pass `isGM` to TokenPopup so it knows whether to show GM controls

5. Add CSS to `EncounterMapRenderer.css` for tokens (append to existing file):
   ```css
   /* === Token Layer === */
   .encounter-map__token { cursor: pointer; transition: opacity 0.2s ease; }
   .encounter-map__token[data-draggable="true"] { cursor: grab; }
   .encounter-map__token.is-dragging { opacity: 0.7; cursor: grabbing !important; }
   .encounter-map__token--hidden { opacity: 0.4; }

   /* Token labels - initial shown, full name on hover */
   .encounter-map__token-label { fill: #9a9a9a; font-size: 10px; font-family: 'Cascadia Code', monospace; pointer-events: none; user-select: none; }
   .encounter-map__token-label--full { display: none; }
   .encounter-map__token:hover .encounter-map__token-label--full { display: block; }
   .encounter-map__token:hover .encounter-map__token-label--initial { display: none; }

   /* Status indicator animations */
   @keyframes pulse-wounded { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
   @keyframes pulse-panicked { 0%, 100% { opacity: 1; stroke-width: 2; } 50% { opacity: 0.5; stroke-width: 3; } }
   .status-indicator--wounded { animation: pulse-wounded 1.5s ease-in-out infinite; }
   .status-indicator--panicked { animation: pulse-panicked 1s ease-in-out infinite; }

   /* Token popup */
   .token-popup { background: #1a1a1a; border: 1px solid #4a6b6b; border-radius: 4px; padding: 8px; font-family: 'Cascadia Code', monospace; font-size: 11px; color: #9a9a9a; }
   .token-popup__close { position: absolute; top: 2px; right: 4px; background: none; border: none; color: #5a5a5a; cursor: pointer; font-size: 14px; }
   .token-popup__close:hover { color: #9a9a9a; }
   .token-popup__name { color: #5a7a7a; font-weight: bold; margin-bottom: 4px; }
   .token-popup__type { color: #5a5a5a; font-size: 9px; text-transform: uppercase; letter-spacing: 1px; }
   .token-popup__status-btn { background: #2a3a3a; border: 1px solid #3a4a4a; color: #9a9a9a; padding: 2px 6px; margin: 2px; cursor: pointer; font-size: 9px; font-family: inherit; }
   .token-popup__status-btn--active { background: #4a6b6b; border-color: #5a7a7a; color: #d0d0d0; }
   .token-popup__remove-btn { background: #3a2a2a; border: 1px solid #5a3a3a; color: #8b5555; padding: 3px 8px; margin-top: 6px; cursor: pointer; font-size: 10px; font-family: inherit; width: 100%; }
   .token-popup__remove-btn:hover { background: #4a3a3a; }
   ```
  </action>
  <verify>
    Run `npm run typecheck` - no type errors.
  </verify>
  <done>
    Token component renders circular clipped images with type-colored glow. TokenStatusOverlay shows status indicators. TokenPopup shows inline details with GM controls. TokenLayer filters by room visibility. All styled with terminal aesthetic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate TokenLayer into EncounterMapRenderer and wire polling in SharedConsole</name>
  <files>
    src/components/domain/encounter/EncounterMapRenderer.tsx
    src/components/domain/encounter/EncounterView.tsx
    src/components/domain/encounter/EncounterMapDisplay.tsx
    src/entries/SharedConsole.tsx
  </files>
  <action>
1. Extend EncounterMapRenderer to accept and render tokens:
   - Add to EncounterMapRendererProps interface: `tokens?: TokenState`, `isGM?: boolean`, `onTokenMove?: (id: string, x: number, y: number) => void`, `onTokenRemove?: (id: string) => void`, `onTokenStatusToggle?: (id: string, status: TokenStatus) => void`
   - Import: `TokenLayer` from `./TokenLayer`, `TokenState`, `TokenStatus` from types
   - Add state: `const [selectedTokenId, setSelectedTokenId] = useState<string | null>(null);`
   - Render TokenLayer inside SVG, AFTER the POIs group (so tokens appear on top):
     ```tsx
     {tokens && Object.keys(tokens).length > 0 && (
       <TokenLayer
         tokens={tokens}
         unitSize={unitSize}
         roomVisibility={roomVisibility}
         isGM={isGM}
         onTokenMove={onTokenMove}
         onTokenRemove={onTokenRemove}
         onTokenStatusToggle={onTokenStatusToggle}
         selectedTokenId={selectedTokenId}
         onTokenSelect={setSelectedTokenId}
       />
     )}
     ```
   - Update `handleMouseDown` to also skip panning when clicking on tokens: add `target.closest('.encounter-map__token')` to the early-return conditions

2. Read EncounterMapDisplay.tsx to understand how it wraps EncounterMapRenderer. Extend its props to pass through token props: `tokens`, `isGM`, `onTokenMove`, `onTokenRemove`, `onTokenStatusToggle`. Pass them down to EncounterMapRenderer.

3. Extend EncounterView props to accept tokens:
   - Add `tokens?: TokenState`, `isGM?: boolean` to EncounterViewProps
   - Pass through to EncounterMapDisplay (or however the 2D map rendering is wired)

4. Wire token polling in SharedConsole.tsx:
   - Import `TokenState` from `@/types/encounterMap`
   - Add state: `const [encounterTokens, setEncounterTokens] = useState<TokenState>({});`
   - In the existing polling handler that fetches `/api/active-view/`, add after existing encounter fields: `setEncounterTokens(data.encounter_tokens || {});`
   - Pass `tokens={encounterTokens}` to the EncounterView component
   - Player view is read-only: `isGM={false}` (no move/remove/status handlers passed)
   - This means in the player view, TokenPopup shows name and status but no edit controls
  </action>
  <verify>
    Run `npm run typecheck` - no type errors.
    Run `npm run build` - no build errors.
  </verify>
  <done>
    EncounterMapRenderer renders tokens above all other map elements. Player terminal shows tokens via polling, filtered by room visibility. Clicking a token shows read-only popup. Full data flow: SharedConsole polling -> EncounterView -> EncounterMapDisplay -> EncounterMapRenderer -> TokenLayer -> Token components.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm run build` succeeds
3. Tokens placed via API appear on encounter map in player terminal
4. Tokens in hidden rooms are not visible to players
5. Tokens show circular image (or fallback initial) with colored glow
6. Status overlays (wounded, dead, panicked) display correctly
7. Clicking a token shows inline popup
</verification>

<success_criteria>
- Circular image tokens render on encounter map with type-colored glow/shadow
- Fallback appearance (colored circle + initial) works for tokens without images
- Label shows initial by default, full name on hover
- Status indicators display as overlays (wounded dot, dead X, panicked ring)
- Players only see tokens in revealed rooms
- Player terminal receives token updates via 2-second polling
- Clicking token shows inline popup with details
</success_criteria>

<output>
After completion, create `.planning/phases/03-encounter-tokens/03-02-SUMMARY.md`
</output>
