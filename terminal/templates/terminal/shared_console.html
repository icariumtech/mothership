<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MOTHERSHIP TERMINAL</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        /* V2-1 Color Palette */
        :root {
            --color-teal: #4a6b6b;
            --color-teal-bright: #5a7a7a;
            --color-amber: #8b7355;
            --color-amber-bright: #9a8065;
            --color-bg-primary: #0a0a0a;
            --color-bg-secondary: #1a1a1a;
            --color-bg-panel: #1a2525;
            --color-bg-panel-dark: #0f1515;
            --color-text-primary: #9a9a9a;
            --color-text-secondary: #7a7a7a;
            --color-text-muted: #5a5a5a;
            --color-border-main: #4a6b6b;
            --color-border-subtle: #2a3a3a;
            --color-active: #8b7355;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000; /* Black to match star map canvas */
            color: var(--color-text-primary);
            font-family: 'Cascadia Code', 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Scanline overlay - covers entire screen */
        .scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        /* ===================
           TERMINAL HEADER
           =================== */
        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 52px;
            padding: 0 40px 0 22px;
            background-color: #1a2828;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 1px,
                rgba(0, 0, 0, 0.3) 1px,
                rgba(0, 0, 0, 0.3) 2px
            );
            border-bottom: 1px solid var(--color-border-subtle);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .terminal-header-left {
            display: flex;
            gap: 20px;
            align-items: baseline;
        }

        .terminal-header h1 {
            font-size: 18px;
            letter-spacing: 3px;
            color: #5a7575;
            margin: 0;
            font-weight: normal;
            font-family: 'Cascadia Code', 'Courier New', monospace;
        }

        .terminal-header .subtitle {
            font-size: 18px;
            letter-spacing: 3px;
            color: #5a7575;
            margin: 0;
            font-weight: normal;
            font-family: 'Cascadia Code', 'Courier New', monospace;
        }

        .terminal-header-right {
            font-size: 11px;
            letter-spacing: 3px;
            color: #8b7355;
            font-family: 'Cascadia Code', 'Courier New', monospace;
        }

        /* Hide header in standby mode */
        body.standby-mode .terminal-header {
            display: none;
        }

        /* ===================
           STANDBY VIEW
           =================== */
        .standby-view {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            background-color: #2b2b2b; /* Charcoal background */
        }

        .standby-logo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .standby-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 96px;
            font-weight: 900;
            letter-spacing: 16px;
            color: #e0e0e0;
            text-align: center;
            opacity: 0.9;
            animation: aggressiveGlitch 3s infinite;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            /* CSS variables for random glitch direction */
            --glitch-x1: -35px;
            --glitch-y1: 0px;
            --glitch-x2: 30px;
            --glitch-y2: 0px;
            --glitch-x3: -20px;
            --glitch-y3: 0px;
        }

        .standby-subtitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 8px;
            color: #8b7355;
            text-align: center;
            opacity: 0.8;
            text-shadow: 0 0 15px rgba(139, 115, 85, 0.4);
            animation: aggressiveGlitch 3s infinite;
            animation-delay: 1.5s; /* Offset by half cycle so it glitches at different time */
            /* CSS variables for random glitch direction */
            --glitch-x1: -35px;
            --glitch-y1: 0px;
            --glitch-x2: 30px;
            --glitch-y2: 0px;
            --glitch-x3: -20px;
            --glitch-y3: 0px;
        }

        /* Aggressive random glitch effect with motion blur */
        @keyframes aggressiveGlitch {
            0%, 88%, 90%, 92%, 100% {
                transform: translate(0, 0) skewX(0deg);
                filter: brightness(1) blur(0px);
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            }
            89% {
                transform: translate(var(--glitch-x1), var(--glitch-y1)) skewX(-5deg);
                filter: brightness(1.3) contrast(1.2) blur(1.5px);
                text-shadow:
                    -5px 0 10px rgba(255, 0, 0, 0.5),
                    5px 0 10px rgba(0, 255, 255, 0.5),
                    -10px 0 15px rgba(255, 0, 0, 0.3),
                    -15px 0 20px rgba(255, 0, 0, 0.2),
                    -20px 0 25px rgba(255, 0, 0, 0.1);
            }
            89.5% {
                transform: translate(var(--glitch-x2), var(--glitch-y2)) skewX(5deg);
                filter: brightness(0.7) contrast(1.5) blur(1.5px);
                text-shadow:
                    5px 0 10px rgba(0, 255, 0, 0.5),
                    -5px 0 10px rgba(255, 0, 255, 0.5),
                    10px 0 15px rgba(0, 255, 0, 0.3),
                    15px 0 20px rgba(0, 255, 0, 0.2),
                    20px 0 25px rgba(0, 255, 0, 0.1);
            }
            91% {
                transform: translate(var(--glitch-x3), var(--glitch-y3)) skewX(3deg);
                filter: brightness(1.4) blur(1px);
                text-shadow:
                    0 0 30px rgba(255, 255, 255, 0.6),
                    -10px 0 20px rgba(255, 255, 255, 0.3),
                    -15px 0 25px rgba(255, 255, 255, 0.2);
            }
        }

        /* Random text blocks that appear around the screen */
        .text-block {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: white;
            white-space: pre-line;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 6s ease-in-out forwards;
            mask-image: radial-gradient(ellipse 100% 100% at 50% 50%, black 30%, transparent 80%);
            -webkit-mask-image: radial-gradient(ellipse 100% 100% at 50% 50%, black 30%, transparent 80%);
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            80% {
                opacity: 0.7;
            }
            100% {
                opacity: 0;
            }
        }

        /* ===================
           CAMPAIGN DASHBOARD VIEW
           =================== */

        /* STEP 1: GRID LAYOUT
           Easy to modify panel positions and sizes here! */
        .campaign-dashboard {
            width: 100vw;
            height: 100vh;
            background-color: transparent;
            display: grid;
            /* COLUMNS: left-width | center-width | right-width */
            grid-template-columns: 300px 1fr 300px;
            /* ROWS: top-height | main-height */
            grid-template-rows: 52px 1fr;
            /* NAME each grid area */
            grid-template-areas:
                "top-left top-center top-right"
                "left center right";
            gap: 30px;
            padding: 0 30px 30px 30px;  /* 30px spacing from edges (top right bottom left) */
        }

        /* STEP 2: PANEL POSITIONING
           Just assign grid-area + specific sizing */
        .dashboard-top {
            grid-area: top-center;
            width: 25vw;  /* Top panel width */
            justify-self: center;
        }

        .dashboard-left {
            grid-area: left;
            display: grid;
            grid-template-rows: 1fr 1fr;  /* Two equal-height panels */
            gap: 30px;  /* 30px between panels */
            min-height: 0;  /* Allow grid children to shrink below content size */
        }

        .dashboard-right {
            grid-area: right;
            display: grid;
            grid-template-rows: 1fr 1fr;  /* Two equal-height panels */
            gap: 30px;  /* 30px between panels */
            min-height: 0;  /* Allow grid children to shrink below content size */
        }

        /* STEP 3: REUSABLE PANEL STYLING */

        /* Base panel appearance */
        .panel-base {
            background-color: var(--color-bg-panel);
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;  /* Allow grid/flex children to shrink below content size */
        }

        /* Chamfered corner utilities (mix and match!) */
        .chamfer-tl {  /* Top-left chamfer */
            clip-path: polygon(
                12px 0, 100% 0, 100% 100%, 0 100%, 0 12px
            );
        }

        .chamfer-tr {  /* Top-right chamfer */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0, 100% 12px, 100% 100%, 0 100%
            );
        }

        .chamfer-bl {  /* Bottom-left chamfer */
            clip-path: polygon(
                0 0, 100% 0, 100% 100%, 12px 100%, 0 calc(100% - 12px)
            );
        }

        .chamfer-br {  /* Bottom-right chamfer */
            clip-path: polygon(
                0 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%
            );
        }

        .chamfer-tr-br {  /* Top-right + Bottom-right */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0,
                100% 12px, 100% calc(100% - 12px),
                calc(100% - 12px) 100%, 0 100%
            );
        }

        .chamfer-tl-bl {  /* Top-left + Bottom-left */
            clip-path: polygon(
                12px 0, 100% 0,
                100% 100%, 12px 100%,
                0 calc(100% - 12px), 0 12px
            );
        }

        .chamfer-bl-br {  /* Bottom-left + Bottom-right */
            clip-path: polygon(
                0 0, 100% 0,
                100% calc(100% - 12px), calc(100% - 12px) 100%,
                12px 100%, 0 calc(100% - 12px)
            );
        }

        .chamfer-tl-tr {  /* Top-left + Top-right */
            clip-path: polygon(
                0 12px, 12px 0,
                calc(100% - 12px) 0, 100% 12px,
                100% 100%, 0 100%
            );
        }

        .chamfer-tr-bl {  /* Top-right + Bottom-left */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0,
                100% 12px, 100% 100%,
                12px 100%, 0 calc(100% - 12px)
            );
        }

        .chamfer-tl-br {  /* Top-left + Bottom-right */
            clip-path: polygon(
                12px 0, 100% 0,
                100% calc(100% - 12px), calc(100% - 12px) 100%,
                0 100%, 0 12px
            );
        }

        /* Border utilities */
        .border-top    { box-shadow: inset 0 2px 0 0 var(--color-border-main); }
        .border-right  { box-shadow: inset -2px 0 0 0 var(--color-border-main); }
        .border-bottom { box-shadow: inset 0 -2px 0 0 var(--color-border-main); }
        .border-left   { box-shadow: inset 2px 0 0 0 var(--color-border-main); }

        /* All borders */
        .border-all {
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        /* Combine borders (common combinations) */
        .border-inner-top-right-bottom {  /* All except left */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main);
        }

        .border-inner-top-left-bottom {  /* All except right */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main);
        }

        .border-inner-left-right-bottom {  /* All except top */
            box-shadow:
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .border-inner-top-left-right {  /* All except bottom */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        /* Diagonal corner lines */
        .corner-line-tl::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr::before {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-bl::after {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* For panels with 2 diagonal corners, use pseudo-classes */
        .corner-line-tr-br::before {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-bl::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-bl::after {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-bl-br::before {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-bl-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-tr::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-tr::after {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr-bl::before {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr-bl::after {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-br::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* Panel-specific styles */
        .dashboard-top {
            align-items: center;
            justify-content: center;
        }

        .dashboard-top-content {
            color: var(--color-teal);
            font-size: 18px;
            letter-spacing: 3px;
        }

        /* Panel Headers */
        .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 13px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 10px 5px 10px;
            border-bottom: 1px solid var(--color-border-subtle);
        }

        /* Adjust h3 padding for chamfered corners */
        .chamfer-tr .dashboard-panel-header h3,
        .chamfer-tr-br .dashboard-panel-header h3 {
            padding-right: 22px; /* 10px base + 12px for corner */
        }

        .chamfer-tl .dashboard-panel-header h3,
        .chamfer-tl-bl .dashboard-panel-header h3,
        .chamfer-tl-tr .dashboard-panel-header h3 {
            padding-left: 22px; /* 10px base + 12px for corner */
        }

        .chamfer-tl-tr .dashboard-panel-header h3 {
            padding-right: 22px; /* Both corners */
        }

        /* Panel Content Areas */
        .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            margin-bottom: 2px;
            margin-left: 2px;
            margin-right: 2px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            color: var(--color-text-primary);
            font-size: 12px;
            line-height: 1.6;
        }

        /* Scrollbar styling */
        .dashboard-panel-content::-webkit-scrollbar {
            width: 10px;
        }

        .dashboard-panel-content::-webkit-scrollbar-track {
            background: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            border: none;
            margin-top: 2px;
            margin-bottom: 2px;
        }

        .dashboard-panel-content::-webkit-scrollbar-thumb {
            background: #0f1515;
            border: 1px solid #4a6b6b;
        }

        .dashboard-panel-content::-webkit-scrollbar-thumb:hover {
            background: #1a2525;
        }

        .dashboard-panel-content::-webkit-scrollbar-button {
            display: none;
        }

        /* Right panel subsections */
        .right-section {
            background-color: var(--color-bg-panel-dark);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .right-section .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .right-section .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 11px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 22px 5px 22px;
            border-bottom: 1px solid var(--color-border-subtle);
        }

        .right-section .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            margin: 2px 5px 2px 2px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            color: var(--color-text-primary);
            font-size: 11px;
            line-height: 1.6;
        }

        /* Star system buttons */
        /* Star system buttons - styled like GM console location rows */
        .star-system-row {
            display: flex;
            align-items: center;
            padding: 0;
            margin: 4px 0;
            border: 1px solid var(--color-border-subtle);
            background-color: var(--color-bg-primary);
            transition: all 0.2s;
        }

        .star-system-row:hover {
            background-color: var(--color-bg-panel-dark);
        }

        .star-system-row.checked {
            border-color: var(--color-active);
            background-color: var(--color-bg-panel-dark);
        }

        .star-system-content {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 8px 6px;
            cursor: pointer;
        }

        .star-system-checkbox {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            border: 1px solid var(--color-teal);
            background-color: var(--color-bg-primary);
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            border-radius: 50%;  /* Make it circular like a radio button */
        }

        .star-system-row.checked .star-system-checkbox {
            background-color: var(--color-active);
            border-color: var(--color-active);
        }

        .star-system-checkbox::after {
            content: '●';
            color: var(--color-bg-primary);
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .star-system-row.checked .star-system-checkbox::after {
            opacity: 1;
        }

        .star-system-name {
            color: var(--color-teal-bright);
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 0.5px;
            flex-grow: 1;
            user-select: none;
        }

        /* Facility indicators */
        .facility-indicators {
            display: flex;
            gap: 4px;
            margin-left: auto;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .facility-indicator {
            width: 8px;
            height: 8px;
            background-color: var(--color-amber);
        }

        .facility-square {
            /* Square is the default shape */
        }

        .facility-triangle {
            /* Create triangle using clip-path */
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        /* System map button for star systems */
        .system-map-btn-container {
            flex-shrink: 0;
            background-color: var(--color-bg-panel-dark);
            border-left: 1px solid var(--color-border-subtle);
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 48px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .system-map-btn-container:hover {
            background-color: var(--color-bg-panel);
        }

        .system-map-btn-icon {
            color: var(--color-teal);
            font-size: 16px;
        }

        /* Momentary flash effect for system map button */
        @keyframes flash-system-map {
            0% {
                background-color: var(--color-active);
            }
            100% {
                background-color: var(--color-bg-panel-dark);
            }
        }

        .system-map-btn-container.flashing {
            animation: flash-system-map 0.5s ease-out;
        }

        .system-map-btn-container.flashing .system-map-btn-icon {
            animation: flash-system-map-icon 0.5s ease-out;
        }

        @keyframes flash-system-map-icon {
            0% {
                color: var(--color-bg-primary);
            }
            100% {
                color: var(--color-teal);
            }
        }

        /* Orbit map drill-down button (same style as system map button) */
        .orbit-map-btn-container {
            flex-shrink: 0;
            background-color: var(--color-bg-panel-dark);
            border-left: 1px solid var(--color-border-subtle);
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 48px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .orbit-map-btn-container:hover {
            background-color: var(--color-bg-panel);
        }

        .orbit-map-btn-icon {
            color: var(--color-teal);
            font-size: 16px;
        }

        /* System Info Panel */
        .system-info-panel {
            position: absolute;
            right: calc(300px + 30px + 30px);  /* right panel width + gap + margin */
            top: 82px;  /* 52px header + 30px gap to align with star map panel */
            width: 350px;
            height: auto;  /* Dynamic height based on content */
            max-height: calc(100vh - 82px - 30px);  /* Don't exceed viewport minus top offset and bottom margin */
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            background-color: var(--color-bg-panel);
            display: flex;
            flex-direction: column;

            /* Larger bottom-right chamfer (48px), keep top-left at 12px */
            clip-path: polygon(
                12px 0, 100% 0,
                100% calc(100% - 48px), calc(100% - 48px) 100%,
                0 100%, 0 12px
            );

            /* Borders using box-shadow to prevent clipping */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .system-info-panel.visible {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .system-info-panel .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .system-info-panel .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 13px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 10px 5px 22px;  /* Extra left padding to avoid top-left chamfer */
            border-bottom: 1px solid var(--color-border-subtle);
        }

        .system-info-panel .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            margin: 2px 5px 2px 2px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
        }

        #system-info-content {
            line-height: 1.8;
        }

        #system-info-content p {
            margin: 8px 0;
            color: var(--color-text-primary);
            font-size: 12px;
        }

        #system-info-content .info-label {
            color: var(--color-teal);
            font-weight: bold;
            letter-spacing: 1px;
        }

        #system-info-content .info-value {
            color: var(--color-amber);
        }

        /* Indicator boxes along bottom of system info panel */
        .system-info-indicator-boxes {
            position: absolute;
            right: calc(300px + 30px + 30px + 58px);  /* Panel right + space for chamfer (48px) + margin (10px) */
            width: 278px;  /* Exactly 12 boxes: (12 × 14px boxes) + (11 × 10px gaps) = 278px */
            height: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: repeating-linear-gradient(
                to right,
                #6b4a4a 0px,  /* Muted burgundy/wine color */
                #6b4a4a 14px,
                transparent 14px,
                transparent 24px
            );
            pointer-events: none;
        }

        .system-info-indicator-boxes.visible {
            opacity: 0.7;
        }

        /* Rectangle decoration extending from boxes to panel edge */
        .system-info-rectangle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            height: 14px;  /* Same height as indicator boxes */
            background-color: #6b4a4a;
        }

        .system-info-rectangle.visible {
            opacity: 0.6;
        }

        /* Triangle decoration on top of rectangle */
        .system-info-triangle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            height: 35px;  /* Triangle height */
            background-color: #6b4a4a;
            clip-path: polygon(0 100%, 100% 100%, 100% 0);  /* Right triangle: bottom-left, bottom-right, top-right */
        }

        .system-info-triangle.visible {
            opacity: 0.6;
        }

        /* Top-left corner line (12px) */
        .system-info-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
            z-index: 1;
        }

        /* Bottom-right corner line (48px) */
        .system-info-panel::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 48px;
            height: 48px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
            z-index: 1;
        }

        /* ===================
           ENCOUNTER MAP VIEW
           =================== */
        .map-view {
            width: 100vw;
            height: 100vh;
            background-color: var(--color-bg-primary);
            padding: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .map-header {
            color: var(--color-teal);
            font-size: 20px;
            letter-spacing: 3px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--color-border-main);
        }

        .map-info-bar {
            display: flex;
            justify-content: space-between;
            color: var(--color-text-secondary);
            font-size: 11px;
            letter-spacing: 1px;
            padding-bottom: 10px;
        }

        .map-container {
            flex: 1;
            background-color: var(--color-bg-panel-dark);
            border: 2px solid var(--color-border-main);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            clip-path: polygon(
                12px 0, 100% 0, 100% calc(100% - 12px),
                calc(100% - 12px) 100%, 0 100%, 0 12px
            );
            position: relative;
        }

        .map-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .no-map-message {
            color: var(--color-text-muted);
            font-size: 14px;
            letter-spacing: 2px;
            text-align: center;
        }

        /* Corner diagonal lines for angular panels */
        .map-container::before,
        .map-container::after,
        .dashboard-panel::before,
        .dashboard-panel::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .map-container::before {
            top: 0;
            left: 0;
        }

        .map-container::after {
            bottom: 0;
            right: 0;
        }

        /* 3D Star Map Background */
        #starmap-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;  /* Background layer */
            background-color: #000000;
        }

        /* 3D System Map Background */
        #systemmap-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;  /* Background layer */
            background-color: #000000;
        }

        /* Ensure all view content is above the star map */
        .standby-view,
        .campaign-dashboard,
        .map-container,
        .terminal-view {
            position: relative;
            z-index: 10;
        }

        .scanline-overlay {
            z-index: 100;  /* Scanlines on top of everything */
        }
    </style>

    <!-- Three.js Library (ES Module via Import Map) -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <!-- GSAP Animation Library -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>
<body{% if active_view.view_type == 'STANDBY' %} class="standby-mode"{% endif %}>
    <!-- Terminal Header -->
    <div class="terminal-header">
        <div class="terminal-header-left">
            <h1>MOTHERSHIP TERMINAL SYSTEM</h1>
            <div class="subtitle"></div>
        </div>
        <div class="terminal-header-right">
            STATION ACCESS
        </div>
    </div>

    <!-- 3D Star Map Background Canvas -->
    <canvas id="starmap-canvas"></canvas>

    <!-- 3D System Map Canvas (shown when viewing individual star systems) -->
    <canvas id="systemmap-canvas" style="display: none;"></canvas>

    <!-- Scanline overlay covers entire screen -->
    <div class="scanline-overlay"></div>

    <!-- STANDBY VIEW -->
    {% if active_view.view_type == 'STANDBY' %}
    <div class="standby-view" id="standby-container">
        <div class="standby-logo">
            <div class="standby-text" data-text="MOTHERSHIP">MOTHERSHIP</div>
            <div class="standby-subtitle">The Outer Veil</div>
        </div>
    </div>

    <script>
    // Randomize glitch direction on each animation iteration
    (function() {
        const mainText = document.querySelector('.standby-text');
        const subtitle = document.querySelector('.standby-subtitle');

        function randomizeGlitchDirection(element) {
            // Random displacement between -35px and 35px
            const x1 = (Math.random() * 70 - 35).toFixed(0);
            const y1 = (Math.random() * 40 - 20).toFixed(0); // Less vertical range
            const x2 = (Math.random() * 60 - 30).toFixed(0);
            const y2 = (Math.random() * 40 - 20).toFixed(0);
            const x3 = (Math.random() * 40 - 20).toFixed(0);
            const y3 = (Math.random() * 30 - 15).toFixed(0);

            element.style.setProperty('--glitch-x1', `${x1}px`);
            element.style.setProperty('--glitch-y1', `${y1}px`);
            element.style.setProperty('--glitch-x2', `${x2}px`);
            element.style.setProperty('--glitch-y2', `${y2}px`);
            element.style.setProperty('--glitch-x3', `${x3}px`);
            element.style.setProperty('--glitch-y3', `${y3}px`);
        }

        // Randomize on animation iteration (each time animation completes a cycle)
        if (mainText) {
            mainText.addEventListener('animationiteration', () => {
                randomizeGlitchDirection(mainText);
            });
            // Randomize on load
            randomizeGlitchDirection(mainText);
        }

        if (subtitle) {
            subtitle.addEventListener('animationiteration', () => {
                randomizeGlitchDirection(subtitle);
            });
            // Randomize on load
            randomizeGlitchDirection(subtitle);
        }
    })();

    // Random text blocks generator for STANDBY view
    (function() {
        const container = document.getElementById('standby-container');
        if (!container) return;

        // Track active blocks for collision detection
        const activeBlocks = [];

        // Individual line snippets (will be randomly combined)
        const lineSnippets = [
            'SYSTEM ONLINE', 'ALL SYSTEMS NOMINAL', 'STANDBY MODE', 'AWAITING ORDERS',
            'QUANTUM FLUX DETECTED', 'STABILIZING FIELD', 'NEURAL INTERFACE ACTIVE',
            'SYNAPTIC LINK STABLE', 'BIOMETRIC SCAN COMPLETE', 'IDENTITY CONFIRMED',
            'HULL INTEGRITY: 98%', 'MINOR BREACH SEALED', 'LIFE SUPPORT: NOMINAL',
            'O2 LEVELS: OPTIMAL', 'REACTOR CORE: STABLE', 'POWER OUTPUT: 100%',
            'NAVIGATION READY', 'COORDINATES LOCKED', 'COMMS ARRAY: ONLINE',
            'SIGNAL STRENGTH: FULL', 'SENSOR SWEEP: CLEAR', 'NO CONTACTS DETECTED',
            'ENGINES: IDLE', 'FUEL: 87%', 'CARGO BAY: SECURE', 'CONTAINMENT HOLDING',
            'ATMOSPHERIC PRESSURE: STABLE', 'GRAVITY: 1.0G', 'SCANNING...',
            'ANALYSIS IN PROGRESS', 'PROCESSING...', 'DECRYPTING DATA',
            'INITIALIZING...', 'BOOT SEQUENCE ACTIVE', 'CRYO BAY: EMPTY',
            'ALL PODS DORMANT', 'MEDICAL: STANDBY', 'AUTO-DOC READY',
            'WEAPONS: OFFLINE', 'SAFETY PROTOCOLS ENGAGED', 'SHIELDS: CHARGING',
            '42% CAPACITY', 'JUMP DRIVE: READY', 'FTL AVAILABLE',
            'RADIATION LEVELS: SAFE', 'DOSE: 0.3 mSv', 'TARGETING SYSTEMS: OFFLINE',
            'PEACE MODE ACTIVE', 'DRONE BAY: SEALED', '3 UNITS READY',
            'MINING LASER: STANDBY', 'CAPACITOR CHARGED', 'EMERGENCY BEACON: ACTIVE',
            'BROADCASTING SOS', 'WARP CORE: STABLE', 'CONTAINMENT AT 100%',
            'AIRLOCK STATUS: SECURE', 'PRESSURE NOMINAL', 'LABORATORY: SEALED',
            'QUARANTINE ACTIVE', 'BRIDGE ACCESS: GRANTED', 'WELCOME COMMANDER',
            'UNKNOWN SIGNAL DETECTED', 'TRACKING SOURCE', 'HEAT SIGNATURE: ANOMALOUS',
            'INVESTIGATING', 'PROXIMITY ALERT', 'OBJECT AT 200M',
            'SYSTEM DIAGNOSTICS COMPLETE', 'NO ERRORS FOUND', 'FIRMWARE UPDATE AVAILABLE',
            'VERSION 3.7.2', 'BACKUP POWER: 100%', 'BATTERIES FULL',
            'WASTE RECYCLING: ACTIVE', 'EFFICIENCY: 94%', 'FOOD STORES: ADEQUATE',
            '142 DAYS REMAINING', 'WATER PURIFICATION: ONLINE', 'RESERVES: 89%',
            'SUIT TELEMETRY: NOMINAL', 'ALL CREW ACCOUNTED FOR', 'BLACK BOX: RECORDING',
            'FLIGHT DATA LOGGED', 'AUTO-PILOT: ENGAGED', 'COURSE LOCKED',
            'STELLAR CARTOGRAPHY', 'MAP UPDATE: 99%', 'ANOMALY DETECTED',
            'CLASSIFICATION: UNKNOWN', 'TEMPORAL DRIFT: MINIMAL', 'CHRONOMETER SYNCED',
            'EXOTIC MATTER: DETECTED', 'ANALYSIS PENDING', 'VOID EXPOSURE: MINIMAL',
            'CREW SAFETY: GREEN', 'DARK MATTER READINGS', 'THRESHOLD EXCEEDED',
            'SUBSPACE INTERFERENCE', 'COMPENSATING', 'ALIEN ARTIFACT DETECTED',
            'ORIGIN: UNKNOWN', 'DISTRESS CALL RECEIVED', 'INVESTIGATING TRANSMISSION'
        ];

        function getRandomLines() {
            // Random number of lines (1-4)
            const lineCount = Math.floor(Math.random() * 4) + 1;
            const selectedLines = [];

            // Pick random lines without repetition
            const availableLines = [...lineSnippets];
            for (let i = 0; i < lineCount; i++) {
                const randomIndex = Math.floor(Math.random() * availableLines.length);
                selectedLines.push('> ' + availableLines[randomIndex]);
                availableLines.splice(randomIndex, 1);
            }

            return selectedLines.join('\n');
        }

        function checkCollision(x, y, width, height) {
            // Check if this position overlaps with any existing blocks
            for (const block of activeBlocks) {
                if (!(x + width < block.x ||
                      x > block.x + block.width ||
                      y + height < block.y ||
                      y > block.y + block.height)) {
                    return true; // Collision detected
                }
            }
            return false;
        }

        function findSafePosition(width, height) {
            const maxAttempts = 50;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Random position (avoid center where main title is)
                let x = Math.random() * 80 + 10; // 10-90%
                let y = Math.random() * 80 + 10; // 10-90%

                // Avoid center area (30-70% range - larger exclusion zone)
                if (x > 30 && x < 70 && y > 30 && y < 70) {
                    // Push to edges if in center
                    if (Math.random() > 0.5) {
                        x = x < 50 ? x - 35 : x + 35;
                    } else {
                        y = y < 50 ? y - 35 : y + 35;
                    }
                }

                // Check collision
                if (!checkCollision(x, y, width, height)) {
                    return { x, y };
                }
            }

            // If we can't find a safe spot, return null
            return null;
        }

        function createTextBlock() {
            const text = getRandomLines();

            // Estimate size (rough approximation)
            const lineCount = text.split('\n').length;
            const maxLineLength = Math.max(...text.split('\n').map(line => line.length));
            const estimatedWidth = maxLineLength * 0.6; // Rough % of viewport width
            const estimatedHeight = lineCount * 2; // Rough % of viewport height

            // Find safe position
            const position = findSafePosition(estimatedWidth, estimatedHeight);
            if (!position) {
                // If no safe position found, skip this block
                return;
            }

            const block = document.createElement('div');
            block.className = 'text-block';
            block.style.left = position.x + '%';
            block.style.top = position.y + '%';

            container.appendChild(block);

            // Track this block
            const blockData = {
                element: block,
                x: position.x,
                y: position.y,
                width: estimatedWidth,
                height: estimatedHeight
            };
            activeBlocks.push(blockData);

            // Type out text character by character
            let currentText = '';
            let charIndex = 0;

            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    currentText += text[charIndex];
                    block.textContent = currentText;
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                }
            }, 50); // 50ms per character

            // Remove after fade animation completes
            setTimeout(() => {
                block.remove();
                // Remove from active blocks array
                const index = activeBlocks.indexOf(blockData);
                if (index > -1) {
                    activeBlocks.splice(index, 1);
                }
            }, 6000);
        }

        // Create text blocks at random intervals
        function spawnTextBlocks() {
            createTextBlock();

            // Schedule next block (random interval between 400ms and 1000ms - faster spawning)
            const nextDelay = Math.random() * 600 + 400;
            setTimeout(spawnTextBlocks, nextDelay);
        }

        // Start spawning after a short delay
        setTimeout(spawnTextBlocks, 500);
    })();
    </script>

    <!-- CAMPAIGN DASHBOARD VIEW -->
    {% elif active_view.view_type == 'CAMPAIGN_DASHBOARD' %}
    <div class="campaign-dashboard">
        <!-- Top Panel -->
        <div class="dashboard-top panel-base chamfer-bl-br border-all corner-line-bl-br">
            <div class="dashboard-top-content">THE OUTER VEIL CAMPAIGN</div>
        </div>

        <!-- Left Column - Two Panels -->
        <div class="dashboard-left">
            <!-- Left Top Panel - CREW -->
            <div class="panel-base chamfer-tr-bl border-all corner-line-tr-bl">
                <div class="dashboard-panel-header">
                    <h3>CREW</h3>
                </div>
                <div class="dashboard-panel-content">
                    <p>&gt; Dr. Elena Vasquez - Science Officer</p>
                    <p>&gt; Marcus "Wrench" Chen - Engineer</p>
                    <p>&gt; Lt. Sarah Kim - Security</p>
                    <p>&gt; Alex Novak - Pilot</p>
                </div>
            </div>

            <!-- Left Bottom Panel - NOTES -->
            <div class="panel-base chamfer-tr-bl border-all corner-line-tr-bl">
                <div class="dashboard-panel-header">
                    <h3>NOTES</h3>
                </div>
                <div class="dashboard-panel-content">
                    <p>&gt; Investigating anomalous readings</p>
                    <p>&gt; Specimen requires containment</p>
                    <p>&gt; Station comms experiencing intermittent interference</p>
                    <p>&gt; Crew morale declining - recommend shore leave</p>
                    <p>&gt; Unexplained power fluctuations in sector 7</p>
                    <p>&gt; Medical bay reports increased stress cases</p>
                    <p>&gt; Supply chain delays expected - ration accordingly</p>
                    <p>&gt; Scanning unknown vessel at coordinates 45.2, -12.7</p>
                    <p>&gt; Engineering requesting additional hands for repairs</p>
                    <p>&gt; Security alert: unauthorized access attempt logged</p>
                    <p>&gt; Navigation system recalibration scheduled 0800 hours</p>
                    <p>&gt; Atmospheric readings nominal across all decks</p>
                    <p>&gt; Distress beacon detected from mining outpost</p>
                    <p>&gt; Cargo manifest discrepancies under investigation</p>
                    <p>&gt; Life support systems operating at 98% efficiency</p>
                    <p>&gt; Recommend full diagnostic sweep before next jump</p>
                    <p>&gt; Unknown biological signatures detected in hold 3</p>
                    <p>&gt; Command override protocols updated - review required</p>
                </div>
            </div>
        </div>

        <!-- Right Column - Two Panels -->
        <div class="dashboard-right">
            <!-- Right Top Panel - Star Map -->
            <div class="panel-base chamfer-tl-br border-all corner-line-tl-br">
                <div class="dashboard-panel-header">
                    <h3>STAR MAP</h3>
                </div>
                <div class="dashboard-panel-content" id="star-map-panel">
                    {% if star_systems %}
                        {% for system in star_systems %}
                            {% if system.label %}
                                <div class="star-system-row" data-system="{{ system.name }}" data-has-system-map="{{ system.has_system_map }}">
                                    <div class="star-system-content">
                                        <div class="star-system-checkbox"></div>
                                        <div class="star-system-name">{{ system.name }}</div>
                                    </div>
                                    {% if system.has_system_map %}
                                        <div class="system-map-btn-container" title="View system map">
                                            <span class="system-map-btn-icon">▶</span>
                                        </div>
                                    {% endif %}
                                </div>
                            {% endif %}
                        {% endfor %}
                    {% else %}
                        <p>&gt; No star systems found</p>
                    {% endif %}
                </div>
            </div>

            <!-- Right Bottom Panel - STATUS -->
            <div class="panel-base chamfer-tl-br border-all corner-line-tl-br">
                <div class="dashboard-panel-header">
                    <h3>STATUS</h3>
                </div>
                <div class="dashboard-panel-content">
                    <p>&gt; All systems nominal</p>
                    <p>&gt; Course steady</p>
                </div>
            </div>
        </div>

        <!-- System Info Panel (appears when star is selected) -->
        <div id="system-info-panel" class="system-info-panel">
            <div class="dashboard-panel-header">
                <h3 id="system-info-name">SYSTEM INFO</h3>
            </div>
            <div class="dashboard-panel-content">
                <div id="system-info-content">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Indicator boxes (sibling to avoid clip-path) -->
        <div class="system-info-indicator-boxes"></div>

        <!-- Rectangle decoration extending to panel edge -->
        <div class="system-info-rectangle"></div>

        <!-- Triangle decoration on top of rectangle -->
        <div class="system-info-triangle"></div>
    </div>

    <!-- Store star systems data in JavaScript -->
    <script>
    window.starSystemsData = {{ star_systems_json|safe }};
    </script>

    <!-- ENCOUNTER MAP VIEW -->
    {% elif active_view.view_type == 'ENCOUNTER_MAP' and location_data %}
    <div class="map-view">
        <div class="map-header">{{ location_data.name|upper }}</div>
        <div class="map-info-bar">
            <span>LOCATION: {{ location_data.coordinates|default:"UNKNOWN" }}</span>
            <span>TYPE: {{ location_data.type|default:"UNKNOWN"|upper }}</span>
            <span>STATUS: {{ location_data.status|default:"UNKNOWN"|upper }}</span>
        </div>
        <div class="map-container">
            {% if location_data.map.image_path %}
                <img src="/data/{{ location_data.map.image_path }}" alt="{{ location_data.map.name }}" class="map-image">
            {% else %}
                <div class="no-map-message">
                    <p>&gt; NO MAP AVAILABLE</p>
                    <p>&gt; {{ location_data.name|upper }}</p>
                </div>
            {% endif %}
        </div>
    </div>

    <!-- FALLBACK -->
    {% else %}
    <div class="standby-view">
        <div class="no-map-message">
            <p>&gt; TERMINAL STANDBY</p>
            <p>&gt; NO ACTIVE VIEW</p>
        </div>
    </div>
    {% endif %}

    <!-- Auto-refresh script -->
    <script>
    (function() {
        let currentViewState = {
            location_slug: '{{ active_view.location_slug|default:"" }}',
            view_type: '{{ active_view.view_type }}',
            view_slug: '{{ active_view.view_slug|default:"" }}',
            updated_at: '{{ active_view.updated_at|date:"Y-m-d H:i:s" }}'
        };

        function checkForViewChanges() {
            fetch('/api/active-view/')
                .then(response => response.json())
                .then(data => {
                    // Check if view has changed
                    if (data.location_slug !== currentViewState.location_slug ||
                        data.view_type !== currentViewState.view_type ||
                        data.view_slug !== currentViewState.view_slug) {

                        console.log('View changed - reloading with reset flag');
                        // Add reset parameter to indicate this is a view change, not a manual refresh
                        window.location.href = window.location.pathname + '?viewchange=1';
                    }

                    // Update current state
                    currentViewState = {
                        location_slug: data.location_slug,
                        view_type: data.view_type,
                        view_slug: data.view_slug,
                        updated_at: data.updated_at
                    };
                })
                .catch(error => {
                    console.error('Error checking active view:', error);
                });
        }

        // Poll every 2 seconds
        setInterval(checkForViewChanges, 2000);
    })();
    </script>

    <!-- 3D Star Map Initialization -->
    <script type="module">
    import * as THREE from 'three';

    // Global star map state (accessible to other scripts)
    window.starMapState = {
        starPositions: new Map(),  // Map of system name to position
        camera: null,
        lookAtTarget: null,
        animating: false,
        animationFrameId: null,  // Store animation frame ID for cancellation
        autoRotate: false,  // Auto-rotate around selected star
        autoRotateSpeed: 0.002,  // Rotation speed (radians per frame) - full rotation ~52 seconds
        lastUserInteractionTime: null,  // Track when user last interacted (for auto-rotation resume)
        autoRotateResumeDelay: 5000  // Resume auto-rotation after 5 seconds of inactivity
    };

    (function() {
        // Get the canvas
        const canvas = document.getElementById('starmap-canvas');
        if (!canvas) return;

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Array to store stars for animation
        const stars = [];

        // Create camera
        const camera = new THREE.PerspectiveCamera(
            75,  // FOV
            window.innerWidth / window.innerHeight,  // Aspect ratio
            0.1,  // Near plane
            1000  // Far plane
        );
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Store camera reference globally
        window.starMapState.camera = camera;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
        scene.add(ambientLight);

        // Create a simple starburst texture (like in the reference image)
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const centerX = 64;
            const centerY = 64;

            // Draw bright center core with glow
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            coreGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = coreGradient;
            ctx.fillRect(0, 0, 128, 128);

            // Draw simple 4-point cross
            ctx.globalCompositeOperation = 'lighter';
            drawSpike(ctx, centerX, centerY, 0, 50, 3);      // North
            drawSpike(ctx, centerX, centerY, 90, 50, 3);     // East
            drawSpike(ctx, centerX, centerY, 180, 50, 3);    // South
            drawSpike(ctx, centerX, centerY, 270, 50, 3);    // West

            // Apply blur for soft glow
            ctx.filter = 'blur(2px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';

            return new THREE.CanvasTexture(canvas);
        }

        // Helper function to draw a spike/ray
        function drawSpike(ctx, x, y, angle, length, width) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((angle * Math.PI) / 180);

            const gradient = ctx.createLinearGradient(0, 0, 0, length);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-width, length);
            ctx.lineTo(width, length);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Create the star texture once for reuse
        const starTexture = createStarTexture();

        // Create targeting reticle texture (two concentric circles with cross cutout)
        function createReticleTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const centerX = size / 2;
            const centerY = size / 2;

            // Amber color (muted yellow) - #8b7355
            const amberColor = 'rgba(139, 115, 85, 1.0)';

            // Clear canvas
            ctx.clearRect(0, 0, size, size);

            // Use compositing to create cutout effect
            ctx.globalCompositeOperation = 'source-over';

            // Draw outer circle
            ctx.strokeStyle = amberColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
            ctx.stroke();

            // Draw inner circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
            ctx.stroke();

            // Draw corner brackets
            const bracketSize = 18;
            const bracketDistance = 95;
            ctx.lineWidth = 3;
            // Top-left
            ctx.beginPath();
            ctx.moveTo(centerX - bracketDistance, centerY - bracketDistance + bracketSize);
            ctx.lineTo(centerX - bracketDistance, centerY - bracketDistance);
            ctx.lineTo(centerX - bracketDistance + bracketSize, centerY - bracketDistance);
            ctx.stroke();
            // Top-right
            ctx.beginPath();
            ctx.moveTo(centerX + bracketDistance - bracketSize, centerY - bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY - bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY - bracketDistance + bracketSize);
            ctx.stroke();
            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(centerX - bracketDistance, centerY + bracketDistance - bracketSize);
            ctx.lineTo(centerX - bracketDistance, centerY + bracketDistance);
            ctx.lineTo(centerX - bracketDistance + bracketSize, centerY + bracketDistance);
            ctx.stroke();
            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(centerX + bracketDistance - bracketSize, centerY + bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY + bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY + bracketDistance - bracketSize);
            ctx.stroke();

            // Use destination-out to cut out the cross
            ctx.globalCompositeOperation = 'destination-out';

            // Horizontal cross bar
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(centerX - 90, centerY - 5, 180, 10);

            // Vertical cross bar
            ctx.fillRect(centerX - 5, centerY - 90, 10, 180);

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';

            return new THREE.CanvasTexture(canvas);
        }

        const reticleTexture = createReticleTexture();

        // Create selection reticle sprite (initially hidden)
        const selectionReticle = new THREE.Sprite(new THREE.SpriteMaterial({
            map: reticleTexture,
            transparent: true,
            opacity: 0.8,
            depthTest: false,  // Always render on top
            depthWrite: false
        }));
        selectionReticle.scale.set(20, 20, 1);  // Size of the reticle
        selectionReticle.visible = false;  // Hidden by default
        scene.add(selectionReticle);

        // Store reticle reference globally
        window.starMapState.selectionReticle = selectionReticle;

        // Create background star field using sprites (same texture as main stars)
        const starFieldCount = 5000;  // Number of background stars
        const backgroundStars = [];

        for (let i = 0; i < starFieldCount; i++) {
            // Random position in a large sphere
            const radius = 150 + Math.random() * 300;  // Distance from center
            const theta = Math.random() * Math.PI * 2;  // Horizontal angle
            const phi = Math.acos(2 * Math.random() - 1);  // Vertical angle (uniform distribution)

            const position = new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Create sprite with starburst texture
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,  // Random opacity 0.4-0.8
                blending: THREE.AdditiveBlending
            });

            const sprite = new THREE.Sprite(spriteMaterial);

            // Random size variation (smaller than main stars)
            const size = 0.5 + Math.random() * 1.5;  // Size 0.5 to 2.0
            sprite.scale.set(size, size, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            // Store for potential animation
            sprite.userData.baseOpacity = sprite.material.opacity;
            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

            scene.add(sprite);
            backgroundStars.push(sprite);
        }

        function createStar(size, position) {
            // Just use a sprite - no sphere core
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size * 6, size * 6, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            // Store sprite reference for animation
            sprite.userData.baseOpacity = 0.9;
            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

            return sprite;
        }

        // Load star map data and create stars
        fetch('/api/star-map/')
            .then(response => response.json())
            .then(data => {
                console.log('Star map data loaded:', data);

                // Create stars from data
                if (data.systems) {
                    data.systems.forEach(system => {
                        const position = new THREE.Vector3(
                            system.position[0],
                            system.position[1],
                            system.position[2]
                        );

                        const star = createStar(system.size || 1, position);

                        star.userData = {
                            name: system.name,
                            type: system.type
                        };

                        scene.add(star);

                        // Store star for animation
                        stars.push(star);

                        // Store star position globally for camera navigation
                        window.starMapState.starPositions.set(system.name, position);

                        // Add point light at star position for subtle illumination
                        const starLight = new THREE.PointLight(0xFFFFFF, 0.3, 40);  // Pure white
                        starLight.position.copy(position);
                        scene.add(starLight);
                    });

                    console.log(`Loaded ${stars.length} stars for pulsing animation`);
                }

                // Create connection routes
                if (data.routes) {
                    const systemPositions = {};
                    data.systems.forEach(sys => {
                        systemPositions[sys.name] = sys.position;
                    });

                    data.routes.forEach(route => {
                        const fromPos = systemPositions[route.from];
                        const toPos = systemPositions[route.to];

                        if (fromPos && toPos) {
                            // Create start and end points
                            const start = new THREE.Vector3(fromPos[0], fromPos[1], fromPos[2]);
                            const end = new THREE.Vector3(toPos[0], toPos[1], toPos[2]);

                            // Calculate direction and distance
                            const direction = end.clone().sub(start);
                            const distance = direction.length();
                            direction.normalize();

                            // Shorten the line on both ends so it doesn't reach star centers
                            // Move start point away from star by 8 units
                            // Move end point away from star by 8 units
                            const offset = 8;
                            const shortenedStart = start.clone().add(direction.clone().multiplyScalar(offset));
                            const shortenedEnd = end.clone().sub(direction.clone().multiplyScalar(offset));

                            // Only create route if there's enough distance after shortening
                            if (distance > offset * 2) {
                                // Create a curve from start to end (full length for gradient)
                                const curve = new THREE.LineCurve3(start, end);

                                // Create tube geometry with more segments for smooth fade
                                const segments = 64;  // More segments for smooth gradient
                                const tubeGeometry = new THREE.TubeGeometry(
                                    curve,
                                    segments,  // Segments along the length
                                    0.3,       // Tube radius (thickness)
                                    8,         // Radial segments (smoothness)
                                    false      // Not closed
                                );

                                // Add vertex alpha values for fade effect
                                const positions = tubeGeometry.attributes.position;
                                const alphas = [];
                                const fadeDistance = 15;  // Distance over which to fade (in units)

                                // Calculate alpha for each vertex
                                for (let i = 0; i < positions.count; i++) {
                                    const vertex = new THREE.Vector3(
                                        positions.getX(i),
                                        positions.getY(i),
                                        positions.getZ(i)
                                    );

                                    // Calculate distance from both ends
                                    const distFromStart = vertex.distanceTo(start);
                                    const distFromEnd = vertex.distanceTo(end);

                                    // Calculate alpha from both ends (handles overlapping fades)
                                    let alphaFromStart = 1.0;
                                    let alphaFromEnd = 1.0;

                                    if (distFromStart < fadeDistance) {
                                        alphaFromStart = distFromStart / fadeDistance;
                                    }
                                    if (distFromEnd < fadeDistance) {
                                        alphaFromEnd = distFromEnd / fadeDistance;
                                    }

                                    // Use the minimum (most transparent) alpha
                                    const alpha = Math.min(alphaFromStart, alphaFromEnd);

                                    alphas.push(alpha);
                                }

                                tubeGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

                                // Custom shader material for vertex alpha
                                const material = new THREE.ShaderMaterial({
                                    uniforms: {
                                        color: { value: new THREE.Color(route.color || 0x5a7a9a) }
                                    },
                                    vertexShader: `
                                        attribute float alpha;
                                        varying float vAlpha;
                                        void main() {
                                            vAlpha = alpha;
                                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                        }
                                    `,
                                    fragmentShader: `
                                        uniform vec3 color;
                                        varying float vAlpha;
                                        void main() {
                                            gl_FragColor = vec4(color, vAlpha);
                                        }
                                    `,
                                    transparent: true,
                                    depthWrite: false
                                });

                                const tube = new THREE.Mesh(tubeGeometry, material);
                                scene.add(tube);
                            }
                        }
                    });
                }

                // Create nebulae clouds
                if (data.nebulae) {
                    // Create soft cloud texture for nebula particles (diffuse, no bright center)
                    function createNebulaTexture() {
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');

                        // Create soft gradient (visible but not too bright at center)
                        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');    // Soft center
                        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');  // Mid region
                        gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');  // Fade
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');    // Transparent edge

                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 64, 64);

                        return new THREE.CanvasTexture(canvas);
                    }

                    const nebulaTexture = createNebulaTexture();
                    const nebulaParticles = [];  // Store for animation

                    data.nebulae.forEach(nebula => {
                        const position = new THREE.Vector3(
                            nebula.position[0],
                            nebula.position[1],
                            nebula.position[2]
                        );

                        // Create spherical shell of particles
                        // Target radius for bright expansion front
                        const targetRadius = nebula.size * 0.85;
                        const shellThickness = nebula.size * 0.25;

                        for (let i = 0; i < nebula.particle_count; i++) {
                            // Random point on sphere using uniform distribution
                            const theta = Math.random() * Math.PI * 2;  // Azimuth: 0 to 2π
                            const phi = Math.acos(2 * Math.random() - 1);  // Elevation: 0 to π (uniform)

                            // Distance from center (concentrated around target radius)
                            const radiusOffset = (Math.random() - 0.5) * shellThickness;
                            const radius = targetRadius + radiusOffset;

                            // Convert spherical to Cartesian coordinates
                            const x = radius * Math.sin(phi) * Math.cos(theta);
                            const y = radius * Math.sin(phi) * Math.sin(theta);
                            const z = radius * Math.cos(phi);

                            const particlePos = new THREE.Vector3(
                                position.x + x,
                                position.y + y,
                                position.z + z
                            );

                            // Particles closer to target radius are brighter (expansion front)
                            const distanceFromFront = Math.abs(radiusOffset);
                            const brightnessFactor = 1.0 - (distanceFromFront / (shellThickness / 2));
                            const particleOpacity = nebula.opacity * Math.max(0.3, brightnessFactor) * (0.6 + Math.random() * 0.4);

                            const spriteMaterial = new THREE.SpriteMaterial({
                                map: nebulaTexture,
                                color: nebula.color,
                                transparent: true,
                                opacity: particleOpacity,
                                blending: THREE.AdditiveBlending,
                                depthWrite: false
                            });

                            const sprite = new THREE.Sprite(spriteMaterial);

                            // Vary particle size
                            const size = (nebula.size / 5) * (0.5 + Math.random() * 0.8);
                            sprite.scale.set(size, size, 1);
                            sprite.position.copy(particlePos);

                            // Store metadata for animation
                            sprite.userData.nebulaType = nebula.type;
                            sprite.userData.baseOpacity = particleOpacity;
                            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

                            scene.add(sprite);
                            nebulaParticles.push(sprite);
                        }
                    });
                }

                console.log('Star map rendered');
            })
            .catch(error => {
                console.error('Error loading star map:', error);
            });

        // Frame counter for throttling expensive operations
        let frameCount = 0;

        // Animation loop with star pulsing
        function animate() {
            requestAnimationFrame(animate);

            frameCount++;

            // Only update star/nebula animations every 3rd frame (20fps instead of 60fps)
            // This significantly improves performance while keeping animations smooth
            if (frameCount % 3 === 0) {
                // Pulse stars
                const time = Date.now() * 0.001; // Time in seconds
                stars.forEach(star => {
                    if (star.userData.sprite) {
                        // Pulse between 0.4 and 1.0 opacity using sine wave (more dramatic)
                        const pulseSpeed = 2.0; // Speed of pulsing (faster)
                        const pulseAmount = 0.3; // How much to pulse (30% variation)
                        const pulse = Math.sin(time * pulseSpeed + star.userData.pulseOffset) * pulseAmount;

                        // Set opacity between 0.4 and 1.0
                        const newOpacity = 0.7 + pulse;
                        star.userData.sprite.material.opacity = Math.max(0.4, Math.min(1.0, newOpacity));
                    }
                });

                // Animate nebula particles based on type
                if (typeof nebulaParticles !== 'undefined') {
                    nebulaParticles.forEach(particle => {
                        const type = particle.userData.nebulaType;

                        if (type === 'emission') {
                            // Emission nebulae: Gentle pulsing (flickering ionized gas)
                            const pulseSpeed = 0.5;  // Slow pulse
                            const pulseAmount = 0.15;  // Subtle variation (15%)
                            const pulse = Math.sin(time * pulseSpeed + particle.userData.pulseOffset) * pulseAmount;
                            particle.material.opacity = particle.userData.baseOpacity * (1.0 + pulse);

                        } else if (type === 'planetary') {
                            // Planetary nebulae: Slow rotation around center
                            const angle = time * particle.userData.rotationSpeed;

                            // Calculate offset without cloning (avoid garbage collection overhead)
                            const offsetX = particle.position.x - particle.userData.nebulaCenter.x;
                            const offsetY = particle.position.y - particle.userData.nebulaCenter.y;
                            const offsetZ = particle.position.z - particle.userData.nebulaCenter.z;

                            // Rotate around Y-axis
                            const cosAngle = Math.cos(angle * 0.1);
                            const sinAngle = Math.sin(angle * 0.1);
                            const rotatedX = offsetX * cosAngle - offsetZ * sinAngle;
                            const rotatedZ = offsetX * sinAngle + offsetZ * cosAngle;

                            particle.position.set(
                                particle.userData.nebulaCenter.x + rotatedX,
                                particle.userData.nebulaCenter.y + offsetY,
                                particle.userData.nebulaCenter.z + rotatedZ
                            );

                        } else if (type === 'reflection') {
                            // Reflection nebulae: Very subtle shimmer
                            const pulseSpeed = 0.3;
                            const pulseAmount = 0.08;  // Very subtle (8%)
                            const pulse = Math.sin(time * pulseSpeed + particle.userData.pulseOffset) * pulseAmount;
                            particle.material.opacity = particle.userData.baseOpacity * (1.0 + pulse);
                        }
                        // Dark nebulae: No animation (static dust clouds)
                    });
                }
            }

            // Check if we should resume auto-rotation after user inactivity
            if (!window.starMapState.autoRotate && window.starMapState.lastUserInteractionTime) {
                const timeSinceLastInteraction = Date.now() - window.starMapState.lastUserInteractionTime;
                if (timeSinceLastInteraction >= window.starMapState.autoRotateResumeDelay) {
                    window.starMapState.autoRotate = true;
                    console.log('Auto-rotation resumed after 5 seconds of inactivity');
                }
            }

            // Auto-rotate camera around selected star
            if (window.starMapState.autoRotate && !window.starMapState.animating) {
                // Calculate offset without cloning (avoid garbage collection overhead)
                const offsetX = camera.position.x - lookAtTarget.x;
                const offsetY = camera.position.y - lookAtTarget.y;
                const offsetZ = camera.position.z - lookAtTarget.z;
                const radius = Math.sqrt(offsetX * offsetX + offsetY * offsetY + offsetZ * offsetZ);

                // Get current angle
                let theta = Math.atan2(offsetX, offsetZ);

                // Increment angle for rotation
                theta += window.starMapState.autoRotateSpeed;

                // Keep current elevation (phi)
                const phi = Math.acos(offsetY / radius);

                // Calculate new position
                const sinPhi = Math.sin(phi);
                camera.position.x = lookAtTarget.x + radius * sinPhi * Math.sin(theta);
                camera.position.y = lookAtTarget.y + radius * Math.cos(phi);
                camera.position.z = lookAtTarget.z + radius * sinPhi * Math.cos(theta);

                camera.lookAt(lookAtTarget);
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Track where camera is looking (center point for rotation)
        const lookAtTarget = new THREE.Vector3(0, 0, 0);

        // Store lookAtTarget reference globally
        window.starMapState.lookAtTarget = lookAtTarget;

        // Camera animation function
        function animateCameraToTarget(targetPosition, duration = 2000) {
            // Cancel any ongoing animation
            if (window.starMapState.animationFrameId) {
                cancelAnimationFrame(window.starMapState.animationFrameId);
                window.starMapState.animationFrameId = null;
            }

            window.starMapState.animating = true;

            // Use current camera position as start (for smooth interruption)
            const startPosition = camera.position.clone();
            const startLookAt = lookAtTarget.clone();
            const startTime = Date.now();

            // Calculate optimal camera position (offset from target)
            const distance = 80;  // Distance from target
            const angle = Math.atan2(startPosition.x - startLookAt.x, startPosition.z - startLookAt.z);
            const endPosition = new THREE.Vector3(
                targetPosition.x + Math.sin(angle) * distance,
                targetPosition.y + 30,  // Slight elevation
                targetPosition.z + Math.cos(angle) * distance
            );

            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Easing function (ease-in-out)
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Interpolate camera position
                camera.position.lerpVectors(startPosition, endPosition, eased);

                // Interpolate lookAt target
                lookAtTarget.lerpVectors(startLookAt, targetPosition, eased);
                camera.lookAt(lookAtTarget);

                if (progress < 1) {
                    window.starMapState.animationFrameId = requestAnimationFrame(updateCamera);
                } else {
                    window.starMapState.animating = false;
                    window.starMapState.animationFrameId = null;
                }
            }

            updateCamera();
        }

        // Make animation function globally accessible
        window.starMapState.animateCameraToTarget = animateCameraToTarget;

        // Simple mouse wheel zoom
        let zoomSpeed = 4;      // Units to zoom per scroll/pinch (increased for more responsive control)
        let minDistance = 20;   // Minimum distance from center
        let maxDistance = 300;  // Maximum distance from center

        window.addEventListener('wheel', (event) => {
            // Check if mouse is over a panel or scrollable content
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');

            // If over a panel, allow normal scrolling
            if (isPanel) {
                // Don't call preventDefault() - let the browser handle scrolling
                return;
            }

            // Otherwise, zoom the galaxy map
            event.preventDefault();

            // Disable auto-rotation when user zooms and record interaction time
            window.starMapState.autoRotate = false;
            window.starMapState.lastUserInteractionTime = Date.now();

            // Calculate direction from camera to target
            const direction = lookAtTarget.clone().sub(camera.position).normalize();
            const currentDistance = camera.position.distanceTo(lookAtTarget);

            // Zoom in or out
            if (event.deltaY < 0) {
                // Zoom in
                const newDistance = currentDistance - zoomSpeed;
                if (newDistance >= minDistance) {
                    camera.position.add(direction.multiplyScalar(zoomSpeed));
                }
            } else {
                // Zoom out
                const newDistance = currentDistance + zoomSpeed;
                if (newDistance <= maxDistance) {
                    camera.position.add(direction.multiplyScalar(-zoomSpeed));
                }
            }
        }, { passive: false });

        // Touch pinch zoom (for mobile/tablet) - attach to window
        let lastTouchDistance = 0;

        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                event.preventDefault();

                // Disable auto-rotation when user pinch zooms and record interaction time
                window.starMapState.autoRotate = false;
                window.starMapState.lastUserInteractionTime = Date.now();

                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const distance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                const delta = lastTouchDistance - distance;
                lastTouchDistance = distance;

                // Apply zoom using directional approach (same as wheel zoom)
                const direction = lookAtTarget.clone().sub(camera.position).normalize();
                const currentDistance = camera.position.distanceTo(lookAtTarget);

                if (delta > 0) {
                    // Pinch in (zoom out)
                    const newDistance = currentDistance + zoomSpeed;
                    if (newDistance <= maxDistance) {
                        camera.position.add(direction.multiplyScalar(-zoomSpeed));
                    }
                } else if (delta < 0) {
                    // Pinch out (zoom in)
                    const newDistance = currentDistance - zoomSpeed;
                    if (newDistance >= minDistance) {
                        camera.position.add(direction.multiplyScalar(zoomSpeed));
                    }
                }
            }
        }, { passive: false });

        // Mouse and touch rotation controls
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let rotateSpeed = 0.003;  // Increased for more responsive touch control

        // Mouse rotation
        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) {  // Left click only
                isDragging = true;
                // Disable auto-rotation when user manually rotates and record interaction time
                window.starMapState.autoRotate = false;
                window.starMapState.lastUserInteractionTime = Date.now();
                previousPosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;

            const deltaX = event.clientX - previousPosition.x;
            const deltaY = event.clientY - previousPosition.y;

            // Rotate camera around center
            const offset = camera.position.clone().sub(lookAtTarget);
            const radius = offset.length();

            // Convert to spherical coordinates
            let theta = Math.atan2(offset.x, offset.z);
            let phi = Math.acos(offset.y / radius);

            // Update angles
            theta -= deltaX * rotateSpeed;
            phi -= deltaY * rotateSpeed;

            // Clamp phi to prevent flipping
            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            // Convert back to cartesian
            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            camera.position.copy(lookAtTarget).add(offset);
            camera.lookAt(lookAtTarget);

            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch rotation (single finger drag) - attach to window
        let isTouching = false;

        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                // Check if touching a panel or button
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel, .star-system-row');
                const isButton = target.closest('button, .system-map-btn-container, .show-btn-container');
                if (isPanel || isButton) return;

                isTouching = true;
                // Disable auto-rotation when user manually rotates and record interaction time
                window.starMapState.autoRotate = false;
                window.starMapState.lastUserInteractionTime = Date.now();
                previousPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (isTouching && event.touches.length === 1) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) {
                    isTouching = false;
                    return;
                }

                event.preventDefault();

                const touch = event.touches[0];
                const deltaX = touch.clientX - previousPosition.x;
                const deltaY = touch.clientY - previousPosition.y;

                // Same rotation logic as mouse
                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / radius);

                theta -= deltaX * rotateSpeed;
                phi -= deltaY * rotateSpeed;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);

                previousPosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isTouching = false;
        });

        // Enable auto-rotation by default when nothing is selected
        // Wait a bit to ensure everything is initialized
        setTimeout(() => {
            // Only enable if no system is currently selected
            const hasSelectedSystem = localStorage.getItem('selected_star_system');
            if (!hasSelectedSystem && window.starMapState) {
                window.starMapState.autoRotate = true;
                console.log('Auto-rotation enabled (no system selected)');
            }
        }, 500);
    })();
    </script>

    <!-- System Map (Solar System View) Script -->
    <script type="module">
    import * as THREE from 'three';

    // Global state for system map
    window.systemMapState = {
        scene: null,
        camera: null,
        renderer: null,
        planets: [],
        orbits: [],
        star: null,
        currentSystem: null,
        currentSystemSlug: null,  // Track current system slug for navigation
        animationFrameId: null,
        startTime: Date.now(),
        controlsInitialized: false,
        isActive: false,  // Track if this view is currently active
        speedMultiplier: 10,  // Default, will be calculated per-system
        selectedPlanet: null,  // Track currently selected planet
        raycaster: null,       // For planet click detection
        mouse: new THREE.Vector2(),  // Mouse position for raycasting
        cameraOffset: null,    // Camera offset from selected planet (maintains view angle)
        lastPlanetAngle: 0,    // Track planet's orbital angle to rotate camera with it
        selectionReticle: null // Selection reticle sprite for selected planet
    };

    // Initialize system map scene
    function initSystemMap() {
        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas) return;

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        window.systemMapState.scene = scene;

        // Create camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 180);
        camera.lookAt(0, 0, 0);
        window.systemMapState.camera = camera;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        window.systemMapState.renderer = renderer;

        // Add ambient light (dim)
        const ambientLight = new THREE.AmbientLight(0x222244, 0.2);
        scene.add(ambientLight);

        // Create star texture for background starfield
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const centerX = 64;
            const centerY = 64;

            // Draw bright center core with glow
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            coreGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = coreGradient;
            ctx.fillRect(0, 0, 128, 128);

            // Draw simple 4-point cross
            ctx.globalCompositeOperation = 'lighter';
            drawSpike(ctx, centerX, centerY, 0, 50, 3);      // North
            drawSpike(ctx, centerX, centerY, 90, 50, 3);     // East
            drawSpike(ctx, centerX, centerY, 180, 50, 3);    // South
            drawSpike(ctx, centerX, centerY, 270, 50, 3);    // West

            // Apply blur for soft glow
            ctx.filter = 'blur(2px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';

            return new THREE.CanvasTexture(canvas);
        }

        function drawSpike(ctx, x, y, angle, length, width) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((angle * Math.PI) / 180);

            const gradient = ctx.createLinearGradient(0, 0, 0, length);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-width, length);
            ctx.lineTo(width, length);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        const starTexture = createStarTexture();

        // Create background star field
        const starFieldCount = 5000;
        const backgroundStars = [];

        for (let i = 0; i < starFieldCount; i++) {
            // Random position in a large sphere
            const radius = 150 + Math.random() * 300;  // Distance from center
            const theta = Math.random() * Math.PI * 2;  // Horizontal angle
            const phi = Math.acos(2 * Math.random() - 1);  // Vertical angle (uniform distribution)

            const position = new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Create sprite with starburst texture
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,  // Random opacity 0.4-0.8
                blending: THREE.AdditiveBlending
            });

            const sprite = new THREE.Sprite(spriteMaterial);

            // Random size variation (smaller than main stars)
            const size = 0.5 + Math.random() * 1.5;  // Size 0.5 to 2.0
            sprite.scale.set(size, size, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            scene.add(sprite);
            backgroundStars.push(sprite);
        }

        console.log('System map initialized with', starFieldCount, 'background stars');

        // Create selection reticle texture
        function createReticleTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const centerX = size / 2;
            const centerY = size / 2;

            // Amber color (muted yellow) - #8b7355
            const amberColor = 'rgba(139, 115, 85, 1.0)';

            // Clear canvas
            ctx.clearRect(0, 0, size, size);

            // Use compositing to create cutout effect
            ctx.globalCompositeOperation = 'source-over';

            // Draw outer circle
            ctx.strokeStyle = amberColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
            ctx.stroke();

            // Draw inner circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
            ctx.stroke();

            // Draw corner brackets
            const bracketSize = 18;
            const bracketDistance = 95;
            ctx.lineWidth = 3;
            // Top-left
            ctx.beginPath();
            ctx.moveTo(centerX - bracketDistance, centerY - bracketDistance + bracketSize);
            ctx.lineTo(centerX - bracketDistance, centerY - bracketDistance);
            ctx.lineTo(centerX - bracketDistance + bracketSize, centerY - bracketDistance);
            ctx.stroke();
            // Top-right
            ctx.beginPath();
            ctx.moveTo(centerX + bracketDistance - bracketSize, centerY - bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY - bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY - bracketDistance + bracketSize);
            ctx.stroke();
            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(centerX - bracketDistance, centerY + bracketDistance - bracketSize);
            ctx.lineTo(centerX - bracketDistance, centerY + bracketDistance);
            ctx.lineTo(centerX - bracketDistance + bracketSize, centerY + bracketDistance);
            ctx.stroke();
            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(centerX + bracketDistance - bracketSize, centerY + bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY + bracketDistance);
            ctx.lineTo(centerX + bracketDistance, centerY + bracketDistance - bracketSize);
            ctx.stroke();

            // Use destination-out to cut out the cross
            ctx.globalCompositeOperation = 'destination-out';

            // Horizontal cross bar
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(centerX - 90, centerY - 5, 180, 10);

            // Vertical cross bar
            ctx.fillRect(centerX - 5, centerY - 90, 10, 180);

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';

            return new THREE.CanvasTexture(canvas);
        }

        const reticleTexture = createReticleTexture();

        // Create selection reticle sprite (initially hidden)
        const selectionReticle = new THREE.Sprite(new THREE.SpriteMaterial({
            map: reticleTexture,
            transparent: true,
            opacity: 0.8,
            depthTest: false,  // Always render on top
            depthWrite: false
        }));
        selectionReticle.scale.set(10, 10, 1);  // Default scale, will be adjusted per planet
        selectionReticle.visible = false;  // Hidden by default
        scene.add(selectionReticle);

        // Store reticle reference globally
        window.systemMapState.selectionReticle = selectionReticle;

        // Initialize raycaster for planet click detection
        window.systemMapState.raycaster = new THREE.Raycaster();
    }

    // Load and display system map
    async function loadSystemMap(systemSlug) {
        try {
            const response = await fetch(`/api/system-map/${systemSlug}/`);
            if (!response.ok) {
                throw new Error(`Failed to load system map: ${response.statusText}`);
            }

            const data = await response.json();
            console.log('System map data loaded:', data);

            // Store current system and slug
            window.systemMapState.currentSystem = data;
            window.systemMapState.currentSystemSlug = systemSlug;

            // Clear existing objects
            clearSystemMap();

            // Initialize scene if not already done
            if (!window.systemMapState.scene) {
                initSystemMap();
            }

            // Render the star
            renderStar(data.star);

            // Render planets and orbits
            if (data.bodies) {
                data.bodies.forEach(body => {
                    renderPlanet(body);
                    // Render orbits by default unless explicitly disabled
                    if (!data.orbits || data.orbits.show !== false) {
                        renderOrbit(body, data.orbits || {});
                    }
                });
            }

            // Calculate speed multiplier based on fastest planet
            // Target: fastest planet completes 1 orbit in 10 seconds
            if (window.systemMapState.planets.length > 0) {
                const minOrbitalPeriod = Math.min(...window.systemMapState.planets.map(p => p.orbitalPeriod));
                window.systemMapState.speedMultiplier = minOrbitalPeriod / 10;
                console.log(`Speed multiplier for ${data.star.name}: ${window.systemMapState.speedMultiplier.toFixed(2)} (fastest planet: ${minOrbitalPeriod} days)`);
            }

            // Apply camera settings from data
            if (data.camera) {
                const cam = window.systemMapState.camera;
                cam.position.set(...data.camera.position);
                cam.lookAt(...data.camera.lookAt);
                if (data.camera.fov) {
                    cam.fov = data.camera.fov;
                    cam.updateProjectionMatrix();
                }
            }

            // Show system map, hide galaxy map with transition
            const selectedSystem = localStorage.getItem('selected_star_system');
            let starPosition = null;
            if (selectedSystem && window.starMapState && window.starMapState.starPositions) {
                starPosition = window.starMapState.starPositions.get(selectedSystem);
            }
            showSystemMap(starPosition);

            // Initialize controls if not already done
            if (!window.systemMapState.controlsInitialized) {
                initSystemMapControls();
                window.systemMapState.controlsInitialized = true;
            }

            // Set system map as active view
            window.systemMapState.isActive = true;
            if (window.orbitMapState) {
                window.orbitMapState.isActive = false;
            }

            // Start animation
            if (!window.systemMapState.animationFrameId) {
                animateSystemMap();
            }

            // Show planet list in left panel (but don't update info panel)
            showPlanetList(data);

        } catch (error) {
            console.error('Error loading system map:', error);
        }
    }

    // ==================== PROCEDURAL PLANET TEXTURE GENERATION ====================

    /**
     * Simple pseudo-random noise function (seeded)
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} seed - Random seed
     * @returns {number} - Noise value between 0 and 1
     */
    function noise2D(x, y, seed = 0) {
        // Improved hash function for better distribution
        const hash = Math.sin(x * 127.1 + y * 311.7 + seed * 74.3) * 43758.5453123;
        const hash2 = Math.sin(x * 269.5 + y * 183.3 + seed * 92.7) * 43758.5453123;
        return Math.abs((hash + hash2) / 2 - Math.floor((hash + hash2) / 2));
    }

    /**
     * Octave noise (multiple layers of noise for detail)
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} octaves - Number of noise layers
     * @param {number} seed - Random seed
     * @returns {number} - Noise value between 0 and 1
     */
    function octaveNoise(x, y, octaves = 4, seed = 0) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1;
        let maxValue = 0;

        for (let i = 0; i < octaves; i++) {
            value += noise2D(x * frequency, y * frequency, seed + i) * amplitude;
            maxValue += amplitude;
            amplitude *= 0.5;
            frequency *= 2;
        }

        return value / maxValue;
    }

    /**
     * Generate procedural planet texture
     * @param {Object} config - Texture configuration from orbit_map.yaml
     * @returns {THREE.Texture} - Generated texture
     */
    function generatePlanetTexture(config) {
        const width = 1024;
        const height = 512; // Equirectangular projection (2:1 ratio)

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        const type = config.type || 'terrestrial_oceanic';
        const primaryColor = config.primary_color || 0x4682B4;
        const secondaryColor = config.secondary_color || 0x228B22;
        const tertiaryColor = config.tertiary_color || null;
        const noiseScale = config.noise_scale || 2.5;
        const seed = config.seed || Math.random() * 1000;

        // Convert hex colors to RGB
        const primary = hexToRgb(primaryColor);
        const secondary = hexToRgb(secondaryColor);
        const tertiary = tertiaryColor ? hexToRgb(tertiaryColor) : null;

        // Generate base planet texture based on type
        switch (type) {
            case 'terrestrial_oceanic':
                generateOceanicTexture(ctx, width, height, primary, secondary, tertiary, noiseScale, seed);
                break;
            case 'barren_rocky':
                generateBarrenTexture(ctx, width, height, primary, secondary, noiseScale, seed);
                break;
            case 'gas_giant':
                generateGasGiantTexture(ctx, width, height, primary, secondary, noiseScale, seed);
                break;
            case 'ice_world':
                generateIceTexture(ctx, width, height, primary, secondary, noiseScale, seed);
                break;
            case 'volcanic':
                generateVolcanicTexture(ctx, width, height, primary, secondary, noiseScale, seed);
                break;
            default:
                generateOceanicTexture(ctx, width, height, primary, secondary, tertiary, noiseScale, seed);
        }

        // TEMPORARILY DISABLED - Testing terrain without clouds
        // if (config.cloud_layer) {
        //     const cloudColor = config.cloud_color || 0xFFFFFF;
        //     const cloudOpacity = config.cloud_opacity || 0.3;
        //     addCloudLayer(ctx, width, height, hexToRgb(cloudColor), cloudOpacity, seed + 100);
        // }

        // Create Three.js texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.needsUpdate = true;

        // Debug: Log texture info
        console.log('Texture created:', {
            width: canvas.width,
            height: canvas.height,
            type: type
        });

        // Debug: Show canvas in console (you can right-click and inspect it)
        console.log('Canvas element:', canvas);

        return texture;
    }

    /**
     * Convert hex color to RGB object
     */
    function hexToRgb(hex) {
        return {
            r: (hex >> 16) & 255,
            g: (hex >> 8) & 255,
            b: hex & 255
        };
    }

    /**
     * Lerp between two RGB colors
     */
    function lerpColor(color1, color2, t) {
        return {
            r: Math.floor(color1.r + (color2.r - color1.r) * t),
            g: Math.floor(color1.g + (color2.g - color1.g) * t),
            b: Math.floor(color1.b + (color2.b - color1.b) * t)
        };
    }

    /**
     * Generate oceanic planet texture (Earth-like)
     */
    function generateOceanicTexture(ctx, width, height, ocean, land, ice, scale, seed) {
        console.log('Generating oceanic texture using Canvas 2D API...');

        // Fill background
        ctx.fillStyle = '#141414';  // Dark background
        ctx.fillRect(0, 0, width, height);

        let bgCount = 0, tealCount = 0, amberCount = 0;

        // Draw pixel by pixel using fillRect
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x / width * scale;
                const ny = y / height * scale;

                const elevation = octaveNoise(nx, ny, 6, seed);

                // Pick color based on elevation
                let color;
                if (elevation < 0.4) {
                    // Skip - already dark background
                    bgCount++;
                    continue;
                } else if (elevation < 0.5) {
                    color = '#64b4b4';  // Bright teal rgb(100,180,180)
                    tealCount++;
                } else {
                    color = '#c89664';  // Bright amber rgb(200,150,100)
                    amberCount++;
                }

                ctx.fillStyle = color;
                ctx.fillRect(x, y, 1, 1);  // Draw 1x1 pixel
            }
        }

        console.log(`Pixel counts - BG: ${bgCount}, Teal: ${tealCount}, Amber: ${amberCount}`);
    }

    /**
     * Generate barren rocky texture (moon-like)
     */
    function generateBarrenTexture(ctx, width, height, dark, light, scale, seed) {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x / width * scale;
                const ny = y / height * scale;

                const value = octaveNoise(nx, ny, 6, seed);
                const craters = octaveNoise(nx * 3, ny * 3, 4, seed + 200);

                // Crater-like features
                let finalValue = value;
                if (craters > 0.75) {
                    finalValue = finalValue * 0.6; // Darken for craters
                }

                const color = lerpColor(dark, light, finalValue);

                const i = (y * width + x) * 4;
                data[i] = color.r;
                data[i + 1] = color.g;
                data[i + 2] = color.b;
                data[i + 3] = 255;
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Generate gas giant texture (banded)
     */
    function generateGasGiantTexture(ctx, width, height, primary, secondary, scale, seed) {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x / width * scale;
                const ny = y / height * scale;

                // Horizontal bands
                const bands = Math.sin(ny * 8 + noise2D(nx, ny, seed) * 2) * 0.5 + 0.5;
                const turbulence = octaveNoise(nx * 2, ny, 4, seed + 50) * 0.3;
                const value = bands + turbulence;

                const color = lerpColor(primary, secondary, value);

                const i = (y * width + x) * 4;
                data[i] = color.r;
                data[i + 1] = color.g;
                data[i + 2] = color.b;
                data[i + 3] = 255;
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Generate ice world texture
     */
    function generateIceTexture(ctx, width, height, ice, darkIce, scale, seed) {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x / width * scale;
                const ny = y / height * scale;

                const value = octaveNoise(nx, ny, 5, seed);
                const cracks = octaveNoise(nx * 4, ny * 4, 3, seed + 100);

                let finalValue = value;
                if (cracks > 0.7) {
                    finalValue = finalValue * 0.7; // Dark cracks
                }

                const color = lerpColor(darkIce, ice, finalValue);

                const i = (y * width + x) * 4;
                data[i] = color.r;
                data[i + 1] = color.g;
                data[i + 2] = color.b;
                data[i + 3] = 255;
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Generate volcanic texture
     */
    function generateVolcanicTexture(ctx, width, height, rock, lava, scale, seed) {
        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x / width * scale;
                const ny = y / height * scale;

                const terrain = octaveNoise(nx, ny, 5, seed);
                const heat = octaveNoise(nx * 3, ny * 3, 4, seed + 150);

                let color;
                if (heat > 0.65 && terrain > 0.4) {
                    // Lava flows
                    color = lerpColor(lava, { r: 255, g: 200, b: 100 }, (heat - 0.65) * 3);
                } else {
                    // Dark volcanic rock
                    color = lerpColor({ r: rock.r - 40, g: rock.g - 40, b: rock.b - 40 }, rock, terrain);
                }

                const i = (y * width + x) * 4;
                data[i] = color.r;
                data[i + 1] = color.g;
                data[i + 2] = color.b;
                data[i + 3] = 255;
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Add cloud layer over existing texture
     */
    function addCloudLayer(ctx, width, height, cloudColor, opacity, seed) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x / width * 4;
                const ny = y / height * 4;

                const clouds = octaveNoise(nx, ny, 4, seed);

                if (clouds > 0.5) {
                    const cloudAlpha = (clouds - 0.5) * 2 * opacity;
                    const i = (y * width + x) * 4;

                    // Blend cloud color with existing pixel
                    data[i] = Math.floor(data[i] * (1 - cloudAlpha) + cloudColor.r * cloudAlpha);
                    data[i + 1] = Math.floor(data[i + 1] * (1 - cloudAlpha) + cloudColor.g * cloudAlpha);
                    data[i + 2] = Math.floor(data[i + 2] * (1 - cloudAlpha) + cloudColor.b * cloudAlpha);
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    // ==================== END PROCEDURAL PLANET TEXTURE GENERATION ====================

    // Star rendering constants
    const STAR_DEFAULT_SIZE = 4;
    const STAR_SPHERE_SEGMENTS = 32;
    const STAR_DEFAULT_CORONA_INTENSITY = 1.5;
    const STAR_LIGHT_DISTANCE = 500;
    const STAR_GLOW_SIZE_MULTIPLIER = 1.5;
    const STAR_GLOW_OPACITY = 0.3;

    // Render central star
    function renderStar(starData) {
        const scene = window.systemMapState.scene;

        // Create star sphere
        const starGeometry = new THREE.SphereGeometry(starData.size || STAR_DEFAULT_SIZE, STAR_SPHERE_SEGMENTS, STAR_SPHERE_SEGMENTS);
        const starMaterial = new THREE.MeshBasicMaterial({
            color: starData.color || 0xFFFFAA
        });
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.position.set(0, 0, 0);
        scene.add(star);

        // Add point light at star position
        const starLight = new THREE.PointLight(
            starData.light_color || starData.color || 0xFFFFAA,
            starData.corona_intensity || STAR_DEFAULT_CORONA_INTENSITY,
            STAR_LIGHT_DISTANCE
        );
        starLight.position.set(0, 0, 0);
        scene.add(starLight);

        // Add glow effect
        const glowGeometry = new THREE.SphereGeometry(starData.size * STAR_GLOW_SIZE_MULTIPLIER || 6, STAR_SPHERE_SEGMENTS, STAR_SPHERE_SEGMENTS);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: starData.color || 0xFFFFAA,
            transparent: true,
            opacity: STAR_GLOW_OPACITY
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.set(0, 0, 0);
        scene.add(glow);

        window.systemMapState.star = { star, glow, light: starLight };
    }

    // Planet sprite rendering constants
    const PLANET_SPRITE_CANVAS_SIZE = 64;
    const PLANET_SPRITE_CENTER = 32;  // CANVAS_SIZE / 2
    const PLANET_SPRITE_RADIUS = 28;
    const PLANET_SPRITE_BORDER_WIDTH = 4;

    // Render a planet
    function renderPlanet(bodyData) {
        const scene = window.systemMapState.scene;

        // Create circle texture for planet outline
        const canvas = document.createElement('canvas');
        canvas.width = PLANET_SPRITE_CANVAS_SIZE;
        canvas.height = PLANET_SPRITE_CANVAS_SIZE;
        const ctx = canvas.getContext('2d');

        // Draw solid black circle background
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(PLANET_SPRITE_CENTER, PLANET_SPRITE_CENTER, PLANET_SPRITE_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Draw teal circle outline on top
        ctx.strokeStyle = '#5a7a7a';  // Teal to match UI
        ctx.lineWidth = PLANET_SPRITE_BORDER_WIDTH;
        ctx.beginPath();
        ctx.arc(PLANET_SPRITE_CENTER, PLANET_SPRITE_CENTER, PLANET_SPRITE_RADIUS, 0, Math.PI * 2);
        ctx.stroke();

        const texture = new THREE.CanvasTexture(canvas);

        // Create sprite with circle texture (automatically faces camera)
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthWrite: true,  // Ensure sprite writes to depth buffer to occlude objects behind it
            depthTest: true
        });

        const planet = new THREE.Sprite(spriteMaterial);
        const size = (bodyData.size || 1) * PLANET_SIZE_MULTIPLIER;  // Double size to maintain visibility
        planet.scale.set(size, size, 1);

        // Calculate initial position based on orbital_angle
        const angle = (bodyData.orbital_angle || 0) * (Math.PI / 180);
        const x = Math.cos(angle) * bodyData.orbital_radius;
        const z = Math.sin(angle) * bodyData.orbital_radius;

        // Apply orbital inclination
        const inclinationRad = (bodyData.inclination || 0) * (Math.PI / 180);
        planet.position.x = x * Math.cos(inclinationRad);
        planet.position.y = x * Math.sin(inclinationRad);
        planet.position.z = z;

        scene.add(planet);

        // Store planet data for animation
        window.systemMapState.planets.push({
            mesh: planet,
            orbitalRadius: bodyData.orbital_radius,
            orbitalPeriod: bodyData.orbital_period || 365,
            initialAngle: angle,
            inclination: bodyData.inclination || 0,  // Store inclination in degrees
            name: bodyData.name,
            clickable: bodyData.clickable || false,
            locationSlug: bodyData.location_slug
        });
    }

    // Orbit rendering constants
    const ORBIT_CURVE_POINTS = 128;
    const ORBIT_DEFAULT_OPACITY = 0.45;

    // Render orbital path
    function renderOrbit(bodyData, orbitSettings) {
        const scene = window.systemMapState.scene;

        const curve = new THREE.EllipseCurve(
            0, 0,
            bodyData.orbital_radius, bodyData.orbital_radius,
            0, 2 * Math.PI,
            false,
            0
        );

        const points = curve.getPoints(ORBIT_CURVE_POINTS);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({
            color: orbitSettings.color || 0x5a7a7a,
            transparent: true,
            opacity: orbitSettings.opacity || ORBIT_DEFAULT_OPACITY
        });

        const orbit = new THREE.Line(geometry, material);

        // Rotate to XZ plane
        orbit.rotation.x = Math.PI / 2;

        // Apply orbital inclination (tilt around Y axis)
        const inclination = bodyData.inclination || 0;  // Inclination in degrees
        orbit.rotation.y = inclination * (Math.PI / 180);  // Convert to radians

        scene.add(orbit);

        window.systemMapState.orbits.push(orbit);
    }

    // Planet animation constants
    const PLANET_ROTATION_SPEED = 0.01;
    const PLANET_SIZE_MULTIPLIER = 2;
    const ORBITAL_PERIOD_TARGET_SECONDS = 10;

    // Animation loop for system map
    function animateSystemMap() {
        window.systemMapState.animationFrameId = requestAnimationFrame(animateSystemMap);

        const scene = window.systemMapState.scene;
        const camera = window.systemMapState.camera;
        const renderer = window.systemMapState.renderer;

        if (!scene || !camera || !renderer) return;

        // Animate planets along their orbits
        const currentTime = Date.now();
        const elapsedSeconds = (currentTime - window.systemMapState.startTime) / 1000;

        window.systemMapState.planets.forEach(planetData => {
            // Calculate current angle based on orbital period
            // Use system-specific speed multiplier (calculated so fastest planet orbits once per ORBITAL_PERIOD_TARGET_SECONDS)
            const orbitalSpeed = (2 * Math.PI) / planetData.orbitalPeriod * window.systemMapState.speedMultiplier;
            const currentAngle = planetData.initialAngle + (orbitalSpeed * elapsedSeconds);

            // Calculate position in orbital plane (before inclination)
            const x = Math.cos(currentAngle) * planetData.orbitalRadius;
            const z = Math.sin(currentAngle) * planetData.orbitalRadius;

            // Apply orbital inclination
            const inclinationRad = planetData.inclination * (Math.PI / 180);

            // Rotate position around Y axis by inclination angle
            planetData.mesh.position.x = x * Math.cos(inclinationRad);
            planetData.mesh.position.y = x * Math.sin(inclinationRad);
            planetData.mesh.position.z = z;

            // Rotate planet on its axis
            planetData.mesh.rotation.y += PLANET_ROTATION_SPEED;
        });

        // Camera tracking: follow selected planet with locked orientation
        if (window.systemMapState.selectedPlanet && window.systemMapState.cameraOffset) {
            const selectedPlanetData = window.systemMapState.planets.find(
                p => p.name === window.systemMapState.selectedPlanet.name
            );

            if (selectedPlanetData && selectedPlanetData.mesh) {
                const planetPos = selectedPlanetData.mesh.position;

                // Calculate planet's current orbital angle
                const currentPlanetAngle = Math.atan2(planetPos.z, planetPos.x);

                // Calculate how much the planet has rotated since last frame
                const angleChange = currentPlanetAngle - window.systemMapState.lastPlanetAngle;

                // Rotate the camera offset by the same amount (around Y axis)
                const offset = window.systemMapState.cameraOffset;
                const cos = Math.cos(angleChange);
                const sin = Math.sin(angleChange);

                const rotatedOffsetX = offset.x * cos - offset.z * sin;
                const rotatedOffsetZ = offset.x * sin + offset.z * cos;

                // Update stored offset with rotated values
                window.systemMapState.cameraOffset.x = rotatedOffsetX;
                window.systemMapState.cameraOffset.z = rotatedOffsetZ;

                // Update stored angle
                window.systemMapState.lastPlanetAngle = currentPlanetAngle;

                // Apply the rotated offset to camera position
                camera.position.x = planetPos.x + rotatedOffsetX;
                camera.position.y = planetPos.y + offset.y;  // Y doesn't rotate
                camera.position.z = planetPos.z + rotatedOffsetZ;

                // Always look at the planet
                camera.lookAt(planetPos);

                // Update reticle position to follow selected planet
                if (window.systemMapState.selectionReticle) {
                    window.systemMapState.selectionReticle.position.copy(planetPos);
                }
            }
        }

        renderer.render(scene, camera);
    }

    // Clear system map
    function clearSystemMap() {
        const scene = window.systemMapState.scene;
        if (!scene) return;

        // Remove all planets
        window.systemMapState.planets.forEach(p => scene.remove(p.mesh));
        window.systemMapState.planets = [];

        // Remove all orbits
        window.systemMapState.orbits.forEach(o => scene.remove(o));
        window.systemMapState.orbits = [];

        // Remove star
        if (window.systemMapState.star) {
            scene.remove(window.systemMapState.star.star);
            scene.remove(window.systemMapState.star.glow);
            scene.remove(window.systemMapState.star.light);
            window.systemMapState.star = null;
        }

        // Hide reticle and clear selection state
        if (window.systemMapState.selectionReticle) {
            window.systemMapState.selectionReticle.visible = false;
        }
        window.systemMapState.selectedPlanet = null;
        window.systemMapState.cameraOffset = null;
        window.systemMapState.lastPlanetAngle = 0;
    }

    // Show system map, hide galaxy map with animated transition
    function showSystemMap(starPosition) {
        const galaxyCanvas = document.getElementById('starmap-canvas');
        const systemCanvas = document.getElementById('systemmap-canvas');

        // If no star position provided, do instant transition (fallback)
        if (!starPosition || !window.starMapState || !window.starMapState.camera) {
            galaxyCanvas.style.display = 'none';
            systemCanvas.style.display = 'block';
            return;
        }

        const galaxyCamera = window.starMapState.camera;
        const startPos = galaxyCamera.position.clone();
        const startLookAt = starPosition.clone();

        // Store original camera position for zoom-out later
        window.starMapState.preSystemViewCameraPosition = startPos.clone();

        // Calculate zoom-in target (move camera closer to star)
        const zoomDirection = new THREE.Vector3().subVectors(starPosition, startPos).normalize();
        const zoomDistance = startPos.distanceTo(starPosition) * 0.3; // Zoom to 30% of distance
        const targetPos = startPos.clone().add(zoomDirection.multiplyScalar(zoomDistance));

        // Make both canvases visible for crossfade
        galaxyCanvas.style.display = 'block';
        systemCanvas.style.display = 'block';
        galaxyCanvas.style.opacity = '1';
        systemCanvas.style.opacity = '0';

        if (typeof gsap !== 'undefined') {
            const animState = { progress: 0 };

            gsap.to(animState, {
                progress: 1,
                duration: 1.5, // 1.5 second transition
                ease: "power2.inOut",
                onUpdate: function() {
                    // Zoom galaxy camera toward star
                    galaxyCamera.position.lerpVectors(startPos, targetPos, animState.progress);
                    galaxyCamera.lookAt(startLookAt);

                    // Crossfade canvases
                    galaxyCanvas.style.opacity = (1 - animState.progress).toString();
                    systemCanvas.style.opacity = animState.progress.toString();
                },
                onComplete: function() {
                    // Hide galaxy canvas after transition
                    galaxyCanvas.style.display = 'none';
                    galaxyCanvas.style.opacity = '1'; // Reset for next time
                    systemCanvas.style.opacity = '1';
                }
            });
        } else {
            // Fallback: instant transition
            galaxyCanvas.style.display = 'none';
            systemCanvas.style.display = 'block';
        }
    }

    // Hide system map, show galaxy map with animated transition
    function hideSystemMap() {
        const galaxyCanvas = document.getElementById('starmap-canvas');
        const systemCanvas = document.getElementById('systemmap-canvas');

        // Stop system map animation
        if (window.systemMapState.animationFrameId) {
            cancelAnimationFrame(window.systemMapState.animationFrameId);
            window.systemMapState.animationFrameId = null;
        }

        // Clear selected planet state
        window.systemMapState.selectedPlanet = null;

        // Get star position for zoom-out animation
        const selectedSystem = localStorage.getItem('selected_star_system');
        let starPosition = null;
        if (selectedSystem && window.starMapState && window.starMapState.starPositions) {
            starPosition = window.starMapState.starPositions.get(selectedSystem);
        }

        // If no star position or camera, do instant transition (fallback)
        if (!starPosition || !window.starMapState || !window.starMapState.camera) {
            systemCanvas.style.display = 'none';
            galaxyCanvas.style.display = 'block';
            showGalaxyList();
            return;
        }

        const galaxyCamera = window.starMapState.camera;

        // Get the stored camera position from before entering system view
        const currentPos = galaxyCamera.position.clone();
        const targetPos = window.starMapState.preSystemViewCameraPosition || currentPos;

        // If we don't have a stored position, fall back to instant transition
        if (!window.starMapState.preSystemViewCameraPosition) {
            systemCanvas.style.display = 'none';
            galaxyCanvas.style.display = 'block';
            showGalaxyList();
            return;
        }

        // Make both canvases visible for crossfade
        galaxyCanvas.style.display = 'block';
        systemCanvas.style.display = 'block';
        galaxyCanvas.style.opacity = '0';
        systemCanvas.style.opacity = '1';

        if (typeof gsap !== 'undefined') {
            const animState = { progress: 0 };

            gsap.to(animState, {
                progress: 1,
                duration: 1.5, // 1.5 second transition
                ease: "power2.inOut",
                onUpdate: function() {
                    // Zoom galaxy camera away from star
                    galaxyCamera.position.lerpVectors(currentPos, targetPos, animState.progress);
                    galaxyCamera.lookAt(starPosition);

                    // Crossfade canvases
                    systemCanvas.style.opacity = (1 - animState.progress).toString();
                    galaxyCanvas.style.opacity = animState.progress.toString();
                },
                onComplete: function() {
                    // Hide system canvas after transition
                    systemCanvas.style.display = 'none';
                    systemCanvas.style.opacity = '1'; // Reset for next time
                    galaxyCanvas.style.opacity = '1';

                    // Restore galaxy list after transition
                    showGalaxyList();
                }
            });
        } else {
            // Fallback: instant transition
            systemCanvas.style.display = 'none';
            galaxyCanvas.style.display = 'block';
            showGalaxyList();
        }
    }

    // ==================== ORBIT MAP NAVIGATION ====================

    // Navigate back from orbit map to system map
    function returnToSystemMap() {
        const canvas = document.getElementById('systemmap-canvas');

        if (typeof gsap !== 'undefined' && canvas) {

            // Fade out orbit map
            gsap.to(canvas, {
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
                onComplete: function() {
                    // Clear orbit map
                    if (window.clearOrbitMap) {
                        window.clearOrbitMap();
                    }

                    // Stop orbit map animation
                    if (window.orbitMapState && window.orbitMapState.animationFrameId) {
                        cancelAnimationFrame(window.orbitMapState.animationFrameId);
                        window.orbitMapState.animationFrameId = null;
                    }

                    // Switch active view flags
                    window.orbitMapState.isActive = false;
                    window.systemMapState.isActive = true;

                    // Restore system map animation
                    if (!window.systemMapState.animationFrameId) {
                        window.systemMapState.startTime = Date.now();
                        animateSystemMap();
                    }

                    // Restore planet list with the previously viewed planet selected
                    const systemData = window.systemMapState.currentSystem;
                    if (systemData) {
                        const lastViewedPlanet = window.systemMapState.lastViewedPlanet;
                        showPlanetList(systemData);

                        // Restore planet selection if there was one
                        if (lastViewedPlanet) {
                            const planetRow = document.querySelector(`.planet-row[data-planet="${lastViewedPlanet}"]`);
                            if (planetRow) {
                                planetRow.classList.add('checked');
                                const checkbox = planetRow.querySelector('[role="checkbox"]');
                                if (checkbox) checkbox.setAttribute('aria-checked', 'true');

                                // Restore planet info panel
                                const planet = systemData.bodies?.find(b => b.name === lastViewedPlanet);
                                if (planet) {
                                    selectPlanet(planet);
                                    zoomToPlanet(planet.name);
                                }
                            }
                        }
                    }

                    // Fade in system map
                    gsap.to(canvas, {
                        opacity: 1,
                        duration: 0.4,
                        ease: "power2.out"
                    });
                }
            });
        } else {
            // Fallback: instant transition
            if (window.clearOrbitMap) {
                window.clearOrbitMap();
            }
            if (window.orbitMapState && window.orbitMapState.animationFrameId) {
                cancelAnimationFrame(window.orbitMapState.animationFrameId);
                window.orbitMapState.animationFrameId = null;
            }
            window.orbitMapState.isActive = false;
            window.systemMapState.isActive = true;
            if (!window.systemMapState.animationFrameId) {
                window.systemMapState.startTime = Date.now();
                animateSystemMap();
            }
            const systemData = window.systemMapState.currentSystem;
            if (systemData) {
                showPlanetList(systemData);
            }
        }
    }

    // Transition from system map to orbit map with zoom animation
    function transitionToOrbitMap(systemSlug, planetSlug) {
        // Find the planet mesh to zoom toward
        const planetData = window.systemMapState.planets.find(p => p.locationSlug === planetSlug);
        if (!planetData || !planetData.mesh) {
            window.loadOrbitMap(systemSlug, planetSlug);
            return;
        }

        // Get the system data to find planet by name
        const systemData = window.systemMapState.currentSystem;
        const planet = systemData?.bodies?.find(b => (b.location_slug || b.name.toLowerCase().replace(/\s+/g, '-')) === planetSlug);

        if (!planet) {
            window.loadOrbitMap(systemSlug, planetSlug);
            return;
        }

        // Check if planet is already selected
        const isPlanetSelected = window.systemMapState.selectedPlanet?.name === planet.name;

        if (!isPlanetSelected) {

            // Find all planet rows and deselect them
            const starMapPanel = document.getElementById('star-map-panel');
            const allPlanetRows = starMapPanel.querySelectorAll('.planet-row');
            allPlanetRows.forEach(row => {
                row.classList.remove('checked');
                const cb = row.querySelector('[role="checkbox"]');
                if (cb) cb.setAttribute('aria-checked', 'false');
            });

            // Select this planet's row
            const planetRow = document.querySelector(`.planet-row[data-planet="${planet.name}"]`);

            if (planetRow) {
                planetRow.classList.add('checked');
                const checkbox = planetRow.querySelector('[role="checkbox"]');
                if (checkbox) checkbox.setAttribute('aria-checked', 'true');

                // Update info panel
                selectPlanet(planet);

                // Trigger zoom animation directly
                zoomToPlanet(planet.name);

                // Wait for zoom to complete, then transition
                setTimeout(() => {
                    doOrbitTransition(systemSlug, planetSlug, planetData);
                }, 1100);
                return;
            }
        }

        // Planet already selected, go straight to transition
        doOrbitTransition(systemSlug, planetSlug, planetData);
    }

    // Internal function to perform the actual orbit map transition
    function doOrbitTransition(systemSlug, planetSlug, planetData) {
        // Store which planet we're viewing for later restoration
        window.systemMapState.lastViewedPlanet = planetData.name;

        // Stop system map animation
        if (window.systemMapState.animationFrameId) {
            cancelAnimationFrame(window.systemMapState.animationFrameId);
            window.systemMapState.animationFrameId = null;
        }

        const camera = window.systemMapState.camera;
        const planetPosition = new THREE.Vector3();
        planetData.mesh.getWorldPosition(planetPosition);
        const canvas = document.getElementById('systemmap-canvas');

        // Calculate zoom target (get very close to the planet)
        const startPos = camera.position.clone();
        const direction = new THREE.Vector3().subVectors(planetPosition, startPos).normalize();
        const planetSize = planetData.size || 5;
        const targetDistance = planetSize * 1.5; // Zoom very close
        const targetPos = planetPosition.clone().add(direction.clone().multiplyScalar(-targetDistance));

        if (typeof gsap !== 'undefined') {
            const scene = window.systemMapState.scene;
            const renderer = window.systemMapState.renderer;

            // Create a timeline for the full transition
            const timeline = gsap.timeline();

            // Step 1: Zoom even closer to planet (0.6s)
            timeline.to(camera.position, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 0.6,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(planetPosition);
                    if (scene && renderer) {
                        renderer.render(scene, camera);
                    }
                }
            });

            // Step 2: Fade out canvas (0.3s)
            timeline.to(canvas, {
                opacity: 0,
                duration: 0.3,
                ease: "power2.in",
                onComplete: function() {
                    window.loadOrbitMap(systemSlug, planetSlug);
                }
            });

            // Step 3: Fade back in (0.4s)
            timeline.to(canvas, {
                opacity: 1,
                duration: 0.4,
                ease: "power2.out"
            });

        } else {
            // Fallback: instant transition
            window.loadOrbitMap(systemSlug, planetSlug);
        }
    }

    // Make functions globally accessible
    window.returnToSystemMap = returnToSystemMap;
    window.transitionToOrbitMap = transitionToOrbitMap;

    // Update menu panel to show orbit map contents
    function updateOrbitMapMenu(orbitData) {
        const starMapPanel = document.getElementById('star-map-panel');
        if (!starMapPanel) {
            console.error('❌ star-map-panel element not found!');
            return;
        }

        let menuHTML = `
            <div class="star-system-row back-to-system-btn"
                 role="button"
                 tabindex="0"
                 aria-label="Return to system view"
                 data-action="back-to-system"
                 style="margin-bottom: 12px; border-color: var(--color-amber);">
                <div class="star-system-content">
                    <div class="star-system-checkbox" style="display: flex; align-items: center; justify-content: center; color: var(--color-amber); font-size: 14px; background: none; border: none; margin-left: 2px;">◀</div>
                    <div class="star-system-name" style="color: var(--color-amber);">BACK TO SYSTEM</div>
                </div>
            </div>
        `;

        // Show moons as clickable rows
        if (orbitData.moons && orbitData.moons.length > 0) {
            orbitData.moons.forEach(moon => {
                const moonName = moon.name || 'Unknown Moon';
                const hasFacilities = moon.has_facilities || false;

                let indicatorsHTML = '';
                if (hasFacilities) {
                    indicatorsHTML = '<div class="facility-indicators">';
                    indicatorsHTML += '<div class="facility-indicator facility-square" title="Has facilities"></div>';
                    indicatorsHTML += '</div>';
                }

                menuHTML += `
                    <div class="star-system-row"
                         role="button"
                         tabindex="0"
                         data-type="moon"
                         data-name="${moonName}">
                        <div class="star-system-content">
                            <div class="star-system-checkbox" role="checkbox" aria-checked="false"></div>
                            <div class="star-system-name">${moonName}</div>
                            ${indicatorsHTML}
                        </div>
                    </div>
                `;
            });
        }

        // Show orbital stations as clickable rows
        if (orbitData.orbital_stations && orbitData.orbital_stations.length > 0) {
            orbitData.orbital_stations.forEach(station => {
                const stationName = station.name || 'Unknown Station';

                menuHTML += `
                    <div class="star-system-row"
                         role="button"
                         tabindex="0"
                         data-type="station"
                         data-name="${stationName}">
                        <div class="star-system-content">
                            <div class="star-system-checkbox" role="checkbox" aria-checked="false"></div>
                            <div class="star-system-name">${stationName}</div>
                            <div class="facility-indicators">
                                <div class="facility-indicator facility-triangle" title="Orbital station"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }

        // Show surface markers as clickable rows
        if (orbitData.surface_markers && orbitData.surface_markers.length > 0) {
            orbitData.surface_markers.forEach(marker => {
                const markerName = marker.name || 'Unknown Location';
                const markerType = marker.marker_type || 'base';

                menuHTML += `
                    <div class="star-system-row"
                         role="button"
                         tabindex="0"
                         data-type="surface"
                         data-name="${markerName}">
                        <div class="star-system-content">
                            <div class="star-system-checkbox" role="checkbox" aria-checked="false"></div>
                            <div class="star-system-name">${markerName}</div>
                            <div class="facility-indicators">
                                <div class="facility-indicator facility-square" title="${markerType}"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }

        starMapPanel.innerHTML = menuHTML;

        // Add event delegation for back button and items
        setupOrbitMapMenuDelegation();
    }

    // Make function globally accessible for orbit map module
    window.updateOrbitMapMenu = updateOrbitMapMenu;

    // Event delegation for orbit map menu
    function setupOrbitMapMenuDelegation() {
        const starMapPanel = document.getElementById('star-map-panel');
        if (!starMapPanel) return;

        // Remove old listeners if they exist
        if (starMapPanel._orbitMapMenuHandler) {
            starMapPanel.removeEventListener('click', starMapPanel._orbitMapMenuHandler);
            starMapPanel._orbitMapMenuHandler = null;
        }

        // Create new delegated click handler
        const clickHandler = function(event) {
            // Check for back button
            const backButton = event.target.closest('[data-action="back-to-system"]');
            if (backButton) {
                returnToSystemMap();
                return;
            }

            // Check for orbit map element selection
            const elementRow = event.target.closest('[data-type]');
            if (elementRow) {
                const elementType = elementRow.dataset.type;
                const elementName = elementRow.dataset.name;

                // Toggle selection
                const isCurrentlySelected = elementRow.classList.contains('checked');

                if (isCurrentlySelected) {
                    // Deselect - clear selection
                    elementRow.classList.remove('checked');
                    const checkbox = elementRow.querySelector('.star-system-checkbox');
                    if (checkbox) checkbox.setAttribute('aria-checked', 'false');
                    unselectOrbitMapElement();
                } else {
                    // Deselect all other elements
                    const allRows = starMapPanel.querySelectorAll('[data-type]');
                    allRows.forEach(row => {
                        row.classList.remove('checked');
                        const cb = row.querySelector('.star-system-checkbox');
                        if (cb) cb.setAttribute('aria-checked', 'false');
                    });

                    // Select this element
                    elementRow.classList.add('checked');
                    const checkbox = elementRow.querySelector('.star-system-checkbox');
                    if (checkbox) checkbox.setAttribute('aria-checked', 'true');

                    // Show element info in panel
                    selectOrbitMapElement(elementType, elementName);
                }
            }
        };

        starMapPanel.addEventListener('click', clickHandler);
        starMapPanel._orbitMapMenuHandler = clickHandler;
    }

    /**
     * Select an orbit map element and show its info in the details panel
     * @param {string} elementType - Type of element: 'moon', 'station', or 'surface'
     * @param {string} elementName - Name of the element
     */
    async function selectOrbitMapElement(elementType, elementName) {
        const infoPanel = document.getElementById('system-info-panel');
        const infoPanelName = document.getElementById('system-info-name');
        const infoPanelContent = document.getElementById('system-info-content');

        if (!infoPanel || !infoPanelName || !infoPanelContent) {
            console.error('System info panel elements not found');
            return;
        }

        // Track this operation with a sequence number to prevent race conditions
        if (!window.systemMapState.infoPanelUpdateSequence) {
            window.systemMapState.infoPanelUpdateSequence = 0;
        }
        window.systemMapState.infoPanelUpdateSequence++;
        const thisSequence = window.systemMapState.infoPanelUpdateSequence;

        // Get the orbit map data
        const orbitData = window.orbitMapState?.orbitMapData;
        if (!orbitData) {
            console.error('Orbit map data not found');
            return;
        }

        // Find the element in the orbit data
        let elementData = null;
        if (elementType === 'moon' && orbitData.moons) {
            elementData = orbitData.moons.find(m => m.name === elementName);
        } else if (elementType === 'station' && orbitData.orbital_stations) {
            elementData = orbitData.orbital_stations.find(s => s.name === elementName);
        } else if (elementType === 'surface' && orbitData.surface_markers) {
            elementData = orbitData.surface_markers.find(m => m.name === elementName);
        }

        if (!elementData) {
            console.error(`Element not found: ${elementType} - ${elementName}`);
            return;
        }

        // Find the mesh for this element in the scene
        let elementMesh = null;
        if (elementType === 'moon') {
            const moonData = window.orbitMapState.moons.find(m => m.name === elementName);
            elementMesh = moonData?.mesh;
        } else if (elementType === 'station') {
            const stationData = window.orbitMapState.stations.find(s => s.name === elementName);
            elementMesh = stationData?.mesh;
        } else if (elementType === 'surface') {
            const markerData = window.orbitMapState.markers.find(m => m.name === elementName);
            elementMesh = markerData?.mesh;
        }

        if (!elementMesh) {
            console.error(`Mesh not found for ${elementType}: ${elementName}`);
            return;
        }

        // Store selected element reference
        window.orbitMapState.selectedElement = {
            type: elementType,
            name: elementName,
            mesh: elementMesh,
            data: elementData
        };

        // Position and show the selection reticle
        if (window.orbitMapState.selectionReticle) {
            const reticle = window.orbitMapState.selectionReticle;

            // Position reticle on element
            reticle.position.copy(elementMesh.position);

            // Scale reticle based on element type and size
            let reticleScale = 5;  // Default
            if (elementType === 'moon') {
                reticleScale = (elementData.size || 2.5) * 6.0;  // Bigger reticle for moons
            } else if (elementType === 'station') {
                reticleScale = (elementData.size || 1.5) * 4.0;
            } else if (elementType === 'surface') {
                reticleScale = 3.0;  // Fixed size for surface markers
            }
            reticle.scale.set(reticleScale, reticleScale, 1);

            // Show reticle
            reticle.visible = true;
        }

        // Animate camera to zoom to selected element (using GSAP)
        const camera = window.orbitMapState.camera;
        const elementPosition = elementMesh.position.clone();
        const planetRadius = orbitData.planet?.size || 15;

        // For orbiting objects (moons/stations), position camera relative to the element
        // so it orbits around the element, not the planet
        let cameraTarget;

        if (elementType === 'moon' || elementType === 'station') {
            // Get element size for distance calculation
            const elementSize = elementData.size || (elementType === 'moon' ? 2.5 : 1.5);

            // Camera distance from element (closer for smaller objects)
            const distanceFromElement = elementType === 'moon'
                ? elementSize * 8 + 10  // Moons: farther back
                : elementSize * 6 + 8;   // Stations: closer

            // Position camera offset from element (away from planet, slightly above)
            const directionFromPlanet = elementPosition.clone().normalize();
            cameraTarget = elementPosition.clone()
                .add(directionFromPlanet.multiplyScalar(distanceFromElement));

            // Add upward offset for better viewing angle
            cameraTarget.y += distanceFromElement * 0.4;

            // Store that we're tracking this element (animation loop will update lookAt)
            window.orbitMapState.cameraLookAt = null;  // null = track selectedElement

        } else {
            // For surface markers, position camera outside planet looking at marker
            const directionToElement = elementPosition.clone().normalize();
            const cameraDistanceFromCenter = planetRadius * 2.2;

            cameraTarget = directionToElement.multiplyScalar(cameraDistanceFromCenter);
            cameraTarget.y += planetRadius * 0.3;

            // Pause planet/orbit animation while viewing surface marker
            // This keeps the marker stationary so user can zoom/rotate freely
            window.orbitMapState.animationPaused = true;
            window.orbitMapState.pausedAt = Date.now();

            // Surface markers - camera looks at element but doesn't track (animation paused)
            window.orbitMapState.cameraLookAt = null;
        }

        // Animate camera position
        gsap.to(camera.position, {
            duration: 1.0,
            x: cameraTarget.x,
            y: cameraTarget.y,
            z: cameraTarget.z,
            ease: "power2.inOut",
            onUpdate: function() {
                // During animation, look at element's current position
                if (window.orbitMapState.selectedElement?.mesh) {
                    camera.lookAt(window.orbitMapState.selectedElement.mesh.position);
                }
            },
            onComplete: function() {
                // Ensure final look direction is correct
                if (window.orbitMapState.selectedElement?.mesh) {
                    camera.lookAt(window.orbitMapState.selectedElement.mesh.position);
                }
            }
        });

        // Build info HTML based on element type
        let contentHTML = '';
        if (elementType === 'moon') {
            contentHTML = buildMoonInfoHTML(elementData);
        } else if (elementType === 'station') {
            contentHTML = buildStationInfoHTML(elementData);
        } else if (elementType === 'surface') {
            contentHTML = buildSurfaceMarkerInfoHTML(elementData);
        }

        // Fade out old content first
        infoPanelContent.style.opacity = '0';
        infoPanelContent.style.transition = 'opacity 300ms ease';

        // Wait for fade out
        await new Promise(resolve => setTimeout(resolve, 300));

        // Check if this operation is still current
        if (window.systemMapState.infoPanelUpdateSequence !== thisSequence) {
            console.log('Orbit map element selection superseded, skipping panel update');
            return;
        }

        // Update panel title
        infoPanelName.textContent = elementName.toUpperCase();
        infoPanelContent.style.opacity = '1';
        infoPanel.classList.add('visible');

        // Typewriter effect for content
        window.typewriteContent(infoPanelContent, contentHTML).then(() => {
            // After typewriter completes, verify this operation is still current
            if (window.systemMapState.infoPanelUpdateSequence !== thisSequence) {
                console.log('Orbit map element selection was superseded during typewriter - force-correcting panel');
                validateAndCorrectPanel(true);
            } else {
                console.log(`Selected ${elementType}:`, elementName);
            }
        });
    }

    /**
     * Unselect orbit map element and restore planet info
     */
    function unselectOrbitMapElement() {
        const infoPanel = document.getElementById('system-info-panel');
        const infoPanelName = document.getElementById('system-info-name');
        const infoPanelContent = document.getElementById('system-info-content');

        if (!infoPanel || !infoPanelName || !infoPanelContent) return;

        // Increment sequence to supersede any ongoing typewriter
        if (!window.systemMapState.infoPanelUpdateSequence) {
            window.systemMapState.infoPanelUpdateSequence = 0;
        }
        window.systemMapState.infoPanelUpdateSequence++;

        // Restore full planet info from system map data
        const planetData = window.systemMapState?.selectedPlanet;
        if (planetData) {
            infoPanelName.textContent = planetData.name.toUpperCase();
            infoPanelContent.innerHTML = buildPlanetInfoHTML(planetData);
        }

        // Hide selection reticle
        if (window.orbitMapState.selectionReticle) {
            window.orbitMapState.selectionReticle.visible = false;
        }

        // Clear selected element reference BEFORE animation so tracking stops
        window.orbitMapState.selectedElement = null;

        // Resume animation if it was paused (for surface markers)
        if (window.orbitMapState.animationPaused && window.orbitMapState.pausedAt) {
            // Adjust startTime to account for pause duration so orbits don't jump
            const pauseDuration = Date.now() - window.orbitMapState.pausedAt;
            window.orbitMapState.startTime += pauseDuration;
            window.orbitMapState.animationPaused = false;
            window.orbitMapState.pausedAt = null;
        }

        // Clear surface camera offset if it was set
        window.orbitMapState.surfaceCameraOffset = null;

        // Set camera to look at planet center again
        window.orbitMapState.cameraLookAt = { x: 0, y: 0, z: 0 };

        // Animate camera back to default planet view
        const camera = window.orbitMapState.camera;
        const defaultPos = window.orbitMapState.defaultCameraPosition;

        if (camera && defaultPos) {
            gsap.to(camera.position, {
                duration: 1.0,
                x: defaultPos.x,
                y: defaultPos.y,
                z: defaultPos.z,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(0, 0, 0);  // Look at planet center during animation
                },
                onComplete: function() {
                    camera.lookAt(0, 0, 0);  // Ensure final look direction
                }
            });
        }

        console.log('Deselected orbit map element, restored planet info');
    }

    /**
     * Build info HTML for a moon
     */
    function buildMoonInfoHTML(moon) {
        let html = '<div class="info-section">';
        html += '<div class="info-label">TYPE</div>';
        html += '<div class="info-value">Moon</div>';
        html += '</div>';

        if (moon.info) {
            if (moon.info.description) {
                html += '<div class="info-section">';
                html += '<div class="info-label">DESCRIPTION</div>';
                html += `<div class="info-value">${moon.info.description}</div>`;
                html += '</div>';
            }

            if (moon.info.population) {
                html += '<div class="info-section">';
                html += '<div class="info-label">POPULATION</div>';
                html += `<div class="info-value">${moon.info.population}</div>`;
                html += '</div>';
            }
        }

        if (moon.orbital_radius) {
            html += '<div class="info-section">';
            html += '<div class="info-label">ORBITAL RADIUS</div>';
            html += `<div class="info-value">${moon.orbital_radius} AU</div>`;
            html += '</div>';
        }

        if (moon.has_facilities) {
            html += '<div class="info-section">';
            html += '<div class="info-label">FACILITIES</div>';
            html += '<div class="info-value">Surface installations present</div>';
            html += '</div>';
        }

        return html;
    }

    /**
     * Build info HTML for an orbital station
     */
    function buildStationInfoHTML(station) {
        let html = '<div class="info-section">';
        html += '<div class="info-label">TYPE</div>';
        html += `<div class="info-value">${station.info?.type || 'Orbital Station'}</div>`;
        html += '</div>';

        if (station.info) {
            if (station.info.description) {
                html += '<div class="info-section">';
                html += '<div class="info-label">DESCRIPTION</div>';
                html += `<div class="info-value">${station.info.description}</div>`;
                html += '</div>';
            }

            if (station.info.population) {
                html += '<div class="info-section">';
                html += '<div class="info-label">POPULATION</div>';
                html += `<div class="info-value">${station.info.population}</div>`;
                html += '</div>';
            }

            if (station.info.status) {
                html += '<div class="info-section">';
                html += '<div class="info-label">STATUS</div>';
                html += `<div class="info-value">${station.info.status}</div>`;
                html += '</div>';
            }
        }

        if (station.orbital_radius) {
            html += '<div class="info-section">';
            html += '<div class="info-label">ORBITAL RADIUS</div>';
            html += `<div class="info-value">${station.orbital_radius} AU</div>`;
            html += '</div>';
        }

        return html;
    }

    /**
     * Build info HTML for a surface marker
     */
    function buildSurfaceMarkerInfoHTML(marker) {
        let html = '<div class="info-section">';
        html += '<div class="info-label">TYPE</div>';
        html += `<div class="info-value">${marker.info?.type || marker.marker_type || 'Surface Location'}</div>`;
        html += '</div>';

        if (marker.info) {
            if (marker.info.description) {
                html += '<div class="info-section">';
                html += '<div class="info-label">DESCRIPTION</div>';
                html += `<div class="info-value">${marker.info.description}</div>`;
                html += '</div>';
            }

            if (marker.info.population) {
                html += '<div class="info-section">';
                html += '<div class="info-label">POPULATION</div>';
                html += `<div class="info-value">${marker.info.population}</div>`;
                html += '</div>';
            }

            if (marker.info.traffic) {
                html += '<div class="info-section">';
                html += '<div class="info-label">TRAFFIC</div>';
                html += `<div class="info-value">${marker.info.traffic}</div>`;
                html += '</div>';
            }

            if (marker.info.status) {
                html += '<div class="info-section">';
                html += '<div class="info-label">STATUS</div>';
                html += `<div class="info-value">${marker.info.status}</div>`;
                html += '</div>';
            }
        }

        if (marker.latitude !== undefined && marker.longitude !== undefined) {
            html += '<div class="info-section">';
            html += '<div class="info-label">COORDINATES</div>';
            html += `<div class="info-value">${marker.latitude.toFixed(2)}°, ${marker.longitude.toFixed(2)}°</div>`;
            html += '</div>';
        }

        return html;
    }

    /**
     * Build info HTML for planet in orbit map view
     */
    function buildPlanetOrbitInfoHTML(planet) {
        const orbitData = window.orbitMapState?.orbitMapData;

        let html = '<div class="info-section">';
        html += '<div class="info-label">TYPE</div>';
        html += '<div class="info-value">Planet</div>';
        html += '</div>';

        // Show orbital environment summary
        if (orbitData) {
            const moonCount = orbitData.moons?.length || 0;
            const stationCount = orbitData.orbital_stations?.length || 0;
            const surfaceCount = orbitData.surface_markers?.length || 0;

            if (moonCount > 0) {
                html += '<div class="info-section">';
                html += '<div class="info-label">MOONS</div>';
                html += `<div class="info-value">${moonCount}</div>`;
                html += '</div>';
            }

            if (stationCount > 0) {
                html += '<div class="info-section">';
                html += '<div class="info-label">ORBITAL STATIONS</div>';
                html += `<div class="info-value">${stationCount}</div>`;
                html += '</div>';
            }

            if (surfaceCount > 0) {
                html += '<div class="info-section">';
                html += '<div class="info-label">SURFACE LOCATIONS</div>';
                html += `<div class="info-value">${surfaceCount}</div>`;
                html += '</div>';
            }
        }

        if (planet.size) {
            html += '<div class="info-section">';
            html += '<div class="info-label">RADIUS</div>';
            html += `<div class="info-value">${planet.size} units</div>`;
            html += '</div>';
        }

        if (planet.axial_tilt !== undefined) {
            html += '<div class="info-section">';
            html += '<div class="info-label">AXIAL TILT</div>';
            html += `<div class="info-value">${planet.axial_tilt}°</div>`;
            html += '</div>';
        }

        return html;
    }

    // ==================== PLANET LIST FEATURE ====================

    // Constants for planet zoom and camera positioning
    const PLANET_ZOOM_DISTANCE_RATIO = 0.3;  // Zoom to 30% of orbital radius
    const MIN_PLANET_ZOOM_DISTANCE = 20;      // Minimum zoom distance
    const CAMERA_ANGLE_45_DEG = 0.7071;       // cos(45°) = sin(45°)
    const CAMERA_ANIMATION_DURATION = 1.5;    // seconds
    const CAMERA_ANIMATION_EASE = "power2.inOut";

    // Timing constants for animations and delays (milliseconds)
    const TIMING_RENDER_DELAY = 50;
    const TIMING_VIEW_TRANSITION = 100;
    const TIMING_FADE_DURATION = 300;
    const TIMING_FLASH_ANIMATION = 500;
    const TIMING_SYSTEM_MAP_LOAD_DELAY = 3500;

    // ==================== HELPER FUNCTIONS ====================

    /**
     * Builds HTML content for system info panel
     * @param {Object} systemData - System data object
     * @returns {string} HTML string for panel content
     */
    function buildSystemInfoHTML(systemData) {
        let contentHTML = '';

        const fields = [
            { key: 'type', label: 'TYPE', transform: val => val.toUpperCase() },
            { key: 'description', label: 'DESCRIPTION' },
            { key: 'population', label: 'POPULATION' },
            { key: 'position', label: 'COORDINATES', transform: val => val.join(', ') }
        ];

        fields.forEach(field => {
            if (systemData[field.key]) {
                const value = field.transform
                    ? field.transform(systemData[field.key])
                    : systemData[field.key];
                contentHTML += `<p><span class="info-label">${field.label}:</span> <span class="info-value">${value}</span></p>`;
            }
        });

        return contentHTML;
    }

    /**
     * Builds HTML content for planet info panel
     * @param {Object} planetData - Planet data object from system_map.yaml
     * @returns {string} HTML string for panel content
     */
    function buildPlanetInfoHTML(planetData) {
        let contentHTML = '';

        const fields = [
            { key: 'type', label: 'TYPE', transform: val => val.toUpperCase().replace('_', ' ') },
            { key: 'description', label: 'DESCRIPTION', nested: 'info' },
            { key: 'population', label: 'POPULATION', nested: 'info' },
            { key: 'habitability', label: 'HABITABILITY', nested: 'info' },
            { key: 'industry', label: 'INDUSTRY', nested: 'info' },
            { key: 'orbital_radius', label: 'ORBITAL RADIUS', transform: val => `${val} AU` },
            { key: 'orbital_period', label: 'ORBITAL PERIOD', transform: val => `${val} days` },
            { key: 'inclination', label: 'INCLINATION', transform: val => `${val}°` },
            { key: 'tidally_locked', label: 'ROTATION', transform: val => val ? 'TIDALLY LOCKED' : 'NORMAL' }
        ];

        fields.forEach(field => {
            let value;
            if (field.nested === 'info' && planetData.info) {
                value = planetData.info[field.key];
            } else {
                value = planetData[field.key];
            }

            if (value !== undefined && value !== null) {
                const displayValue = field.transform ? field.transform(value) : value;
                contentHTML += `<p><span class="info-label">${field.label}:</span> <span class="info-value">${displayValue}</span></p>`;
            }
        });

        return contentHTML;
    }

    /**
     * Show or hide system info panel decorations
     * @param {boolean} visible - Whether to show or hide decorations
     */
    function toggleSystemInfoDecorations(visible) {
        const elements = [
            '.system-info-indicator-boxes',
            '.system-info-rectangle',
            '.system-info-triangle'
        ];

        elements.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                element.classList.toggle('visible', visible);
            }
        });

        if (visible) {
            setTimeout(() => {
                window.updateIndicatorBoxesPosition();
            }, TIMING_RENDER_DELAY);
        }
    }

    /**
     * Set checkbox ARIA state
     * @param {HTMLElement} checkbox - Checkbox element with role="checkbox"
     * @param {boolean} isChecked - Whether checkbox should be checked
     */
    function setCheckboxState(checkbox, isChecked) {
        if (checkbox) {
            checkbox.setAttribute('aria-checked', isChecked ? 'true' : 'false');
        }
    }

    /**
     * Get what the panel SHOULD be displaying based on current state
     * Returns { title: string, contentHTML: string } or null if panel should be hidden
     */
    function getExpectedPanelContent() {
        if (window.systemMapState.selectedPlanet) {
            // Panel should show selected planet
            return {
                title: window.systemMapState.selectedPlanet.name.toUpperCase(),
                contentHTML: buildPlanetInfoHTML(window.systemMapState.selectedPlanet),
                type: 'planet'
            };
        } else if (window.systemMapState.currentSystem) {
            // Panel should show system info
            const systemData = window.systemMapState.currentSystem;
            const selectedSystem = localStorage.getItem('selected_star_system');
            let systemInfo = null;

            if (selectedSystem && window.starSystemsData && window.starSystemsData[selectedSystem]) {
                systemInfo = window.starSystemsData[selectedSystem];
            } else {
                systemInfo = {
                    name: systemData.star.name,
                    type: systemData.star.type,
                    description: `${systemData.star.type} star system`,
                    position: [0, 0, 0],
                    location_slug: systemData.system_slug
                };
            }

            return {
                title: systemInfo.name.toUpperCase(),
                contentHTML: buildSystemInfoHTML(systemInfo),
                type: 'system'
            };
        }

        return null;
    }

    /**
     * Validate that panel is showing correct content and force-correct if not
     * Called after typewriter animations complete to prevent stale content
     * @param {boolean} forceCorrect - If true, always correct regardless of title match
     */
    function validateAndCorrectPanel(forceCorrect = false) {
        const infoPanelName = document.getElementById('system-info-name');
        const infoPanelContent = document.getElementById('system-info-content');

        if (!infoPanelName || !infoPanelContent) return;

        const expected = getExpectedPanelContent();
        if (!expected) return;

        const currentTitle = infoPanelName.textContent;

        // Check if title matches expected or if force-correct is requested
        if (forceCorrect || currentTitle !== expected.title) {
            if (forceCorrect) {
                console.log(`Force-correcting panel after superseded operation to show ${expected.type}: ${expected.title}`);
            } else {
                console.log(`Panel mismatch detected! Expected "${expected.title}" but found "${currentTitle}". Force-correcting...`);
            }

            // Force-correct immediately without animation
            infoPanelName.textContent = expected.title;
            infoPanelContent.innerHTML = expected.contentHTML;

            console.log(`Panel corrected to show ${expected.type}: ${expected.title}`);
        }
    }

    // Expose validation function globally for debugging
    window.validateAndCorrectPanel = validateAndCorrectPanel;

    /**
     * Select a planet and display its details in the info panel
     * @param {Object} planetData - Planet data from system_map.yaml
     */
    async function selectPlanet(planetData) {
        const infoPanel = document.getElementById('system-info-panel');
        const infoPanelName = document.getElementById('system-info-name');
        const infoPanelContent = document.getElementById('system-info-content');

        if (!infoPanel || !infoPanelName || !infoPanelContent) {
            console.error('System info panel elements not found');
            return;
        }

        // Track this operation with a sequence number to prevent race conditions
        if (!window.systemMapState.infoPanelUpdateSequence) {
            window.systemMapState.infoPanelUpdateSequence = 0;
        }
        window.systemMapState.infoPanelUpdateSequence++;
        const thisSequence = window.systemMapState.infoPanelUpdateSequence;

        // Check if there's a previously selected planet (for smooth transition)
        const previouslySelectedPlanet = window.systemMapState.selectedPlanet;

        // Clear camera offset immediately to stop tracking during the transition
        window.systemMapState.cameraOffset = null;
        window.systemMapState.lastPlanetAngle = 0;

        // Kill any ongoing GSAP animations to prevent conflicts
        if (typeof gsap !== 'undefined') {
            gsap.killTweensOf(window.systemMapState.camera?.position);
            // Also kill any progress animations
            if (window.systemMapState._currentAnimState) {
                gsap.killTweensOf(window.systemMapState._currentAnimState);
            }
        }

        // Store selected planet
        window.systemMapState.selectedPlanet = planetData;

        // Find the planet mesh
        const selectedPlanetMesh = window.systemMapState.planets.find(
            p => p.name === planetData.name
        );

        if (!selectedPlanetMesh || !selectedPlanetMesh.mesh || !window.systemMapState.camera) {
            console.error('Planet mesh or camera not found');
            return;
        }

        const camera = window.systemMapState.camera;

        // Calculate zoom distance (same as zoomToPlanet)
        const zoomDistance = selectedPlanetMesh.orbitalRadius * PLANET_ZOOM_DISTANCE_RATIO;
        const actualZoomDistance = Math.max(zoomDistance, MIN_PLANET_ZOOM_DISTANCE);

        // Store the desired offset from the planet (constant throughout animation)
        const desiredOffset = new THREE.Vector3(
            actualZoomDistance * CAMERA_ANGLE_45_DEG,
            actualZoomDistance * CAMERA_ANGLE_45_DEG,
            actualZoomDistance * CAMERA_ANGLE_45_DEG
        );

        // Animate camera to planet
        if (typeof gsap !== 'undefined') {
            // Store starting position
            const startPos = camera.position.clone();

            // Store where camera is currently looking
            const startLookAt = new THREE.Vector3();
            if (previouslySelectedPlanet) {
                // Switching from another planet - use that planet's current position
                const previousPlanetMesh = window.systemMapState.planets.find(
                    p => p.name === previouslySelectedPlanet.name
                );
                if (previousPlanetMesh && previousPlanetMesh.mesh) {
                    previousPlanetMesh.mesh.getWorldPosition(startLookAt);
                } else {
                    // Fallback to sun if previous planet mesh not found
                    startLookAt.set(0, 0, 0);
                }
            } else if (window.systemMapState.currentSystem && window.systemMapState.currentSystem.camera) {
                // No previous planet - use system's default lookAt (probably the sun at 0, 0, 0)
                const systemLookAt = window.systemMapState.currentSystem.camera.lookAt;
                startLookAt.set(systemLookAt[0], systemLookAt[1], systemLookAt[2]);
            } else {
                // Fallback: calculate current lookAt from camera direction
                const lookAtTarget = new THREE.Vector3(0, 0, -1);
                lookAtTarget.applyQuaternion(camera.quaternion);
                startLookAt.copy(camera.position).add(lookAtTarget.multiplyScalar(10));
            }

            // Animate a progress value from 0 to 1
            const animState = { progress: 0 };
            window.systemMapState._currentAnimState = animState;

            gsap.to(animState, {
                progress: 1,
                duration: CAMERA_ANIMATION_DURATION,
                ease: CAMERA_ANIMATION_EASE,
                onUpdate: function() {
                    // Get planet's current position (it's orbiting during animation)
                    const currentPlanetPos = new THREE.Vector3();
                    selectedPlanetMesh.mesh.getWorldPosition(currentPlanetPos);

                    // Calculate target position based on planet's current position
                    const targetPos = currentPlanetPos.clone().add(desiredOffset);

                    // Interpolate camera position from start to current target
                    camera.position.lerpVectors(startPos, targetPos, animState.progress);

                    // Interpolate lookAt from starting point (sun) to planet
                    const currentLookAt = new THREE.Vector3();
                    currentLookAt.lerpVectors(startLookAt, currentPlanetPos, animState.progress);
                    camera.lookAt(currentLookAt.x, currentLookAt.y, currentLookAt.z);

                    // Update reticle position to follow the orbiting planet during animation
                    if (window.systemMapState.selectionReticle) {
                        window.systemMapState.selectionReticle.position.copy(currentPlanetPos);
                    }
                },
                onComplete: function() {
                    // After animation completes, store camera offset for tracking
                    const finalPlanetPos = new THREE.Vector3();
                    selectedPlanetMesh.mesh.getWorldPosition(finalPlanetPos);

                    window.systemMapState.cameraOffset = {
                        x: camera.position.x - finalPlanetPos.x,
                        y: camera.position.y - finalPlanetPos.y,
                        z: camera.position.z - finalPlanetPos.z
                    };

                    // Store the planet's current orbital angle (around Y axis)
                    window.systemMapState.lastPlanetAngle = Math.atan2(finalPlanetPos.z, finalPlanetPos.x);

                    console.log(`Camera locked to planet - offset: (${window.systemMapState.cameraOffset.x.toFixed(2)}, ${window.systemMapState.cameraOffset.y.toFixed(2)}, ${window.systemMapState.cameraOffset.z.toFixed(2)}), angle: ${window.systemMapState.lastPlanetAngle.toFixed(2)}`);
                }
            });
        } else {
            // Fallback to instant positioning if GSAP not available
            const planetPos = new THREE.Vector3();
            selectedPlanetMesh.mesh.getWorldPosition(planetPos);

            const targetCameraPos = planetPos.clone().add(desiredOffset);
            camera.position.copy(targetCameraPos);
            camera.lookAt(planetPos.x, planetPos.y, planetPos.z);

            // Store camera offset immediately
            window.systemMapState.cameraOffset = {
                x: camera.position.x - planetPos.x,
                y: camera.position.y - planetPos.y,
                z: camera.position.z - planetPos.z
            };

            window.systemMapState.lastPlanetAngle = Math.atan2(planetPos.z, planetPos.x);
        }

        // Show selection reticle on selected planet with size-based scaling
        if (window.systemMapState.selectionReticle) {
            // Scale reticle based on planet size (multiply by 6 for good spacing around planet)
            const reticleScale = (planetData.size || 1.0) * 6.0;
            window.systemMapState.selectionReticle.scale.set(reticleScale, reticleScale, 1);
            window.systemMapState.selectionReticle.visible = true;
        }

        // Fade out old content first (same pattern as galaxy map)
        infoPanelContent.style.opacity = '0';
        infoPanelContent.style.transition = 'opacity 300ms ease';

        // Wait for fade out
        await new Promise(resolve => setTimeout(resolve, 300));

        // Check if this operation is still current (prevent race condition)
        if (window.systemMapState.infoPanelUpdateSequence !== thisSequence) {
            console.log('Planet selection superseded, skipping panel update');
            return;
        }

        // Update panel title AND content together without await
        infoPanelName.textContent = planetData.name.toUpperCase();
        infoPanelContent.style.opacity = '1';
        const contentHTML = buildPlanetInfoHTML(planetData);

        // Make panel visible
        infoPanel.classList.add('visible');

        // Start typewriter but don't await it - let it run in background
        window.typewriteContent(infoPanelContent, contentHTML).then(() => {
            // After typewriter completes, verify this operation is still current
            if (window.systemMapState.infoPanelUpdateSequence !== thisSequence) {
                console.log('Planet selection was superseded during typewriter - force-correcting panel');
                // This typewriter was superseded, force-correct the panel immediately
                validateAndCorrectPanel(true);
            } else {
                console.log('Selected planet:', planetData.name);
            }
        });
    }

    /**
     * Unselect current planet and restore system details
     */
    async function unselectPlanet() {
        const systemData = window.systemMapState.currentSystem;
        if (!systemData) return;

        const camera = window.systemMapState.camera;
        if (!camera) return;

        // Track this operation with a sequence number to prevent race conditions
        if (!window.systemMapState.infoPanelUpdateSequence) {
            window.systemMapState.infoPanelUpdateSequence = 0;
        }
        window.systemMapState.infoPanelUpdateSequence++;
        const thisSequence = window.systemMapState.infoPanelUpdateSequence;

        const infoPanelContent = document.getElementById('system-info-content');

        // Get the planet's current position (what we're currently looking at)
        let selectedPlanetData = null;
        if (window.systemMapState.selectedPlanet) {
            selectedPlanetData = window.systemMapState.planets.find(
                p => p.name === window.systemMapState.selectedPlanet.name
            );
        }

        const startLookAt = new THREE.Vector3();
        if (selectedPlanetData && selectedPlanetData.mesh) {
            selectedPlanetData.mesh.getWorldPosition(startLookAt);
        } else {
            // Fallback: use camera's current target (or sun position if no planet selected)
            const lookAtTarget = new THREE.Vector3(0, 0, -1);
            lookAtTarget.applyQuaternion(camera.quaternion);
            startLookAt.copy(camera.position).add(lookAtTarget);
        }

        // Clear camera offset BEFORE animation to stop tracking immediately
        window.systemMapState.cameraOffset = null;
        window.systemMapState.lastPlanetAngle = 0;

        // Kill any ongoing GSAP animations to prevent conflicts
        if (typeof gsap !== 'undefined') {
            gsap.killTweensOf(camera.position);
            if (window.systemMapState._currentAnimState) {
                gsap.killTweensOf(window.systemMapState._currentAnimState);
            }
        }

        // Hide selection reticle immediately
        if (window.systemMapState.selectionReticle) {
            window.systemMapState.selectionReticle.visible = false;
        }

        // Get default camera position from system data
        if (!systemData.camera || !systemData.camera.position || !systemData.camera.lookAt) {
            console.error('System camera configuration missing');
            return;
        }

        const targetPos = systemData.camera.position;
        const targetLookAt = new THREE.Vector3(
            systemData.camera.lookAt[0],
            systemData.camera.lookAt[1],
            systemData.camera.lookAt[2]
        );

        // Animate camera back to system view
        if (typeof gsap !== 'undefined') {
            // Store starting camera position
            const startPos = camera.position.clone();

            // Animate a progress value from 0 to 1
            const animState = { progress: 0 };
            window.systemMapState._currentAnimState = animState;

            gsap.to(animState, {
                progress: 1,
                duration: CAMERA_ANIMATION_DURATION,
                ease: CAMERA_ANIMATION_EASE,
                onUpdate: function() {
                    // Interpolate camera position from current to target
                    const targetPosition = new THREE.Vector3(targetPos[0], targetPos[1], targetPos[2]);
                    camera.position.lerpVectors(startPos, targetPosition, animState.progress);

                    // Interpolate lookAt target from planet to sun
                    const currentLookAt = new THREE.Vector3();
                    currentLookAt.lerpVectors(startLookAt, targetLookAt, animState.progress);
                    camera.lookAt(currentLookAt.x, currentLookAt.y, currentLookAt.z);
                },
                onComplete: function() {
                    // After animation completes, ensure exact final position
                    camera.position.set(targetPos[0], targetPos[1], targetPos[2]);
                    camera.lookAt(targetLookAt.x, targetLookAt.y, targetLookAt.z);

                    // Clear planet selection
                    window.systemMapState.selectedPlanet = null;

                    console.log('Camera returned to system view');
                }
            });
        } else {
            // Fallback to instant positioning
            camera.position.set(targetPos[0], targetPos[1], targetPos[2]);
            camera.lookAt(targetLookAt.x, targetLookAt.y, targetLookAt.z);

            // Clear planet selection immediately
            window.systemMapState.selectedPlanet = null;
        }

        // Restore system info to panel
        const infoPanelName = document.getElementById('system-info-name');
        // infoPanelContent already declared above for typewriter cancellation

        if (infoPanelName && infoPanelContent) {
            // Check if this operation is still current (prevent race condition)
            if (window.systemMapState.infoPanelUpdateSequence !== thisSequence) {
                console.log('Planet unselection superseded, skipping panel update');
                return;
            }

            // Get the selected system data from galaxy map
            const selectedSystem = localStorage.getItem('selected_star_system');
            let systemInfo = null;

            // Try to get the full galaxy system data
            if (selectedSystem && window.starSystemsData && window.starSystemsData[selectedSystem]) {
                systemInfo = window.starSystemsData[selectedSystem];
                infoPanelName.textContent = systemInfo.name.toUpperCase();
            } else {
                // Fallback: use star name from system map data
                infoPanelName.textContent = systemData.star.name.toUpperCase();
                systemInfo = {
                    type: systemData.star.type,
                    description: `${systemData.star.type} star system`,
                    position: [0, 0, 0],
                    location_slug: systemData.system_slug
                };
            }

            // Update panel content with typewriter animation (don't await - let it run in background)
            const contentHTML = buildSystemInfoHTML(systemInfo);
            window.typewriteContent(infoPanelContent, contentHTML).then(() => {
                // After typewriter completes, verify this operation is still current
                if (window.systemMapState.infoPanelUpdateSequence !== thisSequence) {
                    console.log('Planet unselection was superseded during typewriter - force-correcting panel');
                    // This typewriter was superseded, force-correct the panel immediately
                    validateAndCorrectPanel(true);
                } else {
                    console.log('Unselected planet, restored system info');
                }
            });
        }
    }

    /**
     * Handle click events on the system map canvas for planet selection
     * @param {MouseEvent} event - Click event
     */
    function handlePlanetClick(event) {
        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas || canvas.style.display !== 'block') return;

        // Don't handle clicks on UI elements
        const target = event.target;
        if (target !== canvas) return;

        const raycaster = window.systemMapState.raycaster;
        const camera = window.systemMapState.camera;
        const mouse = window.systemMapState.mouse;

        if (!raycaster || !camera) return;

        // Calculate mouse position in normalized device coordinates (-1 to +1)
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update raycaster
        raycaster.setFromCamera(mouse, camera);

        // Get all clickable planet meshes
        const clickablePlanets = window.systemMapState.planets
            .filter(p => p.clickable)
            .map(p => p.mesh);

        // Check for intersections
        const intersects = raycaster.intersectObjects(clickablePlanets);

        if (intersects.length > 0) {
            // Find the planet data for the clicked mesh
            const clickedMesh = intersects[0].object;
            const planetData = window.systemMapState.planets.find(p => p.mesh === clickedMesh);

            if (planetData) {
                // Get full planet data from currentSystem
                const fullPlanetData = window.systemMapState.currentSystem.bodies.find(
                    b => b.name === planetData.name
                );

                if (fullPlanetData) {
                    // Toggle selection: if already selected, unselect it
                    if (window.systemMapState.selectedPlanet &&
                        window.systemMapState.selectedPlanet.name === fullPlanetData.name) {
                        unselectPlanet();
                    } else {
                        selectPlanet(fullPlanetData);
                    }
                }
            }
        } else {
            // Clicked on empty space - unselect if a planet is selected
            if (window.systemMapState.selectedPlanet) {
                unselectPlanet();
            }
        }
    }

    // Global variables for planet list feature
    let originalGalaxyHTML = null;
    let currentView = 'galaxy';  // 'galaxy' or 'planets'

    // Show planet list when system map is displayed
    async function showPlanetList(systemData) {
        const starMapPanel = document.getElementById('star-map-panel');
        if (!starMapPanel) {
            console.error('Star map panel element not found');
            return;
        }

        if (!systemData || !systemData.star) {
            console.error('Invalid system data provided to showPlanetList');
            return;
        }

        // Store original HTML ONLY on first transition (fixes M3)
        if (!originalGalaxyHTML) {
            originalGalaxyHTML = starMapPanel.innerHTML;
            console.log('Stored original galaxy HTML');
        }

        // Clean up galaxy event listeners before showing planet list
        if (starMapPanel._galaxyHandler) {
            starMapPanel.removeEventListener('click', starMapPanel._galaxyHandler);
            starMapPanel._galaxyHandler = null;
        }
        if (starMapPanel._galaxyKeyHandler) {
            starMapPanel.removeEventListener('keydown', starMapPanel._galaxyKeyHandler);
            starMapPanel._galaxyKeyHandler = null;
        }

        // Build planet list HTML
        let planetsHTML = '';

        // Add back button at top with accessibility attributes (fixes m4)
        planetsHTML += `
            <div class="star-system-row back-to-galaxy-btn"
                 role="button"
                 tabindex="0"
                 aria-label="Return to galaxy view"
                 data-action="back-to-galaxy"
                 style="margin-bottom: 12px; border-color: var(--color-amber);">
                <div class="star-system-content">
                    <div class="star-system-checkbox" style="display: flex; align-items: center; justify-content: center; color: var(--color-amber); font-size: 14px; background: none; border: none; margin-left: 2px;">◀</div>
                    <div class="star-system-name" style="color: var(--color-amber);">BACK TO GALAXY</div>
                </div>
            </div>
        `;

        // Add planets/bodies
        if (systemData.bodies && systemData.bodies.length > 0) {
            systemData.bodies.forEach(body => {
                const bodyName = body.name || 'Unknown';

                // Build facility indicators
                let indicatorsHTML = '';
                if (body.surface_facility_count > 0 || body.orbital_station_count > 0) {
                    indicatorsHTML = '<div class="facility-indicators">';
                    if (body.surface_facility_count > 0) {
                        indicatorsHTML += '<div class="facility-indicator facility-square" title="Surface facilities"></div>';
                    }
                    if (body.orbital_station_count > 0) {
                        indicatorsHTML += '<div class="facility-indicator facility-triangle" title="Orbital stations"></div>';
                    }
                    indicatorsHTML += '</div>';
                }

                // Build orbit map arrow button
                const bodySlug = body.location_slug || bodyName.toLowerCase().replace(/\s+/g, '-');
                let orbitMapArrowHTML = '';
                if (body.has_orbit_map) {
                    orbitMapArrowHTML = `
                        <div class="orbit-map-btn-container"
                             data-action="view-orbit-map"
                             data-planet-slug="${bodySlug}"
                             title="View orbit map">
                            <span class="orbit-map-btn-icon">▶</span>
                        </div>
                    `;
                }

                planetsHTML += `
                    <div class="star-system-row planet-row"
                         role="button"
                         tabindex="0"
                         aria-label="Select ${bodyName}"
                         data-planet="${bodyName}"
                         data-planet-slug="${bodySlug}"
                         data-action="select-planet">
                        <div class="star-system-content">
                            <div class="star-system-checkbox" role="checkbox" aria-checked="false"></div>
                            <div class="star-system-name">${bodyName}</div>
                            ${indicatorsHTML}
                        </div>
                        ${orbitMapArrowHTML}
                    </div>
                `;
            });
        } else {
            planetsHTML += '<p>&gt; No planetary bodies in system</p>';
        }

        // Replace content
        starMapPanel.innerHTML = planetsHTML;
        currentView = 'planets';

        // Don't update info panel - it should keep showing system info from galaxy map selection

        // Use event delegation for all clicks (fixes C1 - memory leaks)
        setupPlanetListEventDelegation();

        console.log(`Planet list shown with ${systemData.bodies ? systemData.bodies.length : 0} bodies`);
    }

    // Event delegation for planet list (fixes C1 - prevents memory leaks)
    function setupPlanetListEventDelegation() {
        const starMapPanel = document.getElementById('star-map-panel');
        if (!starMapPanel) return;

        // Remove old listeners if they exist (prevent memory leaks)
        if (starMapPanel._planetListHandler) {
            starMapPanel.removeEventListener('click', starMapPanel._planetListHandler);
            starMapPanel._planetListHandler = null;
        }
        if (starMapPanel._planetListKeyHandler) {
            starMapPanel.removeEventListener('keydown', starMapPanel._planetListKeyHandler);
            starMapPanel._planetListKeyHandler = null;
        }

        // Create new delegated click handler
        const clickHandler = function(event) {
            const target = event.target.closest('[data-action]');
            if (!target) return;

            const action = target.dataset.action;

            if (action === 'back-to-galaxy') {
                hideSystemMap();
            } else if (action === 'view-orbit-map') {
                event.stopPropagation(); // Prevent planet selection
                const planetSlug = target.dataset.planetSlug;
                const systemSlug = window.systemMapState.currentSystemSlug;

                // Transition to orbit map with zoom animation
                transitionToOrbitMap(systemSlug, planetSlug);
            } else if (action === 'select-planet') {
                const planetName = target.dataset.planet;
                const isCurrentlyChecked = target.classList.contains('checked');

                if (isCurrentlyChecked) {
                    // Deselect - recenter on star and restore system info
                    target.classList.remove('checked');
                    const checkbox = target.querySelector('[role="checkbox"]');
                    setCheckboxState(checkbox, false);
                    recenterOnStar();
                    unselectPlanet();  // Restore system info panel
                } else {
                    // Deselect all other planets
                    const allPlanetRows = starMapPanel.querySelectorAll('.planet-row');
                    allPlanetRows.forEach(row => {
                        row.classList.remove('checked');
                        const cb = row.querySelector('[role="checkbox"]');
                        setCheckboxState(cb, false);
                    });

                    // Select this planet
                    target.classList.add('checked');
                    const checkbox = target.querySelector('[role="checkbox"]');
                    setCheckboxState(checkbox, true);

                    // Zoom to planet
                    zoomToPlanet(planetName);

                    // Update info panel with planet details
                    const systemData = window.systemMapState.currentSystem;
                    if (systemData && systemData.bodies) {
                        const planetData = systemData.bodies.find(b => b.name === planetName);
                        if (planetData) {
                            selectPlanet(planetData);
                        }
                    }
                }
            }
        };

        // Store reference for cleanup
        starMapPanel._planetListHandler = clickHandler;

        // Attach delegated listener to panel
        starMapPanel.addEventListener('click', clickHandler);

        // Keyboard support (fixes m4)
        const keyHandler = function(event) {
            if (event.key === 'Enter' || event.key === ' ') {
                const target = event.target.closest('[data-action]');
                if (target) {
                    event.preventDefault();
                    target.click();
                }
            }
        };

        starMapPanel._planetListKeyHandler = keyHandler;
        starMapPanel.addEventListener('keydown', keyHandler);
    }

    // Restore galaxy list
    function showGalaxyList() {
        const starMapPanel = document.getElementById('star-map-panel');
        if (!starMapPanel) {
            console.error('Star map panel element not found');
            return;
        }

        if (!originalGalaxyHTML) {
            console.warn('No original galaxy HTML to restore');
            return;
        }

        // Clean up planet list event listeners (fixes C1)
        if (starMapPanel._planetListHandler) {
            starMapPanel.removeEventListener('click', starMapPanel._planetListHandler);
            starMapPanel._planetListHandler = null;
        }
        if (starMapPanel._planetListKeyHandler) {
            starMapPanel.removeEventListener('keydown', starMapPanel._planetListKeyHandler);
            starMapPanel._planetListKeyHandler = null;
        }

        // Restore original HTML
        starMapPanel.innerHTML = originalGalaxyHTML;
        currentView = 'galaxy';

        // Re-attach event listeners for star systems using reusable function (fixes M1)
        initializeGalaxyEventListeners();

        // Restore selected system state from localStorage
        const selectedSystem = localStorage.getItem('selected_star_system');
        console.log('Restoring galaxy view, selected system:', selectedSystem);

        if (selectedSystem) {
            const starSystemRows = document.querySelectorAll('.star-system-row');
            console.log('Found star system rows:', starSystemRows.length);

            // Find and check the stored system
            starSystemRows.forEach(row => {
                if (row.dataset.system === selectedSystem) {
                    row.classList.add('checked');
                    console.log('Marked row as checked for:', selectedSystem);
                } else {
                    row.classList.remove('checked');
                }
            });

            // Restore info panel and camera position for selected system
            if (window.starSystemsData && window.starSystemsData[selectedSystem]) {
                const systemData = window.starSystemsData[selectedSystem];
                const infoPanel = document.getElementById('system-info-panel');
                const infoPanelName = document.getElementById('system-info-name');
                const infoPanelContent = document.getElementById('system-info-content');

                if (infoPanel && infoPanelName && infoPanelContent) {
                    // Build info content HTML using helper function
                    const contentHTML = buildSystemInfoHTML(systemData);

                    // Update panel instantly (no typewriter effect for restoration)
                    infoPanelName.textContent = systemData.name.toUpperCase();
                    infoPanelContent.innerHTML = contentHTML;
                    infoPanel.classList.add('visible');

                    // Show decorations using helper function
                    toggleSystemInfoDecorations(true);
                }
            }

            // Restore camera position and enable auto-rotation
            // Use longer delay to ensure galaxy map canvas is fully rendered after being shown
            setTimeout(() => {
                console.log('Attempting to restore camera position for:', selectedSystem);
                console.log('starMapState exists:', !!window.starMapState);
                console.log('starPositions exists:', !!window.starMapState?.starPositions);
                console.log('animateCameraToTarget exists:', !!window.starMapState?.animateCameraToTarget);

                if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                    const position = window.starMapState.starPositions.get(selectedSystem);
                    console.log('Position for', selectedSystem, ':', position);

                    if (position) {
                        // Show and position selection reticle
                        if (window.starMapState.selectionReticle) {
                            window.starMapState.selectionReticle.position.copy(position);
                            window.starMapState.selectionReticle.visible = true;
                            console.log('Selection reticle positioned and made visible');
                        }

                        // Enable auto-rotation around the selected star
                        window.starMapState.autoRotate = true;
                        console.log('Auto-rotation enabled');

                        // Animate camera back to selected system
                        window.starMapState.animateCameraToTarget(position, 1500);
                        console.log(`Animating camera to ${selectedSystem} at position`, position);
                    } else {
                        console.error(`Could not restore camera position for ${selectedSystem} - position not found in starPositions map`);
                        console.log('Available systems in starPositions:', Array.from(window.starMapState.starPositions.keys()));
                    }
                } else {
                    console.error('Could not restore camera position - starMapState not fully initialized');
                }
            }, TIMING_FADE_DURATION);  // 300ms delay to ensure galaxy canvas is fully visible and rendered
        }

        console.log('Galaxy list restored');
    }

    // Reusable function to initialize galaxy event listeners (fixes M1 - eliminates code duplication)
    // This function is shared by both page load initialization and galaxy list restoration
    // Uses event delegation pattern to prevent memory leaks (fixes C1)
    function initializeGalaxyEventListeners() {
        const starMapPanel = document.getElementById('star-map-panel');
        if (!starMapPanel) {
            console.error('Star map panel element not found');
            return;
        }

        // Remove old listeners if they exist (prevent memory leaks)
        if (starMapPanel._galaxyHandler) {
            starMapPanel.removeEventListener('click', starMapPanel._galaxyHandler);
            starMapPanel._galaxyHandler = null;
        }
        if (starMapPanel._galaxyKeyHandler) {
            starMapPanel.removeEventListener('keydown', starMapPanel._galaxyKeyHandler);
            starMapPanel._galaxyKeyHandler = null;
        }

        // Create delegated click handler for all galaxy interactions
        const clickHandler = function(event) {
            // Check if clicked on system map button first
            const systemMapBtn = event.target.closest('.system-map-btn-container');
            if (systemMapBtn) {
                event.stopPropagation(); // Prevent row click event

                // Flash animation
                systemMapBtn.classList.add('flashing');
                setTimeout(() => {
                    systemMapBtn.classList.remove('flashing');
                }, TIMING_FLASH_ANIMATION);

                // Get system name from parent row
                const row = systemMapBtn.closest('.star-system-row');
                if (!row) return;

                const systemName = row.dataset.system;
                console.log(`System map button clicked for: ${systemName}`);

                // Check if system is already selected
                const isSelected = row.classList.contains('checked');

                // Get location slug from starSystemsData
                if (window.starSystemsData && window.starSystemsData[systemName]) {
                    const locationSlug = window.starSystemsData[systemName].location_slug;
                    if (locationSlug) {
                        if (!isSelected) {
                            // System not selected - select it first, then load map after animation
                            console.log(`Selecting ${systemName} before loading system map`);

                            // Trigger selection by clicking the content area
                            const contentArea = row.querySelector('.star-system-content');
                            if (contentArea) {
                                contentArea.click();
                            }

                            // Wait for all animations to complete before loading system map:
                            // - Camera pan/zoom animation: 2000ms
                            // - Info panel typewriter effect: ~800ms
                            // - Panel fade-in transitions: ~300ms
                            // Total: 3500ms to ensure smooth completion
                            setTimeout(() => {
                                loadSystemMap(locationSlug);
                            }, TIMING_SYSTEM_MAP_LOAD_DELAY);
                        } else {
                            // System already selected - load map immediately
                            loadSystemMap(locationSlug);
                        }
                    } else {
                        console.error(`No location_slug found for system: ${systemName}`);
                    }
                } else {
                    console.error(`System data not found for: ${systemName}`);
                }
                return;
            }

            // Check if clicked on system content area (for selection)
            const contentArea = event.target.closest('.star-system-content');
            if (contentArea) {
                const row = contentArea.closest('.star-system-row');
                if (!row) return;

                // Get the system name from the parent row
                const systemName = row.dataset.system;

                // Check if this row is already checked
                const isCurrentlyChecked = row.classList.contains('checked');

                if (isCurrentlyChecked) {
                    // Uncheck this row
                    row.classList.remove('checked');
                    localStorage.removeItem('selected_star_system');
                    console.log('No star system selected');

                    // Re-enable auto-rotation around center
                    if (window.starMapState) {
                        window.starMapState.autoRotate = true;
                    }

                    // Hide selection reticle
                    if (window.starMapState && window.starMapState.selectionReticle) {
                        window.starMapState.selectionReticle.visible = false;
                    }

                    // Hide system info panel and decorations using helper function
                    const infoPanel = document.getElementById('system-info-panel');
                    if (infoPanel) {
                        infoPanel.classList.remove('visible');
                    }
                    toggleSystemInfoDecorations(false);

                    // Animate camera back to origin (0, 0, 0)
                    if (window.starMapState && window.starMapState.animateCameraToTarget) {
                        window.starMapState.animateCameraToTarget(new THREE.Vector3(0, 0, 0));
                    }
                    return;
                } else {
                    // Uncheck all other systems using querySelectorAll
                    const allSystemRows = starMapPanel.querySelectorAll('.star-system-row');
                    allSystemRows.forEach(otherRow => {
                        otherRow.classList.remove('checked');
                    });

                    // Check this system
                    row.classList.add('checked');

                    // Store selected system in localStorage for persistence
                    localStorage.setItem('selected_star_system', systemName);

                    console.log(`Star system ${systemName} selected`);

                    // Get system data and populate info panel
                    if (window.starSystemsData && window.starSystemsData[systemName]) {
                        const systemData = window.starSystemsData[systemName];

                        const infoPanel = document.getElementById('system-info-panel');
                        const infoPanelName = document.getElementById('system-info-name');
                        const infoPanelContent = document.getElementById('system-info-content');

                        if (infoPanel && infoPanelName && infoPanelContent) {
                            // Check if panel is already visible
                            const wasVisible = infoPanel.classList.contains('visible');

                            // Build info content HTML using helper function
                            const contentHTML = buildSystemInfoHTML(systemData);

                            // Update content with typewriter effect
                            async function updatePanel() {
                                if (wasVisible) {
                                    // Fade out old content
                                    infoPanelContent.style.opacity = '0';
                                    infoPanelContent.style.transition = `opacity ${TIMING_FADE_DURATION}ms ease`;

                                    // Wait for fade out
                                    await new Promise(resolve => setTimeout(resolve, TIMING_FADE_DURATION));
                                } else {
                                    // Show panel and decorations using helper function
                                    infoPanel.classList.add('visible');
                                    toggleSystemInfoDecorations(true);
                                }

                                // Update header
                                infoPanelName.textContent = systemData.name.toUpperCase();

                                // Reset opacity and typewrite new content
                                infoPanelContent.style.opacity = '1';
                                await window.typewriteContent(infoPanelContent, contentHTML);

                                // Update indicator boxes position after content is loaded (in case height changed)
                                if (wasVisible) {
                                    setTimeout(() => {
                                        window.updateIndicatorBoxesPosition();
                                    }, TIMING_RENDER_DELAY);
                                }
                            }

                            updatePanel();
                        }
                    }

                    // Animate camera to selected star system
                    if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                        const position = window.starMapState.starPositions.get(systemName);
                        if (position) {
                            // Show and position selection reticle
                            if (window.starMapState.selectionReticle) {
                                window.starMapState.selectionReticle.position.copy(position);
                                window.starMapState.selectionReticle.visible = true;
                            }

                            // Enable auto-rotation around the selected star
                            window.starMapState.autoRotate = true;

                            // Animate camera
                            window.starMapState.animateCameraToTarget(position);
                            console.log(`Animating camera to ${systemName} at position:`, position);
                        } else {
                            console.warn(`Position not found for system: ${systemName}`);
                        }
                    }
                }
            }
        };

        // Store handler reference for cleanup
        starMapPanel._galaxyHandler = clickHandler;

        // Attach delegated listener to panel
        starMapPanel.addEventListener('click', clickHandler);

        // Keyboard support
        const keyHandler = function(event) {
            if (event.key === 'Enter' || event.key === ' ') {
                const target = event.target.closest('.star-system-content, .system-map-btn-container');
                if (target) {
                    event.preventDefault();
                    target.click();
                }
            }
        };

        starMapPanel._galaxyKeyHandler = keyHandler;
        starMapPanel.addEventListener('keydown', keyHandler);
    }

    // Make function globally accessible for other scripts
    window.initializeGalaxyEventListeners = initializeGalaxyEventListeners;

    // Zoom camera to selected planet (fixes C2 + m3)
    function zoomToPlanet(planetName) {
        // Validation (fixes M2)
        if (!window.systemMapState || !window.systemMapState.planets) {
            console.error('System map state not initialized');
            return;
        }

        if (!window.systemMapState.camera) {
            console.error('Camera not initialized');
            return;
        }

        // Find planet data
        const planetData = window.systemMapState.planets.find(p => p.name === planetName);
        if (!planetData) {
            console.warn(`Planet "${planetName}" not found in system map`);
            return;
        }

        if (!planetData.mesh) {
            console.warn(`Planet "${planetName}" mesh not yet rendered`);
            return;
        }

        const cam = window.systemMapState.camera;

        // Get actual planet position from Three.js mesh (fixes C2)
        const planetPos = new THREE.Vector3();
        planetData.mesh.getWorldPosition(planetPos);

        // Calculate zoom distance based on orbital radius (using constants - fixes m1)
        const zoomDistance = planetData.orbitalRadius * PLANET_ZOOM_DISTANCE_RATIO;
        const actualZoomDistance = Math.max(zoomDistance, MIN_PLANET_ZOOM_DISTANCE);

        // Calculate camera target position at 45-degree angle from planet's actual position
        const offset = new THREE.Vector3(
            actualZoomDistance * CAMERA_ANGLE_45_DEG,
            actualZoomDistance * CAMERA_ANGLE_45_DEG,
            actualZoomDistance * CAMERA_ANGLE_45_DEG
        );

        const targetCameraPos = planetPos.clone().add(offset);

        // Smooth camera animation (fixes m3)
        if (typeof gsap !== 'undefined') {
            gsap.to(cam.position, {
                x: targetCameraPos.x,
                y: targetCameraPos.y,
                z: targetCameraPos.z,
                duration: CAMERA_ANIMATION_DURATION,
                ease: CAMERA_ANIMATION_EASE,
                onUpdate: function() {
                    // Update lookAt during animation to track planet
                    const currentPlanetPos = new THREE.Vector3();
                    planetData.mesh.getWorldPosition(currentPlanetPos);
                    cam.lookAt(currentPlanetPos.x, currentPlanetPos.y, currentPlanetPos.z);
                }
            });
        } else {
            // Fallback to instant positioning if GSAP not available
            cam.position.copy(targetCameraPos);
            cam.lookAt(planetPos.x, planetPos.y, planetPos.z);
        }

        console.log(`Zoomed to planet: ${planetName} at position (${planetPos.x.toFixed(1)}, ${planetPos.y.toFixed(1)}, ${planetPos.z.toFixed(1)})`);
    }

    // Recenter camera on star (default view) - fixes M2 + m3
    function recenterOnStar() {
        // Validation (fixes M2)
        if (!window.systemMapState || !window.systemMapState.currentSystem) {
            console.error('System map state not initialized');
            return;
        }

        if (!window.systemMapState.camera) {
            console.error('Camera not initialized');
            return;
        }

        const data = window.systemMapState.currentSystem;
        const cam = window.systemMapState.camera;

        // Reset to default camera position from system data
        if (!data.camera || !data.camera.position || !data.camera.lookAt) {
            console.error('System camera configuration missing');
            return;
        }

        const targetPos = data.camera.position;
        const targetLookAt = data.camera.lookAt;

        // Smooth camera animation (fixes m3)
        if (typeof gsap !== 'undefined') {
            gsap.to(cam.position, {
                x: targetPos[0],
                y: targetPos[1],
                z: targetPos[2],
                duration: CAMERA_ANIMATION_DURATION,
                ease: CAMERA_ANIMATION_EASE,
                onUpdate: function() {
                    cam.lookAt(targetLookAt[0], targetLookAt[1], targetLookAt[2]);
                },
                onComplete: function() {
                    if (data.camera.fov) {
                        cam.fov = data.camera.fov;
                        cam.updateProjectionMatrix();
                    }
                }
            });
        } else {
            // Fallback to instant positioning
            cam.position.set(targetPos[0], targetPos[1], targetPos[2]);
            cam.lookAt(targetLookAt[0], targetLookAt[1], targetLookAt[2]);
            if (data.camera.fov) {
                cam.fov = data.camera.fov;
                cam.updateProjectionMatrix();
            }
        }

        console.log('Recentered on star');
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        if (window.systemMapState.camera && window.systemMapState.renderer) {
            window.systemMapState.camera.aspect = window.innerWidth / window.innerHeight;
            window.systemMapState.camera.updateProjectionMatrix();
            window.systemMapState.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });

    // Helper function to update camera offset when user moves camera while following planet
    function updateCameraOffsetIfFollowing() {
        if (window.systemMapState.selectedPlanet && window.systemMapState.camera) {
            const selectedPlanetMesh = window.systemMapState.planets.find(
                p => p.name === window.systemMapState.selectedPlanet.name
            );

            if (selectedPlanetMesh && selectedPlanetMesh.mesh) {
                const camera = window.systemMapState.camera;
                const planetPos = selectedPlanetMesh.mesh.position;

                // Update the offset to reflect new camera position
                window.systemMapState.cameraOffset = {
                    x: camera.position.x - planetPos.x,
                    y: camera.position.y - planetPos.y,
                    z: camera.position.z - planetPos.z
                };
            }
        }
    }

    // Add camera controls for system map
    function initSystemMapControls() {
        // System map camera controls constants
        const SYSTEM_MAP_MIN_ZOOM = 60;
        const SYSTEM_MAP_MAX_ZOOM = 300;
        const SYSTEM_MAP_ZOOM_SPEED = 0.05;  // Reduced from 0.1 (5% per scroll instead of 10%)
        const SYSTEM_MAP_ROTATE_SPEED = 0.003;  // Reduced from 0.005 for less aggressive rotation

        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas) {
            console.error('System map canvas not found!');
            return;
        }

        console.log('Attaching controls to systemmap-canvas, display:', canvas.style.display);

        let lookAtTarget = new THREE.Vector3(0, 0, 0);
        const minDistance = SYSTEM_MAP_MIN_ZOOM;
        const maxDistance = SYSTEM_MAP_MAX_ZOOM;
        const zoomSpeed = SYSTEM_MAP_ZOOM_SPEED;
        const rotateSpeed = SYSTEM_MAP_ROTATE_SPEED;

        // Mouse wheel zoom - attach to window so it works anywhere
        window.addEventListener('wheel', (event) => {
            // Only handle wheel events when system map is visible and active
            if (canvas.style.display !== 'block') return;
            if (!window.systemMapState || !window.systemMapState.isActive) return;  // Only handle if system map is active

            // Check if mouse is over a panel or scrollable content
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');

            // If over a panel, allow normal scrolling
            if (isPanel) {
                // Don't call preventDefault() - let the browser handle scrolling
                return;
            }

            // Otherwise, zoom the system map
            event.preventDefault();

            const camera = window.systemMapState.camera;
            if (!camera) return;

            // Update lookAtTarget and zoom limits based on what's selected
            let effectiveMinDistance = minDistance;
            let effectiveMaxDistance = maxDistance;

            if (window.systemMapState.selectedPlanet) {
                // If a planet is selected, zoom towards the planet with closer limits
                const selectedPlanetMesh = window.systemMapState.planets.find(
                    p => p.name === window.systemMapState.selectedPlanet.name
                );
                if (selectedPlanetMesh && selectedPlanetMesh.mesh) {
                    selectedPlanetMesh.mesh.getWorldPosition(lookAtTarget);
                    // Allow much closer zoom when viewing a planet
                    effectiveMinDistance = 5;   // Can zoom very close to planet
                    effectiveMaxDistance = 100; // Don't need to zoom as far out
                }
            } else {
                // Otherwise zoom towards the sun (origin) with system-wide limits
                lookAtTarget.set(0, 0, 0);
            }

            const delta = event.deltaY;
            const offset = camera.position.clone().sub(lookAtTarget);
            let distance = offset.length();

            if (delta > 0) {
                distance *= (1 + zoomSpeed);
            } else {
                distance *= (1 - zoomSpeed);
            }

            distance = Math.max(effectiveMinDistance, Math.min(effectiveMaxDistance, distance));
            offset.normalize().multiplyScalar(distance);
            camera.position.copy(lookAtTarget).add(offset);

            // Update camera offset if following a planet
            updateCameraOffsetIfFollowing();
        }, { passive: false });

        // Mouse drag rotation - attach to window
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };

        window.addEventListener('mousedown', (event) => {
            // Only handle when system map is visible and active
            if (canvas.style.display !== 'block') return;
            if (!window.systemMapState || !window.systemMapState.isActive) return;  // Only handle if system map is active

            // Don't start dragging if clicking on UI panels or interactive elements
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
            const isButton = target.closest('button, .system-map-btn-container, .show-btn-container');

            if (isPanel || isButton) {
                console.log('Click on UI element, not starting drag');
                return;
            }

            console.log('Starting drag rotation');
            isDragging = true;
            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging || canvas.style.display !== 'block') return;
            if (!window.systemMapState || !window.systemMapState.isActive) return;  // Only handle if system map is active

            const camera = window.systemMapState.camera;
            if (!camera) return;

            // Update lookAtTarget based on what's selected
            if (window.systemMapState.selectedPlanet) {
                // If a planet is selected, rotate around the planet
                const selectedPlanetMesh = window.systemMapState.planets.find(
                    p => p.name === window.systemMapState.selectedPlanet.name
                );
                if (selectedPlanetMesh && selectedPlanetMesh.mesh) {
                    selectedPlanetMesh.mesh.getWorldPosition(lookAtTarget);
                }
            } else {
                // Otherwise rotate around the sun (origin)
                lookAtTarget.set(0, 0, 0);
            }

            const deltaX = event.clientX - previousPosition.x;
            const deltaY = event.clientY - previousPosition.y;

            const offset = camera.position.clone().sub(lookAtTarget);
            const radius = offset.length();

            let theta = Math.atan2(offset.x, offset.z);
            let phi = Math.acos(offset.y / radius);

            theta -= deltaX * rotateSpeed;
            phi -= deltaY * rotateSpeed;

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            camera.position.copy(lookAtTarget).add(offset);
            camera.lookAt(lookAtTarget);

            // Update camera offset if following a planet
            updateCameraOffsetIfFollowing();

            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch controls - attach to window
        let isTouching = false;

        window.addEventListener('touchstart', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (event.touches.length === 1) {
                // Check if touching a panel or button
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                const isButton = target.closest('button, .system-map-btn-container, .show-btn-container');
                if (isPanel || isButton) return;

                isTouching = true;
                previousPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchmove', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (isTouching && event.touches.length === 1) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) {
                    isTouching = false;
                    return;
                }

                event.preventDefault();

                const camera = window.systemMapState.camera;
                if (!camera) return;

                // Update lookAtTarget based on what's selected
                if (window.systemMapState.selectedPlanet) {
                    // If a planet is selected, rotate around the planet
                    const selectedPlanetMesh = window.systemMapState.planets.find(
                        p => p.name === window.systemMapState.selectedPlanet.name
                    );
                    if (selectedPlanetMesh && selectedPlanetMesh.mesh) {
                        selectedPlanetMesh.mesh.getWorldPosition(lookAtTarget);
                    }
                } else {
                    // Otherwise rotate around the sun (origin)
                    lookAtTarget.set(0, 0, 0);
                }

                const touch = event.touches[0];
                const deltaX = touch.clientX - previousPosition.x;
                const deltaY = touch.clientY - previousPosition.y;

                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / radius);

                theta -= deltaX * rotateSpeed;
                phi -= deltaY * rotateSpeed;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);

                // Update camera offset if following a planet
                updateCameraOffsetIfFollowing();

                previousPosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isTouching = false;
        });

        // Pinch zoom for mobile - attach to window
        let lastTouchDistance = 0;

        window.addEventListener('touchstart', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        window.addEventListener('touchmove', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                event.preventDefault();

                const camera = window.systemMapState.camera;
                if (!camera) return;

                // Update lookAtTarget and zoom limits based on what's selected
                let effectiveMinDistance = minDistance;
                let effectiveMaxDistance = maxDistance;

                if (window.systemMapState.selectedPlanet) {
                    // If a planet is selected, zoom towards the planet with closer limits
                    const selectedPlanetMesh = window.systemMapState.planets.find(
                        p => p.name === window.systemMapState.selectedPlanet.name
                    );
                    if (selectedPlanetMesh && selectedPlanetMesh.mesh) {
                        selectedPlanetMesh.mesh.getWorldPosition(lookAtTarget);
                        // Allow much closer zoom when viewing a planet
                        effectiveMinDistance = 5;   // Can zoom very close to planet
                        effectiveMaxDistance = 100; // Don't need to zoom as far out
                    }
                } else {
                    // Otherwise zoom towards the sun (origin) with system-wide limits
                    lookAtTarget.set(0, 0, 0);
                }

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const delta = distance - lastTouchDistance;
                const offset = camera.position.clone().sub(lookAtTarget);
                let dist = offset.length();

                if (delta < 0) {
                    dist *= (1 + zoomSpeed);
                } else {
                    dist *= (1 - zoomSpeed);
                }

                dist = Math.max(effectiveMinDistance, Math.min(effectiveMaxDistance, dist));
                offset.normalize().multiplyScalar(dist);
                camera.position.copy(lookAtTarget).add(offset);

                // Update camera offset if following a planet
                updateCameraOffsetIfFollowing();

                lastTouchDistance = distance;
            }
        }, { passive: false });

        // Add click handler for planet selection
        window.addEventListener('click', handlePlanetClick);

        console.log('System map controls initialized with planet click handling');
    }

    // Expose procedural texture generation globally for orbit map use
    window.generatePlanetTexture = generatePlanetTexture;
    window.hexToRgb = hexToRgb;
    window.lerpColor = lerpColor;
    window.octaveNoise = octaveNoise;
    window.noise2D = noise2D;
    </script>

    <!-- Orbit Map (Planet Detail View) Script -->
    <script type="module">
    import * as THREE from 'three';
    import { TGALoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/TGALoader.js';

    // Global state for orbit map
    window.orbitMapState = {
        scene: null,
        camera: null,
        renderer: null,  // Will share renderer with system map
        planet: null,    // Central planet mesh
        moons: [],       // Orbiting moon meshes
        stations: [],    // Orbital station meshes
        markers: [],     // Surface marker meshes
        orbits: [],      // Orbital path lines
        currentBody: null,  // Which planet we're viewing (slug)
        currentSystem: null,  // Which system the planet is in
        orbitMapData: null,  // Loaded orbit_map.yaml data
        animationFrameId: null,
        startTime: Date.now(),
        speedMultiplier: 1.0,
        planetRotation: 0,  // Track planet rotation for surface markers
        controlsInitialized: false,  // Track if controls have been set up
        isActive: false,  // Track if this view is currently active
        selectionReticle: null,  // Targeting reticle for selected elements
        selectedElement: null,  // Currently selected element {type, name, mesh}
        defaultCameraPosition: { x: 0, y: 30, z: 50 },  // Default camera position to return to
        cameraLookAt: { x: 0, y: 0, z: 0 },  // Current camera target (planet center or selected element)
        surfaceCameraOffset: null,  // Camera offset for following surface markers
        animationPaused: false,  // Pause planet/orbit animation when surface marker selected
        pausedAt: null  // Timestamp when animation was paused
    };

    /**
     * Initialize orbit map scene
     */
    function initOrbitMap() {
        // Reuse system map canvas
        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas) return;

        // Create new scene for orbit map
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        window.orbitMapState.scene = scene;

        // Create camera
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 30, 50);
        camera.lookAt(0, 0, 0);
        window.orbitMapState.camera = camera;

        // Create or reuse renderer
        let renderer;
        if (window.systemMapState && window.systemMapState.renderer) {
            // Reuse system map renderer if it exists
            renderer = window.systemMapState.renderer;
        } else {
            // Create new renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Also store in systemMapState for sharing
            if (window.systemMapState) {
                window.systemMapState.renderer = renderer;
            }
        }

        // Enable shadow maps for eclipse effect
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // Soft shadows
        window.orbitMapState.renderer = renderer;

        // Ambient fill light - see dark side while keeping terminator visible
        const ambientLight = new THREE.AmbientLight(0x778899, 1.1);  // Stronger fill light
        scene.add(ambientLight);

        // Default sun position (will be updated when orbit data loads)
        const sunDistance = 200;
        const sunPosition = new THREE.Vector3(-sunDistance, 0, 0);

        // Intense directional light for stark terminator line
        const directionalLight = new THREE.DirectionalLight(0xFFFFF0, 4.0);  // Very bright warm white
        directionalLight.position.copy(sunPosition);

        // Enable shadow casting for eclipse effect
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 50;
        directionalLight.shadow.camera.far = 400;
        // Shadow camera frustum needs to cover orbital area
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.bias = -0.001;  // Reduce shadow acne

        scene.add(directionalLight);
        window.orbitMapState.directionalLight = directionalLight;

        // Create sun with multiple glow layers for intense effect
        const sunGroup = new THREE.Group();
        sunGroup.position.copy(sunPosition);

        // Core sun sphere (blinding white center)
        const sunCoreGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunCoreMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,  // Pure white
        });
        const sunCore = new THREE.Mesh(sunCoreGeometry, sunCoreMaterial);
        sunGroup.add(sunCore);

        // Inner glow layer
        const innerGlowGeometry = new THREE.SphereGeometry(8, 32, 32);
        const innerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFDD,
            transparent: true,
            opacity: 0.7,
            side: THREE.BackSide
        });
        const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
        sunGroup.add(innerGlow);

        // Middle glow layer
        const middleGlowGeometry = new THREE.SphereGeometry(14, 32, 32);
        const middleGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFEE88,
            transparent: true,
            opacity: 0.4,
            side: THREE.BackSide
        });
        const middleGlow = new THREE.Mesh(middleGlowGeometry, middleGlowMaterial);
        sunGroup.add(middleGlow);

        // Outer glow layer (corona)
        const outerGlowGeometry = new THREE.SphereGeometry(22, 32, 32);
        const outerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFCC44,
            transparent: true,
            opacity: 0.2,
            side: THREE.BackSide
        });
        const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
        sunGroup.add(outerGlow);

        // Add sun flare sprite (billboard that always faces camera)
        const flareCanvas = document.createElement('canvas');
        flareCanvas.width = 256;
        flareCanvas.height = 256;
        const flareCtx = flareCanvas.getContext('2d');
        const flareGradient = flareCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
        flareGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        flareGradient.addColorStop(0.08, 'rgba(255, 255, 220, 0.9)');
        flareGradient.addColorStop(0.2, 'rgba(255, 238, 136, 0.5)');
        flareGradient.addColorStop(0.4, 'rgba(255, 200, 80, 0.2)');
        flareGradient.addColorStop(0.7, 'rgba(255, 170, 50, 0.05)');
        flareGradient.addColorStop(1, 'rgba(255, 150, 30, 0)');
        flareCtx.fillStyle = flareGradient;
        flareCtx.fillRect(0, 0, 256, 256);

        const flareTexture = new THREE.CanvasTexture(flareCanvas);
        const flareMaterial = new THREE.SpriteMaterial({
            map: flareTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            opacity: 1.0
        });
        const sunFlare = new THREE.Sprite(flareMaterial);
        sunFlare.scale.set(60, 60, 1);  // Large intense flare
        sunGroup.add(sunFlare);

        scene.add(sunGroup);
        window.orbitMapState.sunGroup = sunGroup;

        // Add background starfield (similar to system map)
        createOrbitMapStarfield();

        // Create selection reticle (same pattern as system map)
        const reticleTexture = createReticleTexture();
        const selectionReticle = new THREE.Sprite(new THREE.SpriteMaterial({
            map: reticleTexture,
            transparent: true,
            opacity: 0.8,
            depthTest: false,  // Always render on top
            depthWrite: false
        }));
        selectionReticle.scale.set(10, 10, 1);  // Default scale, will be adjusted per element
        selectionReticle.visible = false;  // Hidden by default
        scene.add(selectionReticle);

        // Store reticle reference globally
        window.orbitMapState.selectionReticle = selectionReticle;

        console.log('Orbit map scene initialized');
    }

    /**
     * Create reticle texture for orbit map (same as system map)
     */
    function createReticleTexture() {
        const size = 256;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        const centerX = size / 2;
        const centerY = size / 2;

        // Amber color (muted yellow) - #8b7355
        const amberColor = 'rgba(139, 115, 85, 1.0)';

        // Clear canvas
        ctx.clearRect(0, 0, size, size);

        // Use compositing to create cutout effect
        ctx.globalCompositeOperation = 'source-over';

        // Draw outer circle
        ctx.strokeStyle = amberColor;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
        ctx.stroke();

        // Draw inner circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
        ctx.stroke();

        // Draw corner brackets
        const bracketSize = 18;
        const bracketDistance = 95;
        ctx.lineWidth = 3;
        // Top-left
        ctx.beginPath();
        ctx.moveTo(centerX - bracketDistance, centerY - bracketDistance + bracketSize);
        ctx.lineTo(centerX - bracketDistance, centerY - bracketDistance);
        ctx.lineTo(centerX - bracketDistance + bracketSize, centerY - bracketDistance);
        ctx.stroke();
        // Top-right
        ctx.beginPath();
        ctx.moveTo(centerX + bracketDistance - bracketSize, centerY - bracketDistance);
        ctx.lineTo(centerX + bracketDistance, centerY - bracketDistance);
        ctx.lineTo(centerX + bracketDistance, centerY - bracketDistance + bracketSize);
        ctx.stroke();
        // Bottom-left
        ctx.beginPath();
        ctx.moveTo(centerX - bracketDistance, centerY + bracketDistance - bracketSize);
        ctx.lineTo(centerX - bracketDistance, centerY + bracketDistance);
        ctx.lineTo(centerX - bracketDistance + bracketSize, centerY + bracketDistance);
        ctx.stroke();
        // Bottom-right
        ctx.beginPath();
        ctx.moveTo(centerX + bracketDistance - bracketSize, centerY + bracketDistance);
        ctx.lineTo(centerX + bracketDistance, centerY + bracketDistance);
        ctx.lineTo(centerX + bracketDistance, centerY + bracketDistance - bracketSize);
        ctx.stroke();

        // Use destination-out to cut out the cross
        ctx.globalCompositeOperation = 'destination-out';

        // Horizontal cross bar
        ctx.fillStyle = 'rgba(0, 0, 0, 1)';
        ctx.fillRect(centerX - 90, centerY - 5, 180, 10);

        // Vertical cross bar
        ctx.fillRect(centerX - 5, centerY - 90, 10, 180);

        // Reset composite operation
        ctx.globalCompositeOperation = 'source-over';

        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    /**
     * Create background starfield for orbit map
     */
    function createOrbitMapStarfield() {
        const scene = window.orbitMapState.scene;
        const starCount = 5000;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            const radius = 400 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            starPositions[i3 + 2] = radius * Math.cos(phi);
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

        const starMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 1.5,
            sizeAttenuation: true
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
    }

    /**
     * Load and display orbit map for a planet
     * @param {string} systemSlug - System slug (e.g., "sol")
     * @param {string} bodySlug - Planet slug (e.g., "earth")
     */
    async function loadOrbitMap(systemSlug, bodySlug) {
        try {
            const response = await fetch(`/api/orbit-map/${systemSlug}/${bodySlug}/`);
            if (!response.ok) {
                throw new Error(`Failed to load orbit map: ${response.status}`);
            }

            const data = await response.json();
            console.log('Orbit map data loaded:', data);

            // Clear existing orbit map
            clearOrbitMap();

            // Initialize scene if not already done
            if (!window.orbitMapState.scene) {
                initOrbitMap();
            }

            // Show orbit map canvas (hide other views)
            showOrbitMapCanvas();

            // Store orbit map data
            window.orbitMapState.orbitMapData = data;
            window.orbitMapState.currentBody = bodySlug;
            window.orbitMapState.currentSystem = systemSlug;
            window.orbitMapState.startTime = Date.now();

            // Set camera position from config and store as default
            if (data.camera && data.camera.position) {
                const camPos = data.camera.position;
                window.orbitMapState.camera.position.set(camPos[0], camPos[1], camPos[2]);
                window.orbitMapState.camera.lookAt(0, 0, 0);
                // Store default position for returning after element selection
                window.orbitMapState.defaultCameraPosition = { x: camPos[0], y: camPos[1], z: camPos[2] };
            } else {
                // Use fallback default
                window.orbitMapState.defaultCameraPosition = { x: 0, y: 30, z: 50 };
            }
            // Reset camera target to planet center
            window.orbitMapState.cameraLookAt = { x: 0, y: 0, z: 0 };

            // Update sun position based on planet's orbital angle and declination
            updateSunPosition(data.planet);

            // Render the central planet
            renderCentralPlanet(data.planet);

            // Render moons
            if (data.moons && data.moons.length > 0) {
                data.moons.forEach(moon => renderMoon(moon));
            }

            // Render orbital stations
            if (data.orbital_stations && data.orbital_stations.length > 0) {
                data.orbital_stations.forEach(station => renderOrbitalStation(station));
            }

            // Render surface markers
            if (data.surface_markers && data.surface_markers.length > 0) {
                data.surface_markers.forEach(marker => renderSurfaceMarker(marker));
            }

            // Initialize controls (only once)
            if (!window.orbitMapState.controlsInitialized) {
                initOrbitMapControls();
                window.orbitMapState.controlsInitialized = true;
            }

            // Switch active view flags
            window.systemMapState.isActive = false;
            window.orbitMapState.isActive = true;

            // Start animation
            if (!window.orbitMapState.animationFrameId) {
                animateOrbitMap();
            }

            // Update menu to show orbit map contents and back button
            window.updateOrbitMapMenu(data);

            // Planet info already showing from selectPlanet() call in transitionToOrbitMap
            // Don't overwrite it here - keep the full planet details

            console.log('✅ Orbit map rendered successfully');

        } catch (error) {
            console.error('Error loading orbit map:', error);
        }
    }

    /**
     * Update sun position based on planet's orbital angle and sun declination
     */
    function updateSunPosition(planetData) {
        const sunDistance = 200;

        // Calculate sun direction based on planet's orbital position
        let sunDirection = new THREE.Vector3(-1, 0, 0);  // Default direction

        // Try to get actual orbital angle from selected planet data
        const selectedPlanet = window.systemMapState?.selectedPlanet;
        if (selectedPlanet && selectedPlanet.orbital_angle !== undefined) {
            // Planet is at angle θ from star, so star is at angle θ + 180° from planet
            const angleRad = ((selectedPlanet.orbital_angle || 0) + 180) * (Math.PI / 180);
            sunDirection = new THREE.Vector3(
                Math.cos(angleRad),
                0,
                Math.sin(angleRad)
            );
            console.log('Sun positioned based on orbital angle:', selectedPlanet.orbital_angle);
        }

        // Apply sun declination (season angle) from planet data
        // Positive = northern hemisphere tilted toward sun (northern summer)
        // Negative = southern hemisphere tilted toward sun (southern summer)
        const sunDeclination = planetData?.sun_declination || 0;
        if (sunDeclination !== 0) {
            // Convert declination to radians and apply as elevation
            const declinationRad = sunDeclination * (Math.PI / 180);
            // Elevate sun direction by declination angle
            sunDirection.y = Math.sin(declinationRad);
            // Scale horizontal components to maintain unit vector length
            const horizontalScale = Math.cos(declinationRad);
            sunDirection.x *= horizontalScale;
            sunDirection.z *= horizontalScale;
            console.log('Sun declination applied:', sunDeclination, 'degrees');
        }
        sunDirection.normalize();

        // Calculate new sun position
        const sunPosition = sunDirection.clone().multiplyScalar(sunDistance);

        // Update directional light position
        if (window.orbitMapState.directionalLight) {
            window.orbitMapState.directionalLight.position.copy(sunPosition);
        }

        // Update sun visual position
        if (window.orbitMapState.sunGroup) {
            window.orbitMapState.sunGroup.position.copy(sunPosition);
        }

        console.log('Sun position updated:', sunPosition);
    }

    /**
     * Render the central planet with procedural texture
     */
    function renderCentralPlanet(planetData) {
        const scene = window.orbitMapState.scene;

        // Remove old planet if it exists
        if (window.orbitMapState.planet && window.orbitMapState.planet.mesh) {
            const oldPlanet = window.orbitMapState.planet.mesh;
            scene.remove(oldPlanet);

            // Dispose of old resources
            if (oldPlanet.geometry) oldPlanet.geometry.dispose();
            if (oldPlanet.material) {
                if (oldPlanet.material.map) oldPlanet.material.map.dispose();
                oldPlanet.material.dispose();
            }

            // Remove old cloud layer if it exists
            if (window.orbitMapState.planet.clouds) {
                const oldClouds = window.orbitMapState.planet.clouds;
                scene.remove(oldClouds);
                if (oldClouds.geometry) oldClouds.geometry.dispose();
                if (oldClouds.material) {
                    if (oldClouds.material.map) oldClouds.material.map.dispose();
                    oldClouds.material.dispose();
                }
            }

            // Remove old lat/lon grid if it exists
            if (window.orbitMapState.planet.latLonGrid) {
                const oldGrid = window.orbitMapState.planet.latLonGrid;
                scene.remove(oldGrid);
                if (oldGrid.geometry) oldGrid.geometry.dispose();
                if (oldGrid.material) oldGrid.material.dispose();
            }

            console.log('Removed old planet mesh, clouds, and grid');
        }

        const size = planetData.size || 15.0;
        // Use SphereGeometry for equirectangular textures (standard texture format)
        const geometry = new THREE.SphereGeometry(size, 64, 64);

        // Load PNG texture (default or from planet config)
        const textureLoader = new THREE.TextureLoader();
        const texturePath = planetData.texture || '/textures/planet_default.png';
        const texture = textureLoader.load(texturePath,
            () => console.log('Planet texture loaded:', texturePath),
            undefined,
            (err) => console.error('Error loading texture:', err)
        );

        // Derive normal map path from diffuse texture path
        // Pattern: /textures/type/Type-EQUIRECTANGULAR-N-size.png -> /textures/type/Bump-EQUIRECTANGULAR-N-size.png
        const normalMapPath = planetData.normal_map || texturePath.replace(/\/[^\/]+-EQUIRECTANGULAR-/, '/Bump-EQUIRECTANGULAR-');

        // Create material with normal map support
        const material = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.7,
            metalness: 0.0
        });

        // Load normal map (RGB encoded surface normals - optional)
        if (normalMapPath && normalMapPath !== texturePath) {
            textureLoader.load(normalMapPath,
                (normalMap) => {
                    material.normalMap = normalMap;
                    material.normalScale = new THREE.Vector2(5.0, 5.0);  // Cranked up for maximum detail
                    material.needsUpdate = true;
                    console.log('Planet normal map loaded:', normalMapPath);
                },
                undefined,
                (err) => console.warn('Normal map not found (optional):', normalMapPath)
            );
        }

        const planet = new THREE.Mesh(geometry, material);
        planet.rotation.y = 0;  // Will rotate in animation loop

        // Planet casts shadows (for moon eclipse effect)
        planet.castShadow = true;
        planet.receiveShadow = true;

        // Apply axial tilt if specified
        if (planetData.axial_tilt) {
            planet.rotation.z = (planetData.axial_tilt * Math.PI) / 180;
        }

        scene.add(planet);

        // Add lat/lon grid overlay
        const latLonSegments = 32;  // More segments = smoother grid lines
        const gridGeometry = new THREE.SphereGeometry(size * 1.02, latLonSegments, latLonSegments);
        const gridMaterial = new THREE.MeshBasicMaterial({
            color: 0x5a7a7a,  // Teal
            wireframe: true,
            transparent: true,
            opacity: 0.3,
            depthWrite: false
        });

        const latLonGrid = new THREE.Mesh(gridGeometry, gridMaterial);

        // Apply same axial tilt as planet
        if (planetData.axial_tilt) {
            latLonGrid.rotation.z = (planetData.axial_tilt * Math.PI) / 180;
        }

        scene.add(latLonGrid);

        window.orbitMapState.planet = {
            mesh: planet,
            rotationSpeed: planetData.rotation_speed || 0.002,
            latLonGrid: latLonGrid
        };

        console.log('Central planet rendered with texture and lat/lon grid');
    }

    /**
     * Render an orbiting moon
     */
    function renderMoon(moonData) {
        const scene = window.orbitMapState.scene;

        const size = moonData.size || 3.0;
        // Use SphereGeometry for equirectangular textures (standard texture format)
        const geometry = new THREE.SphereGeometry(size, 32, 32);

        // Load texture for moon (direct texture or procedural)
        let material;
        if (moonData.texture) {
            // Load direct texture (e.g., icosahedral texture)
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(moonData.texture,
                () => console.log('Moon texture loaded:', moonData.texture),
                undefined,
                (err) => console.error('Error loading moon texture:', err)
            );

            // Derive normal map path from diffuse texture path
            const normalMapPath = moonData.normal_map || moonData.texture.replace(/\/[^\/]+-EQUIRECTANGULAR-/, '/Bump-EQUIRECTANGULAR-');

            material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.8,
                metalness: 0.0
            });

            // Load normal map (RGB encoded surface normals - optional)
            if (normalMapPath && normalMapPath !== moonData.texture) {
                textureLoader.load(normalMapPath,
                    (normalMap) => {
                        material.normalMap = normalMap;
                        material.normalScale = new THREE.Vector2(5.0, 5.0);  // Cranked up for maximum detail
                        material.needsUpdate = true;
                        console.log('Moon normal map loaded:', normalMapPath);
                    },
                    undefined,
                    (err) => console.warn('Moon normal map not found (optional):', normalMapPath)
                );
            }
        } else if (moonData.texture_config) {
            // Generate procedural texture
            const texture = generatePlanetTexture(moonData.texture_config);
            material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.8,
                metalness: 0.0
            });
        } else {
            // Fallback: simple colored sphere
            material = new THREE.MeshStandardMaterial({
                color: moonData.color || 0xAAAAAA,
                roughness: 0.8,
                metalness: 0.0
            });
        }

        const moon = new THREE.Mesh(geometry, material);

        // Moon receives shadows (eclipsed by planet)
        moon.castShadow = true;
        moon.receiveShadow = true;

        scene.add(moon);

        // Render orbital path
        const orbitLine = renderOrbitPath(moonData);

        // Store moon data
        window.orbitMapState.moons.push({
            mesh: moon,
            name: moonData.name,
            orbitalRadius: moonData.orbital_radius,
            orbitalPeriod: moonData.orbital_period,
            initialAngle: (moonData.orbital_angle || 0) * (Math.PI / 180),
            inclination: moonData.inclination || 0,
            clickable: moonData.clickable || false,
            data: moonData
        });

        console.log(`Moon rendered: ${moonData.name}`);
    }

    /**
     * Render orbital path line
     */
    function renderOrbitPath(bodyData) {
        const scene = window.orbitMapState.scene;
        const radius = bodyData.orbital_radius;
        const inclination = bodyData.inclination || 0;

        // Create points in XZ plane (horizontal) to match moon animation
        const points = [];
        const segments = 128;
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);
            points.push(new THREE.Vector3(x, 0, z));
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const material = new THREE.LineBasicMaterial({
            color: 0x5a7a7a,  // Teal to match UI
            opacity: 0.3,
            transparent: true
        });

        const orbitLine = new THREE.Line(geometry, material);

        // Apply orbital inclination (rotate around X axis to tilt the orbit)
        orbitLine.rotation.x = (inclination * Math.PI) / 180;

        scene.add(orbitLine);
        window.orbitMapState.orbits.push(orbitLine);

        return orbitLine;
    }

    /**
     * Render an orbital station
     */
    function renderOrbitalStation(stationData) {
        const scene = window.orbitMapState.scene;

        // Create station sprite (simple icon for now)
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');

        // Draw station icon (simple square with border)
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, 32, 32);
        ctx.strokeStyle = '#8b7355';  // Amber
        ctx.lineWidth = 3;
        ctx.strokeRect(4, 4, 24, 24);
        ctx.fillStyle = '#8b7355';
        ctx.fillRect(8, 8, 16, 16);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(stationData.size || 1.5, stationData.size || 1.5, 1);

        scene.add(sprite);

        // Render orbital path
        const orbitLine = renderOrbitPath(stationData);

        // Store station data
        window.orbitMapState.stations.push({
            mesh: sprite,
            name: stationData.name,
            orbitalRadius: stationData.orbital_radius,
            orbitalPeriod: stationData.orbital_period,
            initialAngle: (stationData.orbital_angle || 0) * (Math.PI / 180),
            inclination: stationData.inclination || 0,
            data: stationData
        });

        console.log(`Orbital station rendered: ${stationData.name}`);
    }

    /**
     * Render a surface marker on the planet
     */
    function renderSurfaceMarker(markerData) {
        const scene = window.orbitMapState.scene;
        const planetData = window.orbitMapState.orbitMapData.planet;
        const planetRadius = planetData.size || 15.0;

        // Create marker sprite
        const canvas = document.createElement('canvas');
        canvas.width = 24;
        canvas.height = 24;
        const ctx = canvas.getContext('2d');

        // Draw marker based on type
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(12, 12, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#5a7a7a';  // Teal
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(12, 12, 10, 0, Math.PI * 2);
        ctx.stroke();

        // Add marker type indicator
        ctx.fillStyle = '#5a7a7a';
        ctx.fillRect(8, 8, 8, 8);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(2, 2, 1);

        // Position on planet surface using lat/lon
        const position = latLonToVector3(
            markerData.latitude,
            markerData.longitude,
            planetRadius + 0.5  // Slightly above surface
        );
        sprite.position.copy(position);

        scene.add(sprite);

        // Store marker data
        window.orbitMapState.markers.push({
            mesh: sprite,
            name: markerData.name,
            latitude: markerData.latitude,
            longitude: markerData.longitude,
            radius: planetRadius,
            data: markerData
        });

        console.log(`Surface marker rendered: ${markerData.name}`);
    }

    /**
     * Convert latitude/longitude to 3D position on sphere
     */
    function latLonToVector3(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        return new THREE.Vector3(
            -(radius * Math.sin(phi) * Math.cos(theta)),
            radius * Math.cos(phi),
            radius * Math.sin(phi) * Math.sin(theta)
        );
    }

    /**
     * Animation loop for orbit map
     */
    function animateOrbitMap() {
        window.orbitMapState.animationFrameId = requestAnimationFrame(animateOrbitMap);

        const scene = window.orbitMapState.scene;
        const camera = window.orbitMapState.camera;
        const renderer = window.orbitMapState.renderer;

        if (!scene || !camera || !renderer) return;

        const currentTime = Date.now();
        const elapsedSeconds = (currentTime - window.orbitMapState.startTime) / 1000;

        // Skip animation updates if paused (surface marker selected)
        const isPaused = window.orbitMapState.animationPaused;

        // Rotate central planet (unless paused)
        if (window.orbitMapState.planet && !isPaused) {
            const planet = window.orbitMapState.planet;
            planet.mesh.rotation.y += planet.rotationSpeed;
            window.orbitMapState.planetRotation = planet.mesh.rotation.y;

            // Rotate lat/lon grid with planet
            if (planet.latLonGrid) {
                planet.latLonGrid.rotation.y = planet.mesh.rotation.y;
            }

            // Rotate surface markers with planet
            window.orbitMapState.markers.forEach(markerData => {
                // Get base position from lat/lon
                const basePosition = latLonToVector3(
                    markerData.latitude,
                    markerData.longitude,
                    markerData.radius + 0.5
                );

                // Create rotation matrix matching planet's rotation
                const rotationMatrix = new THREE.Matrix4().makeRotationY(planet.mesh.rotation.y);

                // Apply rotation to position
                const rotatedPosition = basePosition.clone().applyMatrix4(rotationMatrix);

                markerData.mesh.position.copy(rotatedPosition);
            });
        }

        // Animate orbiting moons (unless paused)
        if (!isPaused) {
            window.orbitMapState.moons.forEach(moonData => {
                const orbitalSpeed = (2 * Math.PI) / moonData.orbitalPeriod;
                const currentAngle = moonData.initialAngle + (orbitalSpeed * elapsedSeconds);

                // Calculate position in flat XZ plane
                const x = moonData.orbitalRadius * Math.cos(currentAngle);
                const z = moonData.orbitalRadius * Math.sin(currentAngle);
                let y = 0;

                // Apply orbital inclination if present
                if (moonData.inclination) {
                    const inclinationRad = (moonData.inclination * Math.PI) / 180;
                    // Rotate around X axis: y' = y*cos - z*sin, z' = y*sin + z*cos
                    const yRotated = y * Math.cos(inclinationRad) - z * Math.sin(inclinationRad);
                    const zRotated = y * Math.sin(inclinationRad) + z * Math.cos(inclinationRad);
                    y = yRotated;
                    moonData.mesh.position.set(x, y, zRotated);
                } else {
                    moonData.mesh.position.set(x, y, z);
                }
            });
        }

        // Animate orbiting stations (unless paused)
        if (!isPaused) {
            window.orbitMapState.stations.forEach(stationData => {
                const orbitalSpeed = (2 * Math.PI) / stationData.orbitalPeriod;
                const currentAngle = stationData.initialAngle + (orbitalSpeed * elapsedSeconds);

                // Calculate position in flat XZ plane
                const x = stationData.orbitalRadius * Math.cos(currentAngle);
                const z = stationData.orbitalRadius * Math.sin(currentAngle);
                let y = 0;

                // Apply orbital inclination if present
                if (stationData.inclination) {
                    const inclinationRad = (stationData.inclination * Math.PI) / 180;
                    // Rotate around X axis: y' = y*cos - z*sin, z' = y*sin + z*cos
                    const yRotated = y * Math.cos(inclinationRad) - z * Math.sin(inclinationRad);
                    const zRotated = y * Math.sin(inclinationRad) + z * Math.cos(inclinationRad);
                    y = yRotated;
                    stationData.mesh.position.set(x, y, zRotated);
                } else {
                    stationData.mesh.position.set(x, y, z);
                }
            });
        }

        // Update selection reticle position to follow selected element
        if (window.orbitMapState.selectionReticle && window.orbitMapState.selectionReticle.visible) {
            const selectedElement = window.orbitMapState.selectedElement;
            if (selectedElement && selectedElement.mesh) {
                // Update reticle position to match element's current position
                window.orbitMapState.selectionReticle.position.copy(selectedElement.mesh.position);
            }
        }

        // Update camera to track selected orbiting element (moons/stations only)
        // Surface markers don't need tracking since animation is paused when they're selected
        if (window.orbitMapState.cameraLookAt === null && window.orbitMapState.selectedElement?.mesh) {
            const selectedElement = window.orbitMapState.selectedElement;

            // Only track orbiting elements (moons/stations), not surface markers
            if (selectedElement.type !== 'surface') {
                camera.lookAt(window.orbitMapState.selectedElement.mesh.position);
            }
        }

        renderer.render(scene, camera);
    }

    /**
     * Clear orbit map scene
     */
    function clearOrbitMap() {
        const scene = window.orbitMapState.scene;
        if (!scene) return;

        // Remove planet (including clouds and lat/lon grid)
        if (window.orbitMapState.planet) {
            // Remove planet mesh
            if (window.orbitMapState.planet.mesh) {
                scene.remove(window.orbitMapState.planet.mesh);
            }

            // Remove cloud layer if it exists
            if (window.orbitMapState.planet.clouds) {
                scene.remove(window.orbitMapState.planet.clouds);
                if (window.orbitMapState.planet.clouds.geometry) {
                    window.orbitMapState.planet.clouds.geometry.dispose();
                }
                if (window.orbitMapState.planet.clouds.material) {
                    window.orbitMapState.planet.clouds.material.dispose();
                }
            }

            // Remove lat/lon grid if it exists
            if (window.orbitMapState.planet.latLonGrid) {
                scene.remove(window.orbitMapState.planet.latLonGrid);
                if (window.orbitMapState.planet.latLonGrid.geometry) {
                    window.orbitMapState.planet.latLonGrid.geometry.dispose();
                }
                if (window.orbitMapState.planet.latLonGrid.material) {
                    window.orbitMapState.planet.latLonGrid.material.dispose();
                }
            }

            window.orbitMapState.planet = null;
        }

        // Remove moons
        window.orbitMapState.moons.forEach(m => scene.remove(m.mesh));
        window.orbitMapState.moons = [];

        // Remove stations
        window.orbitMapState.stations.forEach(s => scene.remove(s.mesh));
        window.orbitMapState.stations = [];

        // Remove markers
        window.orbitMapState.markers.forEach(m => scene.remove(m.mesh));
        window.orbitMapState.markers = [];

        // Remove orbits
        window.orbitMapState.orbits.forEach(o => scene.remove(o));
        window.orbitMapState.orbits = [];

        // Hide selection reticle
        if (window.orbitMapState.selectionReticle) {
            window.orbitMapState.selectionReticle.visible = false;
        }

        // Clear selected element and camera tracking
        window.orbitMapState.selectedElement = null;
        window.orbitMapState.surfaceCameraOffset = null;
        window.orbitMapState.animationPaused = false;
        window.orbitMapState.pausedAt = null;

        console.log('Orbit map cleared (including clouds and lat/lon grid)');
    }

    /**
     * Show orbit map canvas and hide other views (for testing)
     */
    function showOrbitMapCanvas() {
        // Get canvas elements
        const systemCanvas = document.getElementById('systemmap-canvas');
        const galaxyCanvas = document.getElementById('galaxy-canvas');

        // Show system map canvas (orbit map uses same canvas)
        if (systemCanvas) {
            systemCanvas.style.display = 'block';
            systemCanvas.style.opacity = '1';
        }

        // Hide galaxy canvas
        if (galaxyCanvas) {
            galaxyCanvas.style.display = 'none';
        }

        // Hide other view containers
        const standbyView = document.querySelector('.standby-container');

        if (standbyView) standbyView.style.display = 'none';

        // Keep dashboard visible so star-map-panel remains accessible
        // The orbit map shows with the dashboard panel containing the navigation menu

        console.log('Orbit map canvas visible, dashboard kept visible for menu');
    }

    /**
     * Initialize orbit map camera controls (zoom, rotate, pan)
     */
    function initOrbitMapControls() {
        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas) return;

        const MIN_ZOOM = 20;
        const MAX_ZOOM = 150;
        const ZOOM_SPEED = 0.05;
        const ROTATE_SPEED = 0.003;

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Mouse wheel zoom
        window.addEventListener('wheel', (event) => {
            if (canvas.style.display !== 'block') return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;  // Only handle if orbit map is active

            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content');
            if (isPanel) return;

            event.preventDefault();

            const camera = window.orbitMapState.camera;
            if (!camera) return;

            const zoomDirection = event.deltaY > 0 ? 1 : -1;
            const currentDistance = camera.position.length();
            const newDistance = currentDistance * (1 + zoomDirection * ZOOM_SPEED);

            if (newDistance >= MIN_ZOOM && newDistance <= MAX_ZOOM) {
                const scale = newDistance / currentDistance;
                camera.position.multiplyScalar(scale);
            }
        }, { passive: false });

        // Mouse drag to rotate - attach to window (like system map)
        window.addEventListener('mousedown', (event) => {
            if (canvas.style.display !== 'block') return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;  // Only handle if orbit map is active

            // Don't start dragging if clicking on UI panels or interactive elements
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
            const isButton = target.closest('button, .orbit-map-btn-container, .back-btn-container');

            if (isPanel || isButton) {
                return;
            }

            if (event.button === 0) {  // Left click
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;  // Only handle if orbit map is active

            const camera = window.orbitMapState.camera;
            if (!camera) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            // Rotate around selected element if one exists, otherwise around planet center
            const lookAtTarget = new THREE.Vector3(0, 0, 0);
            const selectedElement = window.orbitMapState.selectedElement;
            if (selectedElement && selectedElement.mesh) {
                lookAtTarget.copy(selectedElement.mesh.position);
            }

            const offset = camera.position.clone().sub(lookAtTarget);
            const radius = offset.length();

            // Convert to spherical coordinates
            let theta = Math.atan2(offset.x, offset.z);
            let phi = Math.acos(offset.y / radius);

            // Update angles based on mouse movement
            theta -= deltaX * ROTATE_SPEED;
            phi -= deltaY * ROTATE_SPEED;

            // Clamp phi to avoid gimbal lock
            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            // Convert back to Cartesian coordinates
            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            camera.position.copy(lookAtTarget).add(offset);
            camera.lookAt(lookAtTarget);

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch controls - single finger rotation
        let isTouching = false;

        window.addEventListener('touchstart', (event) => {
            // Only handle when orbit map is active
            if (canvas.style.display !== 'block') return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;

            if (event.touches.length === 1) {
                // Check if touching a panel or button
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
                const isButton = target.closest('button, .orbit-map-btn-container, .back-btn-container');
                if (isPanel || isButton) return;

                isTouching = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchmove', (event) => {
            // Only handle when orbit map is active
            if (canvas.style.display !== 'block') return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;

            if (isTouching && event.touches.length === 1) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
                if (isPanel) {
                    isTouching = false;
                    return;
                }

                event.preventDefault();

                const camera = window.orbitMapState.camera;
                if (!camera) return;

                const touch = event.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;

                // Rotate around selected element if one exists, otherwise around planet center
                const lookAtTarget = new THREE.Vector3(0, 0, 0);
                const selectedElement = window.orbitMapState.selectedElement;
                if (selectedElement && selectedElement.mesh) {
                    lookAtTarget.copy(selectedElement.mesh.position);
                }

                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                // Convert to spherical coordinates
                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / radius);

                // Update angles based on touch movement
                theta -= deltaX * ROTATE_SPEED;
                phi -= deltaY * ROTATE_SPEED;

                // Clamp phi to avoid gimbal lock
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                // Convert back to Cartesian coordinates
                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);

                previousMousePosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;
            isTouching = false;
        });

        // Pinch zoom for mobile - two finger
        let lastTouchDistance = 0;

        window.addEventListener('touchstart', (event) => {
            // Only handle when orbit map is active
            if (canvas.style.display !== 'block') return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;

            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
                if (isPanel) return;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        window.addEventListener('touchmove', (event) => {
            // Only handle when orbit map is active
            if (canvas.style.display !== 'block') return;
            if (!window.orbitMapState || !window.orbitMapState.isActive) return;

            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
                if (isPanel) return;

                event.preventDefault();

                const camera = window.orbitMapState.camera;
                if (!camera) return;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const delta = distance - lastTouchDistance;
                const currentDistance = camera.position.length();

                // Apply zoom - pinch out (increasing distance) = zoom in, pinch in = zoom out
                let newDistance;
                if (delta > 0) {
                    // Fingers moving apart - zoom in
                    newDistance = currentDistance * (1 - ZOOM_SPEED);
                } else {
                    // Fingers moving together - zoom out
                    newDistance = currentDistance * (1 + ZOOM_SPEED);
                }

                if (newDistance >= MIN_ZOOM && newDistance <= MAX_ZOOM) {
                    const scale = newDistance / currentDistance;
                    camera.position.multiplyScalar(scale);
                }

                lastTouchDistance = distance;
            }
        }, { passive: false });

        console.log('Orbit map controls initialized (mouse + touch)');
    }

    // Expose functions globally for testing
    window.loadOrbitMap = loadOrbitMap;
    window.initOrbitMap = initOrbitMap;
    window.clearOrbitMap = clearOrbitMap;
    window.showOrbitMapCanvas = showOrbitMapCanvas;
    window.initOrbitMapControls = initOrbitMapControls;

    console.log('Orbit map renderer loaded');
    </script>

    <!-- Star System Selection Script -->
    <script type="module">
    (function() {
        // Typewriter effect for system info panel with operation ID tracking
        let typewriterOperationId = 0;

        function typewriteContent(element, html, speed = 15) {
            // Generate a unique operation ID for this typewriter
            typewriterOperationId++;
            const thisOperationId = typewriterOperationId;

            // Store the current operation ID on the element
            element._currentTypewriterId = thisOperationId;

            return new Promise((resolve) => {
                // Create a temporary div to parse the HTML and extract text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // Clear the element
                element.innerHTML = '';

                // We'll build up the content with proper HTML structure
                let currentHTML = '';
                let charIndex = 0;
                const fullText = tempDiv.textContent;

                function typeNextChar() {
                    // Check if this operation is still current (not superseded by a newer one)
                    if (element._currentTypewriterId !== thisOperationId) {
                        console.log(`Typewriter ${thisOperationId} cancelled - current is ${element._currentTypewriterId}`);
                        resolve();
                        return;
                    }

                    if (charIndex < fullText.length) {
                        // Get the next character
                        const char = fullText[charIndex];
                        charIndex++;

                        // Rebuild HTML up to current position
                        currentHTML = '';
                        let textSoFar = fullText.substring(0, charIndex);
                        let textIndex = 0;

                        // Parse through original HTML structure and insert characters
                        function buildHTML(node) {
                            if (node.nodeType === Node.TEXT_NODE) {
                                const nodeText = node.textContent;
                                const charsToShow = Math.min(nodeText.length, Math.max(0, textSoFar.length - textIndex));
                                textIndex += nodeText.length;
                                return nodeText.substring(0, charsToShow);
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                const tagName = node.tagName.toLowerCase();
                                const className = node.className ? ` class="${node.className}"` : '';
                                let innerHTML = '';

                                for (let child of node.childNodes) {
                                    innerHTML += buildHTML(child);
                                }

                                if (innerHTML.length > 0) {
                                    return `<${tagName}${className}>${innerHTML}</${tagName}>`;
                                }
                                return '';
                            }
                            return '';
                        }

                        currentHTML = '';
                        textIndex = 0;
                        for (let child of tempDiv.childNodes) {
                            currentHTML += buildHTML(child);
                        }

                        element.innerHTML = currentHTML;

                        setTimeout(typeNextChar, speed);
                    } else {
                        // Typewriter completed successfully
                        resolve();
                    }
                }

                typeNextChar();
            });
        }

        // Helper function to position indicator boxes, rectangle, and triangle below the panel
        function updateIndicatorBoxesPosition() {
            const infoPanel = document.getElementById('system-info-panel');
            const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
            const rectangle = document.querySelector('.system-info-rectangle');
            const triangle = document.querySelector('.system-info-triangle');

            if (infoPanel && indicatorBoxes && infoPanel.classList.contains('visible')) {
                const panelRect = infoPanel.getBoundingClientRect();
                const boxesRect = indicatorBoxes.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const boxesTop = panelRect.bottom + 5;

                indicatorBoxes.style.top = boxesTop + 'px';

                // Position rectangle from right edge of boxes to right edge of panel
                if (rectangle) {
                    rectangle.style.top = boxesTop + 'px';
                    // Right edge: same as panel (360px from viewport right)
                    rectangle.style.right = 'calc(300px + 30px + 30px)';  // 360px
                    // Width: from right edge of boxes to right edge of panel, with 10px gap
                    const panelRightEdge = viewportWidth - 360;  // Panel's right edge from left
                    const boxesRightEdge = boxesRect.right;       // Boxes' right edge from left
                    const rectangleWidth = panelRightEdge - boxesRightEdge - 10;  // 10px gap like between boxes
                    rectangle.style.width = rectangleWidth + 'px';

                    // Position triangle on top of rectangle
                    if (triangle) {
                        const triangleHeight = 35;  // Match CSS height
                        const triangleWidth = 35;   // Same as height for isosceles right triangle
                        triangle.style.top = (boxesTop - triangleHeight - 5) + 'px';  // 5px gap between triangle and rectangle
                        triangle.style.right = 'calc(300px + 30px + 30px)';  // Right edge aligned with panel
                        triangle.style.width = triangleWidth + 'px';  // Equal to height for equal legs
                    }
                }
            }
        }

        // Make functions globally accessible
        window.typewriteContent = typewriteContent;
        window.updateIndicatorBoxesPosition = updateIndicatorBoxesPosition;

        // Set up ResizeObserver to reposition indicator boxes when panel resizes
        const systemInfoPanel = document.getElementById('system-info-panel');
        if (systemInfoPanel) {
            const resizeObserver = new ResizeObserver(entries => {
                window.updateIndicatorBoxesPosition();
            });
            resizeObserver.observe(systemInfoPanel);
        }

        // Also update on window resize
        window.addEventListener('resize', window.updateIndicatorBoxesPosition);

        // Initialize galaxy list event listeners on page load (fixes M1 - uses shared function)
        window.initializeGalaxyEventListeners();

        // Check if this is a view change from GM console (not a manual refresh)
        const urlParams = new URLSearchParams(window.location.search);
        const isViewChange = urlParams.get('viewchange') === '1';
        const currentViewType = '{{ active_view.view_type }}';

        // Remove the viewchange parameter from URL (clean up)
        if (isViewChange) {
            window.history.replaceState({}, '', window.location.pathname);
        }

        // Get all star system rows (needed for multiple operations below)
        const starSystemRows = document.querySelectorAll('.star-system-row');

        // Only reset to default state if dashboard was just selected from GM console
        if (isViewChange && currentViewType === 'CAMPAIGN_DASHBOARD') {
            // Clear localStorage
            localStorage.removeItem('selected_star_system');

            // Uncheck all systems
            starSystemRows.forEach(row => {
                row.classList.remove('checked');
            });

            // Hide all UI elements
            const infoPanel = document.getElementById('system-info-panel');
            if (infoPanel) {
                infoPanel.classList.remove('visible');
            }
            const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
            if (indicatorBoxes) {
                indicatorBoxes.classList.remove('visible');
            }
            const rectangle = document.querySelector('.system-info-rectangle');
            if (rectangle) {
                rectangle.classList.remove('visible');
            }
            const triangle = document.querySelector('.system-info-triangle');
            if (triangle) {
                triangle.classList.remove('visible');
            }

            // Hide selection reticle
            if (window.starMapState && window.starMapState.selectionReticle) {
                window.starMapState.selectionReticle.visible = false;
            }

            // Reset camera to center after a short delay to allow star map to load
            setTimeout(() => {
                if (window.starMapState && window.starMapState.animateCameraToTarget) {
                    window.starMapState.animateCameraToTarget(new THREE.Vector3(0, 0, 0), 1000);
                    console.log('Dashboard loaded via GM console - reset to default view');

                    // Re-enable auto-rotation after camera returns to center
                    setTimeout(() => {
                        if (window.starMapState) {
                            window.starMapState.autoRotate = true;
                        }
                    }, 1500);  // Wait for animation to complete
                }
            }, 500);
        }

        // Restore selected system from localStorage on page load (if not resetting)
        const selectedSystem = localStorage.getItem('selected_star_system');

        if (selectedSystem && !(isViewChange && currentViewType === 'CAMPAIGN_DASHBOARD')) {
            // Find and check the stored system
            starSystemRows.forEach(row => {
                if (row.dataset.system === selectedSystem) {
                    row.classList.add('checked');
                } else {
                    row.classList.remove('checked');
                }
            });

            // Populate and show info panel for selected system
            if (window.starSystemsData && window.starSystemsData[selectedSystem]) {
                const systemData = window.starSystemsData[selectedSystem];
                const infoPanel = document.getElementById('system-info-panel');
                const infoPanelName = document.getElementById('system-info-name');
                const infoPanelContent = document.getElementById('system-info-content');

                if (infoPanel && infoPanelName && infoPanelContent) {
                    // Build info content HTML
                    let contentHTML = '';

                    if (systemData.type) {
                        contentHTML += '<p><span class="info-label">TYPE:</span> <span class="info-value">' +
                            systemData.type.toUpperCase() + '</span></p>';
                    }
                    if (systemData.description) {
                        contentHTML += '<p><span class="info-label">DESCRIPTION:</span> <span class="info-value">' +
                            systemData.description + '</span></p>';
                    }
                    if (systemData.population) {
                        contentHTML += '<p><span class="info-label">POPULATION:</span> <span class="info-value">' +
                            systemData.population + '</span></p>';
                    }
                    if (systemData.position) {
                        contentHTML += '<p><span class="info-label">COORDINATES:</span> <span class="info-value">' +
                            systemData.position.join(', ') + '</span></p>';
                    }
                    if (systemData.location_slug) {
                        contentHTML += '<p><span class="info-label">LOCATION ID:</span> <span class="info-value">' +
                            systemData.location_slug + '</span></p>';
                    }
                    if (systemData.has_system_map) {
                        contentHTML += '<p><span class="info-label">SYSTEM MAP:</span> <span class="info-value">AVAILABLE</span></p>';
                    }

                    // Update panel with typewriter effect
                    async function initPanel() {
                        infoPanelName.textContent = systemData.name.toUpperCase();
                        await window.typewriteContent(infoPanelContent, contentHTML);
                        infoPanel.classList.add('visible');

                        // Show indicator boxes, rectangle, and triangle
                        const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
                        if (indicatorBoxes) {
                            indicatorBoxes.classList.add('visible');
                        }
                        const rectangle = document.querySelector('.system-info-rectangle');
                        if (rectangle) {
                            rectangle.classList.add('visible');
                        }
                        const triangle = document.querySelector('.system-info-triangle');
                        if (triangle) {
                            triangle.classList.add('visible');
                        }

                        // Position the elements
                        setTimeout(() => {
                            window.updateIndicatorBoxesPosition();
                        }, 50);
                    }

                    initPanel();
                }
            }

            // Wait for star map to load, then animate to selected system
            setTimeout(() => {
                if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                    const position = window.starMapState.starPositions.get(selectedSystem);
                    if (position) {
                        // Show and position selection reticle
                        if (window.starMapState.selectionReticle) {
                            window.starMapState.selectionReticle.position.copy(position);
                            window.starMapState.selectionReticle.visible = true;
                        }

                        // Enable auto-rotation around the selected star
                        window.starMapState.autoRotate = true;

                        // Animate camera
                        window.starMapState.animateCameraToTarget(position, 3000);  // Slower initial animation
                        console.log(`Restoring view to ${selectedSystem}`);
                    }
                }
            }, 1000);  // Wait 1 second for star map to load
        } else if (starSystemRows.length > 0 && !(isViewChange && currentViewType === 'CAMPAIGN_DASHBOARD')) {
            // If no stored selection, select the first system by default (unless we're resetting)
            const firstSystemName = starSystemRows[0].dataset.system;
            starSystemRows[0].classList.add('checked');

            // Populate and show info panel for first system
            if (window.starSystemsData && window.starSystemsData[firstSystemName]) {
                const systemData = window.starSystemsData[firstSystemName];
                const infoPanel = document.getElementById('system-info-panel');
                const infoPanelName = document.getElementById('system-info-name');
                const infoPanelContent = document.getElementById('system-info-content');

                if (infoPanel && infoPanelName && infoPanelContent) {
                    // Build info content HTML
                    let contentHTML = '';

                    if (systemData.type) {
                        contentHTML += '<p><span class="info-label">TYPE:</span> <span class="info-value">' +
                            systemData.type.toUpperCase() + '</span></p>';
                    }
                    if (systemData.description) {
                        contentHTML += '<p><span class="info-label">DESCRIPTION:</span> <span class="info-value">' +
                            systemData.description + '</span></p>';
                    }
                    if (systemData.population) {
                        contentHTML += '<p><span class="info-label">POPULATION:</span> <span class="info-value">' +
                            systemData.population + '</span></p>';
                    }
                    if (systemData.position) {
                        contentHTML += '<p><span class="info-label">COORDINATES:</span> <span class="info-value">' +
                            systemData.position.join(', ') + '</span></p>';
                    }
                    if (systemData.location_slug) {
                        contentHTML += '<p><span class="info-label">LOCATION ID:</span> <span class="info-value">' +
                            systemData.location_slug + '</span></p>';
                    }
                    if (systemData.has_system_map) {
                        contentHTML += '<p><span class="info-label">SYSTEM MAP:</span> <span class="info-value">AVAILABLE</span></p>';
                    }

                    // Update panel with typewriter effect
                    async function initPanel() {
                        infoPanelName.textContent = systemData.name.toUpperCase();
                        await window.typewriteContent(infoPanelContent, contentHTML);
                        infoPanel.classList.add('visible');

                        // Show indicator boxes, rectangle, and triangle
                        const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
                        if (indicatorBoxes) {
                            indicatorBoxes.classList.add('visible');
                        }
                        const rectangle = document.querySelector('.system-info-rectangle');
                        if (rectangle) {
                            rectangle.classList.add('visible');
                        }
                        const triangle = document.querySelector('.system-info-triangle');
                        if (triangle) {
                            triangle.classList.add('visible');
                        }

                        // Position the elements
                        setTimeout(() => {
                            window.updateIndicatorBoxesPosition();
                        }, 50);
                    }

                    initPanel();
                }
            }

            // Animate to first system
            setTimeout(() => {
                if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                    const position = window.starMapState.starPositions.get(firstSystemName);
                    if (position) {
                        // Show and position selection reticle
                        if (window.starMapState.selectionReticle) {
                            window.starMapState.selectionReticle.position.copy(position);
                            window.starMapState.selectionReticle.visible = true;
                        }

                        // Enable auto-rotation around the selected star
                        window.starMapState.autoRotate = true;

                        // Animate camera
                        window.starMapState.animateCameraToTarget(position, 3000);
                        console.log(`Initial view: ${firstSystemName}`);
                    }
                }
            }, 1000);
        }
    })();
    </script>
</body>
</html>
