---
phase: 05-real-time-push-architecture
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - terminal/active_view_store.py
  - terminal/sse_broadcaster.py
  - terminal/migrations/0017_delete_activeview.py
  - terminal/models.py
  - terminal/urls.py
autonomous: true
requirements:
  - RTMA-01
  - RTMA-02
  - RTMA-03
  - RTMA-04

must_haves:
  truths:
    - "In-memory ActiveView state initializes to STANDBY defaults on server start"
    - "SSE broadcaster accumulates per-listener queues and cleans up stale listeners"
    - "GET /api/active-view/stream/ responds with text/event-stream content-type"
    - "First SSE event on connect delivers full current ActiveView state as 'activeview' named event"
    - "Keepalive comment lines sent every 30 seconds to prevent proxy timeout"
    - "ActiveView model is removed from Django and SQLite table dropped"
    - "Message model and SQLite database file retained intact"
  artifacts:
    - path: "terminal/active_view_store.py"
      provides: "Thread-safe in-memory singleton for ActiveView state"
      contains: "def get_state"
    - path: "terminal/sse_broadcaster.py"
      provides: "MessageAnnouncer class with listen/unlisten/announce + format_sse helper"
      contains: "class MessageAnnouncer"
    - path: "terminal/migrations/0017_delete_activeview.py"
      provides: "Django migration that drops the ActiveView table"
      contains: "DeleteModel"
    - path: "terminal/models.py"
      provides: "Message model only — ActiveView class removed"
      contains: "class Message"
  key_links:
    - from: "terminal/sse_broadcaster.py"
      to: "terminal/views.py"
      via: "from terminal.sse_broadcaster import broadcaster, format_sse"
      pattern: "broadcaster\\.announce"
    - from: "terminal/active_view_store.py"
      to: "terminal/views.py"
      via: "from terminal.active_view_store import get_state, update_state"
      pattern: "update_state\\("
    - from: "terminal/urls.py"
      to: "terminal/views.py"
      via: "path('api/active-view/stream/', views.api_active_view_stream)"
      pattern: "api_active_view_stream"
---

<objective>
Create the server-side SSE infrastructure: in-memory ActiveView store, pub/sub broadcaster, SSE streaming endpoint, and Django migration to remove the ActiveView database model.

Purpose: Establishes the foundation for instant push updates — the store replaces the SQLite singleton and the broadcaster pushes to all connected clients when state changes.
Output: Three new Python modules (active_view_store.py, sse_broadcaster.py, migration), models.py cleaned of ActiveView, urls.py with SSE route registered, and a working `GET /api/active-view/stream/` endpoint that streams initial state.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-push-architecture/05-CONTEXT.md
@.planning/phases/05-real-time-push-architecture/05-RESEARCH.md
@terminal/models.py
@terminal/urls.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create active_view_store.py and sse_broadcaster.py</name>
  <files>terminal/active_view_store.py</files>
  <files>terminal/sse_broadcaster.py</files>
  <action>
Create `terminal/active_view_store.py` — thread-safe module singleton that replaces the SQLite ActiveView row:

```python
# terminal/active_view_store.py
import threading

_lock = threading.Lock()

_state: dict = {
    'view_type': 'STANDBY',
    'location_slug': '',
    'view_slug': '',
    'overlay_location_slug': '',
    'overlay_terminal_slug': '',
    'charon_mode': 'DISPLAY',
    'charon_location_path': '',
    'charon_dialog_open': False,
    'charon_active_channel': 'story',
    'encounter_level': 1,
    'encounter_deck_id': '',
    'encounter_room_visibility': {},
    'encounter_door_status': {},
    'encounter_tokens': {},
    'encounter_active_portraits': [],
    'ship_system_overrides': {},
}

def get_state() -> dict:
    with _lock:
        return dict(_state)

def update_state(**kwargs) -> dict:
    with _lock:
        _state.update(kwargs)
        return dict(_state)
```

The `encounter_tokens` default is `{}` (dict keyed by token_id, matching existing pattern). The `encounter_active_portraits` default is `[]` (ordered list of NPC IDs).

Create `terminal/sse_broadcaster.py` — queue-per-listener pub/sub broadcaster:

```python
# terminal/sse_broadcaster.py
import queue
import threading
import json


class MessageAnnouncer:
    def __init__(self):
        self.listeners: list[queue.Queue] = []
        self._lock = threading.Lock()

    def listen(self) -> queue.Queue:
        q = queue.Queue(maxsize=5)
        with self._lock:
            self.listeners.append(q)
        return q

    def unlisten(self, q: queue.Queue) -> None:
        with self._lock:
            try:
                self.listeners.remove(q)
            except ValueError:
                pass

    def announce(self, data: dict) -> None:
        msg = format_sse(json.dumps(data), event='activeview')
        with self._lock:
            listeners = list(self.listeners)
        for i in reversed(range(len(listeners))):
            try:
                listeners[i].put_nowait(msg)
            except queue.Full:
                # Listener not consuming — treat as dead connection, remove
                self.unlisten(listeners[i])


def format_sse(data: str, event: str | None = None) -> str:
    msg = f'data: {data}\n\n'
    if event is not None:
        msg = f'event: {event}\n{msg}'
    return msg


# Module-level singleton — one instance per process
broadcaster = MessageAnnouncer()
```

Note: `announce()` always wraps with `event='activeview'` so the frontend listener registered with `es.addEventListener('activeview', ...)` fires correctly (not the default `onmessage`).
  </action>
  <verify>
```bash
cd /home/gjohnson/mothership/charon
python -c "
from terminal.active_view_store import get_state, update_state
state = get_state()
assert state['view_type'] == 'STANDBY', f'Bad default: {state[\"view_type\"]}'
new_state = update_state(view_type='ENCOUNTER', location_slug='test_location')
assert new_state['view_type'] == 'ENCOUNTER'
assert new_state['location_slug'] == 'test_location'
print('active_view_store: OK')

from terminal.sse_broadcaster import broadcaster, format_sse
q = broadcaster.listen()
broadcaster.announce({'view_type': 'ENCOUNTER'})
msg = q.get_nowait()
assert 'event: activeview' in msg, f'Missing event type in: {msg}'
assert '\"view_type\": \"ENCOUNTER\"' in msg, f'Missing data in: {msg}'
broadcaster.unlisten(q)
print('sse_broadcaster: OK')
"
```
  </verify>
  <done>Both modules import cleanly; get_state returns STANDBY defaults; update_state mutates and returns new state; broadcaster.announce puts formatted SSE message with 'activeview' event type into listener queue; unlisten removes queue cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Remove ActiveView model, create migration, add SSE endpoint to views/urls</name>
  <files>terminal/models.py</files>
  <files>terminal/migrations/0017_delete_activeview.py</files>
  <files>terminal/views.py</files>
  <files>terminal/urls.py</files>
  <action>
**Step A — Create migration `terminal/migrations/0017_delete_activeview.py`:**

Check the latest migration filename first:
```bash
ls terminal/migrations/*.py | grep -v __init__ | sort | tail -3
```
The latest is `0016_add_encounter_active_portraits.py`. Create:

```python
# terminal/migrations/0017_delete_activeview.py
from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ('terminal', '0016_add_encounter_active_portraits'),
    ]

    operations = [
        migrations.DeleteModel(
            name='ActiveView',
        ),
    ]
```

Run migration: `python manage.py migrate terminal`

**Step B — Remove ActiveView from `terminal/models.py`:**

Delete the entire `ActiveView` class (from `class ActiveView(models.Model):` through the final method). Keep the `Message` class and all imports that Message needs. The `User` import must be retained for `Message.created_by` and `Message.recipients` foreign keys.

**Step C — Add SSE streaming view to `terminal/views.py`:**

Add `api_active_view_stream` function. This must be placed BEFORE the existing `get_active_view_json` function. It must NOT import from `terminal.models import ActiveView` (that class no longer exists). Extract the payload-building logic that exists in `get_active_view_json` into a standalone `build_active_view_payload(state: dict) -> dict` helper function that both `get_active_view_json` and `api_active_view_stream` can call.

The `build_active_view_payload` helper replicates the existing `get_active_view_json` response dict logic, accepting a raw `state` dict (from `active_view_store.get_state()`) instead of an `ActiveView` ORM object. Key differences from old code:
- Read fields from `state['field_name']` instead of `active_view.field_name`
- No `updated_at` field in the response (in-memory store has no timestamp; SSE push is the change signal)
- NPC data loading and ENCOUNTER metadata loading remain identical to existing logic

```python
import queue as queue_module
from django.http import StreamingHttpResponse
from terminal.sse_broadcaster import broadcaster, format_sse
from terminal.active_view_store import get_state
import json

def build_active_view_payload(state: dict) -> dict:
    """Build the enriched active-view response dict from raw in-memory state."""
    from terminal.data_loader import DataLoader
    response = {
        'location_slug': state.get('location_slug', ''),
        'view_type': state.get('view_type', 'STANDBY'),
        'view_slug': state.get('view_slug', ''),
        'overlay_location_slug': state.get('overlay_location_slug', ''),
        'overlay_terminal_slug': state.get('overlay_terminal_slug', ''),
        'charon_mode': state.get('charon_mode', 'DISPLAY'),
        'charon_location_path': state.get('charon_location_path', ''),
        'charon_dialog_open': state.get('charon_dialog_open', False),
        'charon_active_channel': state.get('charon_active_channel', 'story'),
        'encounter_level': state.get('encounter_level', 1),
        'encounter_deck_id': state.get('encounter_deck_id', ''),
        'encounter_room_visibility': state.get('encounter_room_visibility', {}),
        'encounter_door_status': state.get('encounter_door_status', {}),
        'encounter_tokens': state.get('encounter_tokens', {}),
        'encounter_active_portraits': list(state.get('encounter_active_portraits', [])),
        'ship_system_overrides': state.get('ship_system_overrides', {}),
    }

    # Always include NPC data (portrait overlay needs it without a second request)
    loader_for_npcs = DataLoader()
    npcs = loader_for_npcs.load_npcs()
    response['encounter_npc_data'] = {
        npc['id']: {'id': npc['id'], 'name': npc['name'], 'portrait': npc.get('portrait', '')}
        for npc in npcs
        if npc.get('id')
    }

    # ENCOUNTER view: include location metadata
    if state.get('view_type') == 'ENCOUNTER' and state.get('location_slug'):
        loader = DataLoader()
        location = loader.find_location_by_slug(state['location_slug'])
        if location:
            response['location_type'] = location.get('type', 'unknown')
            response['location_name'] = location.get('name', '')
            response['location_data'] = location
            location_path = loader.get_location_path(state['location_slug'])
            if location_path:
                response['location_path'] = location_path
                if len(location_path) >= 1:
                    response['location_data']['system_slug'] = location_path[0]
                if len(location_path) >= 2:
                    response['location_data']['parent_slug'] = location_path[0]
            # Multi-deck map loading (copy existing deck-loading logic from get_active_view_json)
            # ... (copy the manifest/deck loading block verbatim from get_active_view_json)

    return response


def api_active_view_stream(request):
    """
    SSE endpoint — streams ActiveView state changes to all connected clients.
    Public endpoint — no login required (same pattern as /api/active-view/).
    """
    def event_stream():
        # Send full current state immediately on connect so client is in sync
        initial_payload = build_active_view_payload(get_state())
        yield format_sse(json.dumps(initial_payload), event='activeview')

        q = broadcaster.listen()
        try:
            while True:
                try:
                    msg = q.get(timeout=30)
                    yield msg
                except queue_module.Empty:
                    yield ': keepalive\n\n'
        finally:
            broadcaster.unlisten(q)

    response = StreamingHttpResponse(event_stream(), content_type='text/event-stream')
    response['Cache-Control'] = 'no-cache'
    response['X-Accel-Buffering'] = 'no'
    return response
```

Also update `get_active_view_json` to use `build_active_view_payload(get_state())` instead of reading from the ORM. This keeps the REST endpoint functional for backward compatibility and for the INITIAL_DATA template pass-through in `display_view_react`.

**Step D — Update `terminal/urls.py`:**

Add one line before the existing `api/active-view/` path:
```python
path('api/active-view/stream/', views.api_active_view_stream, name='active_view_stream'),
```
Place it BEFORE `api/active-view/` to ensure the more specific path matches first (though Django's URL matching is exact, order still matters for readability).

**CRITICAL**: Remove ALL remaining `from terminal.models import ActiveView` imports from views.py. Search for them with grep, replace each with imports from `terminal.active_view_store`. The `display_view_react` and other views that currently call `ActiveView.get_current()` must switch to `get_state()` in this step.

IMPORTANT: `display_view_react` passes `active_view` to the template context. After removing the ORM model, this view must pass the state dict (from `get_state()`) and the template must not call ORM methods. Update `display_view_react` to read from `active_view_store.get_state()` and pass it as a plain dict.
  </action>
  <verify>
```bash
cd /home/gjohnson/mothership/charon
# 1. Migration applied
python manage.py showmigrations terminal | grep 0017

# 2. No ActiveView ORM references remain in views.py
grep -n "from terminal.models import ActiveView\|ActiveView.get_current\|active_view.save()" terminal/views.py && echo "FAIL: ActiveView references remain" || echo "PASS: No ActiveView ORM references"

# 3. SSE endpoint responds correctly (start server in background for this test)
# Manual check: curl -N http://127.0.0.1:8000/api/active-view/stream/ should return:
# event: activeview
# data: {"view_type": "STANDBY", ...}

# 4. Django check passes (catches import errors)
python manage.py check

# 5. Message model still intact
python -c "from terminal.models import Message; print('Message model OK:', Message.__name__)"
```
  </verify>
  <done>Migration 0017 applied (ActiveView table dropped); no `ActiveView` ORM imports remain in views.py; `python manage.py check` passes; `GET /api/active-view/stream/` returns `content-type: text/event-stream`; Message model still importable from terminal.models.</done>
</task>

</tasks>

<verification>
Full foundation check:
```bash
cd /home/gjohnson/mothership/charon

# Python modules OK
python -c "from terminal.active_view_store import get_state, update_state; from terminal.sse_broadcaster import broadcaster, format_sse; print('Modules OK')"

# Migration applied
python manage.py showmigrations terminal

# No ORM leaks
grep -rn "ActiveView" terminal/ --include="*.py" | grep -v migrations | grep -v __pycache__

# Django health
python manage.py check

# SSE URL registered
python manage.py show_urls 2>/dev/null | grep stream || python -c "
from django.urls import reverse
print(reverse('active_view_stream'))
"
```
</verification>

<success_criteria>
- `terminal/active_view_store.py` exists with `get_state()` / `update_state()` returning thread-safe copies
- `terminal/sse_broadcaster.py` exists with `MessageAnnouncer` singleton and `format_sse()` helper
- Migration 0017 applied: `ActiveView` table dropped, `Message` table intact
- `ActiveView` class removed from `terminal/models.py`
- `get_active_view_json` updated to use `build_active_view_payload(get_state())`
- `api_active_view_stream` added and registered at `/api/active-view/stream/`
- `python manage.py check` passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-push-architecture/05-01-SUMMARY.md`
</output>
