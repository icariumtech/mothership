---
phase: 04-npc-portrait-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - terminal/models.py
  - terminal/views.py
  - terminal/urls.py
autonomous: true
requirements:
  - PORT-01
  - PORT-04

must_haves:
  truths:
    - "GM can toggle a portrait via POST to /api/gm/encounter/toggle-portrait/ and get success response"
    - "The /api/active-view/ response always includes encounter_active_portraits (list of NPC IDs) and encounter_npc_data (id->NPC map)"
    - "Switching to a new ENCOUNTER location clears encounter_active_portraits"
  artifacts:
    - path: "terminal/models.py"
      provides: "encounter_active_portraits JSONField on ActiveView"
      contains: "encounter_active_portraits"
    - path: "terminal/views.py"
      provides: "api_encounter_toggle_portrait endpoint and extended active-view response"
      exports: ["api_encounter_toggle_portrait", "get_active_view_json"]
    - path: "terminal/urls.py"
      provides: "URL registration for toggle-portrait"
      contains: "toggle-portrait"
  key_links:
    - from: "terminal/views.py:api_encounter_toggle_portrait"
      to: "terminal/models.py:ActiveView.encounter_active_portraits"
      via: "list append/remove then active_view.save()"
      pattern: "encounter_active_portraits"
    - from: "terminal/views.py:get_active_view_json"
      to: "terminal/data_loader.py:DataLoader.load_npcs"
      via: "always include NPC lookup map in response"
      pattern: "encounter_npc_data"
---

<objective>
Add encounter_active_portraits to the Django backend: a new JSONField on ActiveView, a toggle API endpoint, extension of the active-view poll response to include portrait IDs and NPC data, and portrait reset when switching encounters.

Purpose: The terminal's polling loop needs encounter_active_portraits in every /api/active-view/ response to drive the NPCPortraitOverlay component. The GM needs a POST endpoint to toggle portraits on/off.

Output: Database migration, updated models.py, extended views.py (2 functions modified + 1 new), updated urls.py.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-npc-portrait-system/04-CONTEXT.md
@.planning/phases/04-npc-portrait-system/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add encounter_active_portraits JSONField to ActiveView and generate migration</name>
  <files>terminal/models.py</files>
  <action>
    In terminal/models.py, add a new JSONField to the ActiveView model after the existing encounter_tokens field (around line 102):

    ```python
    encounter_active_portraits = models.JSONField(
        default=list,
        blank=True,
        help_text='Ordered list of NPC IDs currently displayed as portrait overlays'
    )
    ```

    Note: default=list (not default=dict like encounter_tokens) because this is an ordered list of IDs, not a dict.

    After editing models.py, run the Django migration:
    ```bash
    cd /home/gjohnson/mothership/charon && python manage.py makemigrations terminal --name="add_encounter_active_portraits"
    python manage.py migrate
    ```

    Verify migration applied cleanly with no errors.
  </action>
  <verify>
    ```bash
    cd /home/gjohnson/mothership/charon && python manage.py showmigrations terminal | tail -5
    python -c "from terminal.models import ActiveView; av = ActiveView.get_current(); print(av.encounter_active_portraits)"
    ```
    Output should show migration applied and `[]` for encounter_active_portraits.
  </verify>
  <done>migration exists and applies cleanly; ActiveView.encounter_active_portraits returns [] on fresh instance</done>
</task>

<task type="auto">
  <name>Task 2: Add toggle-portrait endpoint, extend active-view response, and register URL</name>
  <files>terminal/views.py, terminal/urls.py</files>
  <action>
    **Part A — Extend get_active_view_json (terminal/views.py)**

    In the `get_active_view_json` function, add portrait state and NPC lookup to the response dict (after the encounter_tokens line, around line 199):

    ```python
    'encounter_tokens': active_view.encounter_tokens or {},
    'encounter_active_portraits': list(active_view.encounter_active_portraits or []),
    ```

    Then, after building the response dict but before the final `return JsonResponse(response)`, add NPC data — always include it (negligible overhead for ~4 NPCs):

    ```python
    # Always include NPC data so portrait overlay has name/image without a second request
    loader_for_npcs = DataLoader()
    npcs = loader_for_npcs.load_npcs()
    encounter_npc_data = {npc['id']: {'id': npc['id'], 'name': npc['name'], 'portrait': npc.get('portrait', '')} for npc in npcs}
    response['encounter_npc_data'] = encounter_npc_data
    ```

    Note: DataLoader is already imported at the top of get_active_view_json. Use a different variable name (loader_for_npcs) to avoid conflict with the existing loader variable used for encounter location loading later in the same function. Alternatively, hoist to the top of the function and reuse the same loader instance.

    **Part B — Add api_encounter_toggle_portrait (terminal/views.py)**

    Add this new view function after the existing encounter token endpoints (e.g., after api_encounter_clear_tokens):

    ```python
    @login_required
    def api_encounter_toggle_portrait(request):
        """
        Toggle an NPC portrait display on the terminal.
        POST: { npc_id: string }
        If npc_id is already in encounter_active_portraits, removes it (dismiss).
        If not, appends it (show).
        """
        from terminal.models import ActiveView
        import json

        if request.method != 'POST':
            return JsonResponse({'error': 'Method not allowed'}, status=405)

        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON'}, status=400)

        npc_id = data.get('npc_id', '').strip()
        if not npc_id:
            return JsonResponse({'error': 'npc_id required'}, status=400)

        active_view = ActiveView.get_current()
        portraits = list(active_view.encounter_active_portraits or [])

        if npc_id in portraits:
            portraits.remove(npc_id)
        else:
            portraits.append(npc_id)

        active_view.encounter_active_portraits = portraits
        active_view.updated_by = request.user
        active_view.save()

        return JsonResponse({
            'success': True,
            'active_portraits': portraits,
        })
    ```

    **Part C — Clear portraits on new encounter location (terminal/views.py)**

    In the `api_switch_view` function, inside the `if is_new_encounter_location:` block (around line 495), after setting `encounter_room_visibility`, also clear portraits:

    ```python
    # Clear portrait overlays when switching to a new encounter location
    active_view.encounter_active_portraits = []
    ```

    Add this line alongside the existing room visibility reset. It should be inside `if is_new_encounter_location:` but NOT inside any nested `if location and location.get('map'):` — portraits should clear unconditionally on new encounter location regardless of whether a map exists.

    **Part D — Register URL (terminal/urls.py)**

    Add the new URL to urlpatterns after the existing encounter token endpoints:

    ```python
    path('api/gm/encounter/toggle-portrait/', views.api_encounter_toggle_portrait, name='encounter_toggle_portrait'),
    ```

    Place it after the `encounter_clear_tokens` line for logical grouping.
  </action>
  <verify>
    ```bash
    cd /home/gjohnson/mothership/charon && python manage.py check
    curl -s http://127.0.0.1:8000/api/active-view/ | python -m json.tool | grep -E "encounter_active_portraits|encounter_npc_data"
    ```
    Response should include both `encounter_active_portraits: []` and `encounter_npc_data: {...}` keys.

    Verify URL registered:
    ```bash
    python manage.py show_urls 2>/dev/null | grep toggle-portrait || python -c "from django.urls import reverse; print(reverse('encounter_toggle_portrait'))"
    ```
  </verify>
  <done>
    - /api/active-view/ response includes encounter_active_portraits (list) and encounter_npc_data (dict of id->NPC)
    - /api/gm/encounter/toggle-portrait/ URL resolves
    - python manage.py check passes with no errors
    - Switching encounter locations clears encounter_active_portraits in api_switch_view
  </done>
</task>

</tasks>

<verification>
1. `python manage.py check` — no errors
2. `python manage.py showmigrations terminal` — new migration applied
3. `curl http://127.0.0.1:8000/api/active-view/` — response JSON contains `encounter_active_portraits` (array) and `encounter_npc_data` (object with NPC IDs as keys)
4. `python -c "from django.urls import reverse; print(reverse('encounter_toggle_portrait'))"` — resolves without error
</verification>

<success_criteria>
- encounter_active_portraits JSONField exists on ActiveView with default=list
- /api/active-view/ always returns encounter_active_portraits and encounter_npc_data
- api_encounter_toggle_portrait adds/removes NPC IDs from the list atomically
- api_switch_view clears encounter_active_portraits when switching to a new encounter location
- No existing tests broken, manage.py check clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-npc-portrait-system/04-01-SUMMARY.md` with what was built, key file paths modified, and any decisions made during implementation.
</output>
