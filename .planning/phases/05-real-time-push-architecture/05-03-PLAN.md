---
phase: 05-real-time-push-architecture
plan: "03"
type: execute
wave: 3
depends_on:
  - "05-02"
files_modified:
  - src/hooks/useSSE.ts
  - src/components/ui/SSEConnectionToast.tsx
  - src/entries/SharedConsole.tsx
  - src/entries/GMConsole.tsx
  - vite.config.ts
autonomous: true
requirements:
  - RTMA-01

must_haves:
  truths:
    - "SharedConsole receives instant ActiveView updates via SSE instead of 2-second polling"
    - "GMConsole receives instant ActiveView updates via SSE instead of 5-second polling"
    - "Both clients silently auto-reconnect on SSE disconnect"
    - "SharedConsole (player terminal) shows connection warning after 5 failed reconnect attempts"
    - "GMConsole shows connection warning after 2 failed reconnect attempts (warns sooner)"
    - "Warning toast auto-dismisses when connection recovers"
    - "On reconnect, client state is immediately in sync (SSE first-event carries full state)"
    - "setInterval polling loops removed from both SharedConsole and GMConsole"
    - "Vite dev proxy passes SSE streaming through without buffering"
  artifacts:
    - path: "src/hooks/useSSE.ts"
      provides: "EventSource lifecycle hook with reconnect tracking and toast trigger"
      exports: ["useSSE"]
    - path: "src/components/ui/SSEConnectionToast.tsx"
      provides: "Connection-lost warning toast component"
      exports: ["SSEConnectionToast"]
    - path: "src/entries/SharedConsole.tsx"
      provides: "SharedConsole using useSSE instead of setInterval"
      contains: "useSSE"
    - path: "src/entries/GMConsole.tsx"
      provides: "GMConsole using useSSE instead of setInterval"
      contains: "useSSE"
  key_links:
    - from: "src/entries/SharedConsole.tsx"
      to: "/api/active-view/stream/"
      via: "useSSE({ url: '/api/active-view/stream/', ... })"
      pattern: "useSSE"
    - from: "src/entries/GMConsole.tsx"
      to: "/api/active-view/stream/"
      via: "useSSE({ url: '/api/active-view/stream/', ... })"
      pattern: "useSSE"
    - from: "src/hooks/useSSE.ts"
      to: "EventSource"
      via: "new EventSource(url)"
      pattern: "new EventSource"
---

<objective>
Build the frontend SSE layer: `useSSE` custom hook wrapping EventSource with reconnect tracking, `SSEConnectionToast` warning component, and replace polling loops in SharedConsole and GMConsole with SSE subscriptions. Fix Vite proxy if it buffers SSE.

Purpose: Completes the real-time pipeline — state changes on the server now flow instantly to all browser clients instead of arriving up to 2 seconds late.
Output: Two new files (useSSE.ts, SSEConnectionToast.tsx), SharedConsole and GMConsole updated to use SSE, Vite proxy configured for streaming passthrough.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-push-architecture/05-CONTEXT.md
@.planning/phases/05-real-time-push-architecture/05-RESEARCH.md
@.planning/phases/05-real-time-push-architecture/05-02-SUMMARY.md
@src/entries/SharedConsole.tsx
@src/entries/GMConsole.tsx
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSSE hook and SSEConnectionToast component</name>
  <files>src/hooks/useSSE.ts</files>
  <files>src/components/ui/SSEConnectionToast.tsx</files>
  <action>
Create `src/hooks/useSSE.ts`:

```typescript
import { useEffect, useRef, useCallback, useState } from 'react';

interface UseSSEOptions {
  url: string;
  onEvent: (data: unknown) => void;
  onConnect?: () => void;     // Called on (re)connect — optional state re-sync
  failureThreshold?: number;  // Consecutive failed reconnects before showing toast
  retryDelayMs?: number;      // Delay between manual reconnect attempts
}

export function useSSE({
  url,
  onEvent,
  onConnect,
  failureThreshold = 3,
  retryDelayMs = 3000,
}: UseSSEOptions) {
  const [connectionLost, setConnectionLost] = useState(false);
  const failureCount = useRef(0);
  const esRef = useRef<EventSource | null>(null);
  const retryTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const connect = useCallback(() => {
    // Close existing connection before opening a new one
    if (esRef.current) {
      esRef.current.close();
      esRef.current = null;
    }
    if (retryTimer.current) {
      clearTimeout(retryTimer.current);
      retryTimer.current = null;
    }

    const es = new EventSource(url);
    esRef.current = es;

    es.onopen = () => {
      failureCount.current = 0;
      setConnectionLost(false);
      onConnect?.();
    };

    // Listen for named 'activeview' events (server sends: event: activeview\ndata: {...})
    es.addEventListener('activeview', (e: MessageEvent) => {
      try {
        onEvent(JSON.parse(e.data));
      } catch {
        console.error('[SSE] Failed to parse activeview event data:', e.data);
      }
    });

    es.onerror = () => {
      // EventSource auto-reconnects, but we manage our own retry for toast tracking
      es.close();
      esRef.current = null;
      failureCount.current += 1;
      if (failureCount.current >= failureThreshold) {
        setConnectionLost(true);
      }
      retryTimer.current = setTimeout(connect, retryDelayMs);
    };
  }, [url, onEvent, onConnect, failureThreshold, retryDelayMs]);

  useEffect(() => {
    connect();
    return () => {
      esRef.current?.close();
      if (retryTimer.current) clearTimeout(retryTimer.current);
    };
  }, [connect]);

  return { connectionLost };
}
```

Note: We use `es.addEventListener('activeview', ...)` (not `es.onmessage`) because the server sends named events (`event: activeview\ndata: {...}`). `onmessage` only fires for unnamed events.

Create `src/components/ui/SSEConnectionToast.tsx`:

```tsx
import React from 'react';

interface SSEConnectionToastProps {
  message?: string;
}

export function SSEConnectionToast({
  message = 'Connection lost — retrying...',
}: SSEConnectionToastProps) {
  return (
    <div
      style={{
        position: 'fixed',
        top: '8px',
        left: '50%',
        transform: 'translateX(-50%)',
        zIndex: 9999,
        backgroundColor: '#5c2a2a',
        border: '1px solid #8b4444',
        color: '#cc7777',
        fontFamily: 'Cascadia Code, monospace',
        fontSize: '12px',
        padding: '6px 16px',
        letterSpacing: '0.08em',
        pointerEvents: 'none',
        whiteSpace: 'nowrap',
      }}
    >
      {message}
    </div>
  );
}
```

Styling rationale: Matches the project's CRT aesthetic (monospace, muted red-amber tones). Fixed positioning at top-center so it doesn't obscure encounter map. `pointerEvents: none` so it doesn't block clicks. No animation — appears/disappears based on `connectionLost` boolean.
  </action>
  <verify>
```bash
cd /home/gjohnson/mothership/charon
npm run typecheck 2>&1 | grep -E "useSSE|SSEConnectionToast|error TS" | head -20
```
Both files must pass TypeScript type checking with no errors.
  </verify>
  <done>src/hooks/useSSE.ts exports useSSE function; src/components/ui/SSEConnectionToast.tsx exports SSEConnectionToast component; both pass TypeScript typecheck with zero errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire useSSE into SharedConsole and GMConsole, fix Vite proxy for SSE</name>
  <files>src/entries/SharedConsole.tsx</files>
  <files>src/entries/GMConsole.tsx</files>
  <files>vite.config.ts</files>
  <action>
**Step A — Fix Vite proxy for SSE streaming (vite.config.ts):**

Vite's default http-proxy may buffer streaming responses. The SSE endpoint must pass through chunk-by-chunk. Update the proxy entry for `/api`:

```typescript
server: {
  port: 5173,
  proxy: {
    '/api': {
      target: 'http://127.0.0.1:8000',
      // No selfHandleResponse — Vite's http-proxy passes streaming through by default
      // but we must not set changeOrigin or compression that could buffer
    },
    '/gmconsole': 'http://127.0.0.1:8000',
  }
}
```

First test by curling the SSE endpoint directly (without Vite proxy) to confirm the Django side works:
```bash
curl -N http://127.0.0.1:8000/api/active-view/stream/
```
Events should arrive immediately. If Vite proxy buffers, add `configure` option:
```typescript
'/api': {
  target: 'http://127.0.0.1:8000',
  configure: (proxy) => {
    proxy.on('proxyRes', (proxyRes) => {
      // Force chunk flushing for SSE
      if (proxyRes.headers['content-type']?.includes('text/event-stream')) {
        proxyRes.headers['x-accel-buffering'] = 'no';
      }
    });
  },
},
```
Only add the `configure` block if the direct test confirms buffering is the problem. Do not add unnecessary complexity if the simple string proxy already works.

**Step B — Update SharedConsole.tsx:**

Read SharedConsole.tsx fully before editing. The key changes:

1. Import useSSE and SSEConnectionToast:
```typescript
import { useSSE } from '@hooks/useSSE';
import { SSEConnectionToast } from '@components/ui/SSEConnectionToast';
```

2. Remove the polling `useEffect` (lines ~297-370 in current file — the `setInterval` that calls `/api/active-view/` every 2000ms). Remove ALL of it including the `return () => clearInterval(pollInterval)` cleanup.

3. Also remove the one-time `fetchActiveView()` useEffect (lines ~268-294) that does the initial fetch on mount — SSE first-event now provides initial state (in addition to `window.INITIAL_DATA`).

4. Add useSSE hook call. The existing polling handler contained complex state-sync logic (CHARON dialog transitions, map mode reset, overlay sync). Move this logic into the `onEvent` callback:

```typescript
const { connectionLost } = useSSE({
  url: '/api/active-view/stream/',
  onEvent: useCallback((rawData: unknown) => {
    const data = rawData as ActiveView;

    // Update encounter tokens if present (skip during in-flight moves)
    if (data.encounter_tokens && !tokenMoveInFlight.current) {
      setEncounterTokens(data.encounter_tokens);
    }

    const previousViewType = activeViewRef.current?.view_type;
    setActiveView(data);

    // CHARON_TERMINAL transition handling
    if (data.view_type === 'CHARON_TERMINAL' && previousViewType !== 'CHARON_TERMINAL') {
      setCharonDialogOpen(true);
      charonApi.toggleDialog(true).catch(console.error);
    } else if (data.view_type !== 'CHARON_TERMINAL' && previousViewType === 'CHARON_TERMINAL') {
      setCharonDialogOpen(false);
      charonApi.toggleDialog(false).catch(console.error);
    } else {
      setCharonDialogOpen(data.charon_dialog_open);
    }

    // Reset map state when transitioning TO BRIDGE
    if (data.view_type === 'BRIDGE' && previousViewType !== 'BRIDGE') {
      setSelectedSystem(null);
      setMapViewMode('galaxy');
      setCurrentSystemSlug(null);
      setSelectedPlanet(null);
      setCurrentBodySlug(null);
      setSelectedOrbitElement(null);
      setSelectedOrbitElementType(null);
      setSelectedOrbitElementData(null);
      setActiveTab('map');
    }

    // Sync terminal overlay
    if (data.overlay_terminal_slug && data.overlay_location_slug) {
      setTerminalOverlayLocation(data.overlay_location_slug);
      setTerminalOverlaySlug(data.overlay_terminal_slug);
      setTerminalOverlayOpen(true);
    } else {
      setTerminalOverlayOpen(false);
    }
  }, [activeView?.view_type, charonDialogOpen, tokenMoveInFlight]),
  failureThreshold: 5,   // Player terminal: more tolerant (5 failures before warning)
  retryDelayMs: 3000,
});
```

IMPORTANT: The old polling used `data.updated_at !== activeView?.updated_at` to guard state updates. SSE pushes only when state changes, so this guard is no longer needed — every SSE event IS a state change. Remove the `updated_at` comparison entirely. All state sync logic runs on every SSE event.

5. Add toast rendering to the JSX. Find the top-level return JSX (the outermost `<div>` or fragment) and add `SSEConnectionToast` as the first child:
```tsx
return (
  <>
    {connectionLost && <SSEConnectionToast />}
    {/* ... existing JSX ... */}
  </>
);
```

**Step C — Update GMConsole.tsx:**

Read GMConsole.tsx fully before editing. Changes:

1. Import useSSE and SSEConnectionToast.

2. Remove the ActiveView `setInterval` polling block (lines ~62-73 in current file — the 5000ms interval that calls `gmConsoleApi.getActiveView()`).

3. Keep the CHARON channel unread polling (the 5s interval for unreads at lines ~76-96) — per CONTEXT.md decision, channel unread polling stays as-is.

4. Also remove the initial `useEffect` that fetches active view on mount (lines ~41-61 if present).

5. Add useSSE hook:
```typescript
const { connectionLost } = useSSE({
  url: '/api/active-view/stream/',
  onEvent: useCallback((rawData: unknown) => {
    setActiveView(rawData as ActiveView);
  }, []),
  failureThreshold: 2,   // GM console: warn sooner (2 failures)
  retryDelayMs: 3000,
});
```

The GMConsole `onEvent` is simpler than SharedConsole — it just sets `activeView`. The GM console doesn't do CHARON dialog auto-transitions or map resets.

6. Add toast to GMConsole JSX (same pattern as SharedConsole).

**Step D — Remove post-write getActiveView() calls from GMConsole callback handlers:**

This is a REQUIRED cleanup step. After removing the polling loop, scan GMConsole.tsx for all remaining `getActiveView()` calls inside callback handlers. These are the pattern:

```typescript
const viewData = await gmConsoleApi.getActiveView();
setActiveView(viewData);
```

This pattern appears in multiple callbacks including: `handleSelectLocation`, `handleEncounter`, `handleShowTerminal`, `handleStandby`, `handleBridge`, `handleCharonActivate`, `handleToggleCharonDialog`, `handleEncounterViewUpdate`, and potentially others.

**Decision: Remove all post-write `getActiveView()` calls.** Rationale: Once SSE is active, the server broadcasts the updated ActiveView to all subscribers immediately after every write operation (05-02 SSE backend ensures this). The `onEvent` callback in `useSSE` will receive the new state automatically, typically within milliseconds. The post-write `getActiveView()` fetch is therefore redundant — it races with the SSE push and causes a duplicate `setActiveView()` call. Removing it is cleaner and eliminates the race condition.

For each affected callback, delete the two-line block:
```typescript
// DELETE these two lines from every callback that has them:
const viewData = await gmConsoleApi.getActiveView();
setActiveView(viewData);
```

If the callback's sole remaining purpose was fetching and setting active view (i.e., the rest of the callback body is empty or already handled by the SSE onEvent), simplify or remove the callback accordingly.

If any callback needs to take a local action immediately (e.g., optimistic UI update before SSE arrives), that is acceptable — but `getActiveView()` + `setActiveView()` is not needed for that; use local state directly.

After editing, the only remaining `getActiveView` call in GMConsole.tsx should be none — or, if one is needed for an initial page-load fallback before SSE first-event arrives, document it with a comment:
```typescript
// One-time initial load fallback: SSE first-event will also deliver state,
// but this ensures state is set if the SSE connection is slow to open.
```

**IMPORTANT — `useCallback` stability for `onEvent`:** The `onEvent` callback in SharedConsole captures `activeView?.view_type` and `charonDialogOpen` in its closure. Wrap with `useCallback` and include these in the dependency array. This means `useSSE`'s `connect` function will also re-create when they change. To prevent reconnect storms, ensure the `useSSE` hook's `connect` function is wrapped with `useCallback` (it already is in the hook implementation — `connect` only changes when its own deps change, not when component state changes). The `useEffect` in useSSE depends on `connect`, so it will re-subscribe if `onEvent` changes. To avoid this, lift the state reads out of the callback using refs:

In SharedConsole, add refs for the values needed in the SSE callback:
```typescript
const activeViewRef = useRef(activeView);
useEffect(() => { activeViewRef.current = activeView; }, [activeView]);
const charonDialogOpenRef = useRef(charonDialogOpen);
useEffect(() => { charonDialogOpenRef.current = charonDialogOpen; }, [charonDialogOpen]);
```
Then in the `onEvent` callback, read from refs instead of captured state:
```typescript
const previousViewType = activeViewRef.current?.view_type;
// ... rest of logic
```
This way `onEvent` has no deps that change → `useCallback` has `[]` deps → `connect` is stable → no reconnect storms.
  </action>
  <verify>
```bash
cd /home/gjohnson/mothership/charon

# 1. TypeScript compiles
npm run typecheck 2>&1 | grep -E "error TS" | head -20

# 2. No setInterval polling remains in SharedConsole or GMConsole (for active-view)
grep -n "setInterval\|clearInterval" src/entries/SharedConsole.tsx
grep -n "setInterval\|clearInterval" src/entries/GMConsole.tsx
# Only the CHARON unread poll in GMConsole should remain

# 3. useSSE is wired in both files
grep -n "useSSE" src/entries/SharedConsole.tsx
grep -n "useSSE" src/entries/GMConsole.tsx

# 4. SSEConnectionToast is rendered in both files
grep -n "SSEConnectionToast" src/entries/SharedConsole.tsx
grep -n "SSEConnectionToast" src/entries/GMConsole.tsx

# 5. Post-write getActiveView() calls removed from GMConsole callbacks
# Expected: zero matches (or one commented initial-load fallback if intentionally kept)
grep -n "getActiveView" src/entries/GMConsole.tsx
# If any matches remain, confirm each is intentional (not a post-write redundant fetch)

# 6. Build succeeds
npm run build 2>&1 | tail -10
```
  </verify>
  <done>TypeScript typecheck passes with zero errors; no active-view setInterval polling remains in SharedConsole or GMConsole; useSSE used in both files with correct failureThreshold (5 for player, 2 for GM); SSEConnectionToast renders in both; all post-write getActiveView() calls removed from GMConsole callback handlers (grep confirms zero remaining or documents any intentional exception); npm run build succeeds.</done>
</task>

</tasks>

<verification>
End-to-end SSE validation (requires running Django server):
```bash
cd /home/gjohnson/mothership/charon

# 1. TypeScript check
npm run typecheck 2>&1 | grep "error TS" | wc -l
# Expected: 0

# 2. Build check
npm run build 2>&1 | grep -E "error|Error" | grep -v "// error" | head -5

# 3. Direct SSE stream test (start server separately, run in another terminal)
# curl -N http://127.0.0.1:8000/api/active-view/stream/
# Expected first 3 lines:
# event: activeview
# data: {"view_type": "STANDBY", ...}
# (blank line)
# Then: ': keepalive' every 30 seconds

# 4. Polling removal confirmed
grep -c "setInterval" src/entries/SharedConsole.tsx
# Expected: 1 (only the bridge messages poll, not active-view poll)
grep -c "setInterval" src/entries/GMConsole.tsx
# Expected: 1 (only the CHARON unread poll)

# 5. Post-write fetch cleanup confirmed
grep -n "getActiveView" src/entries/GMConsole.tsx
# Expected: 0 lines (all post-write redundant fetches removed)
```
</verification>

<success_criteria>
- `src/hooks/useSSE.ts` exports `useSSE` with EventSource lifecycle, reconnect counter, `connectionLost` state
- `src/components/ui/SSEConnectionToast.tsx` exports `SSEConnectionToast` with fixed-top-center positioning
- SharedConsole uses `useSSE({ url: '/api/active-view/stream/', failureThreshold: 5 })`
- GMConsole uses `useSSE({ url: '/api/active-view/stream/', failureThreshold: 2 })`
- Active-view `setInterval` polling removed from both files
- All post-write `getActiveView()` + `setActiveView()` calls removed from GMConsole callback handlers (SSE delivers state automatically)
- `npm run typecheck` zero errors
- `npm run build` succeeds
- Vite proxy configured to pass SSE through without buffering
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-push-architecture/05-03-SUMMARY.md`
</output>
