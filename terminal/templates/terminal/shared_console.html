<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MOTHERSHIP TERMINAL</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        /* V2-1 Color Palette */
        :root {
            --color-teal: #4a6b6b;
            --color-teal-bright: #5a7a7a;
            --color-amber: #8b7355;
            --color-amber-bright: #9a8065;
            --color-bg-primary: #0a0a0a;
            --color-bg-secondary: #1a1a1a;
            --color-bg-panel: #1a2525;
            --color-bg-panel-dark: #0f1515;
            --color-text-primary: #9a9a9a;
            --color-text-secondary: #7a7a7a;
            --color-text-muted: #5a5a5a;
            --color-border-main: #4a6b6b;
            --color-border-subtle: #2a3a3a;
            --color-active: #8b7355;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000; /* Black to match star map canvas */
            color: var(--color-text-primary);
            font-family: 'Cascadia Code', 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Scanline overlay - covers entire screen */
        .scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        /* ===================
           TERMINAL HEADER
           =================== */
        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 52px;
            padding: 0 40px 0 22px;
            background-color: #1a2828;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 1px,
                rgba(0, 0, 0, 0.3) 1px,
                rgba(0, 0, 0, 0.3) 2px
            );
            border-bottom: 1px solid var(--color-border-subtle);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .terminal-header-left {
            display: flex;
            gap: 20px;
            align-items: baseline;
        }

        .terminal-header h1 {
            font-size: 18px;
            letter-spacing: 3px;
            color: #5a7575;
            margin: 0;
            font-weight: normal;
            font-family: 'Cascadia Code', 'Courier New', monospace;
        }

        .terminal-header .subtitle {
            font-size: 18px;
            letter-spacing: 3px;
            color: #5a7575;
            margin: 0;
            font-weight: normal;
            font-family: 'Cascadia Code', 'Courier New', monospace;
        }

        .terminal-header-right {
            font-size: 11px;
            letter-spacing: 3px;
            color: #8b7355;
            font-family: 'Cascadia Code', 'Courier New', monospace;
        }

        /* Hide header in standby mode */
        body.standby-mode .terminal-header {
            display: none;
        }

        /* ===================
           STANDBY VIEW
           =================== */
        .standby-view {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            background-color: #2b2b2b; /* Charcoal background */
        }

        .standby-logo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .standby-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 96px;
            font-weight: 900;
            letter-spacing: 16px;
            color: #e0e0e0;
            text-align: center;
            opacity: 0.9;
            animation: aggressiveGlitch 3s infinite;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            /* CSS variables for random glitch direction */
            --glitch-x1: -35px;
            --glitch-y1: 0px;
            --glitch-x2: 30px;
            --glitch-y2: 0px;
            --glitch-x3: -20px;
            --glitch-y3: 0px;
        }

        .standby-subtitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 8px;
            color: #8b7355;
            text-align: center;
            opacity: 0.8;
            text-shadow: 0 0 15px rgba(139, 115, 85, 0.4);
            animation: aggressiveGlitch 3s infinite;
            animation-delay: 1.5s; /* Offset by half cycle so it glitches at different time */
            /* CSS variables for random glitch direction */
            --glitch-x1: -35px;
            --glitch-y1: 0px;
            --glitch-x2: 30px;
            --glitch-y2: 0px;
            --glitch-x3: -20px;
            --glitch-y3: 0px;
        }

        /* Aggressive random glitch effect with motion blur */
        @keyframes aggressiveGlitch {
            0%, 88%, 90%, 92%, 100% {
                transform: translate(0, 0) skewX(0deg);
                filter: brightness(1) blur(0px);
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            }
            89% {
                transform: translate(var(--glitch-x1), var(--glitch-y1)) skewX(-5deg);
                filter: brightness(1.3) contrast(1.2) blur(1.5px);
                text-shadow:
                    -5px 0 10px rgba(255, 0, 0, 0.5),
                    5px 0 10px rgba(0, 255, 255, 0.5),
                    -10px 0 15px rgba(255, 0, 0, 0.3),
                    -15px 0 20px rgba(255, 0, 0, 0.2),
                    -20px 0 25px rgba(255, 0, 0, 0.1);
            }
            89.5% {
                transform: translate(var(--glitch-x2), var(--glitch-y2)) skewX(5deg);
                filter: brightness(0.7) contrast(1.5) blur(1.5px);
                text-shadow:
                    5px 0 10px rgba(0, 255, 0, 0.5),
                    -5px 0 10px rgba(255, 0, 255, 0.5),
                    10px 0 15px rgba(0, 255, 0, 0.3),
                    15px 0 20px rgba(0, 255, 0, 0.2),
                    20px 0 25px rgba(0, 255, 0, 0.1);
            }
            91% {
                transform: translate(var(--glitch-x3), var(--glitch-y3)) skewX(3deg);
                filter: brightness(1.4) blur(1px);
                text-shadow:
                    0 0 30px rgba(255, 255, 255, 0.6),
                    -10px 0 20px rgba(255, 255, 255, 0.3),
                    -15px 0 25px rgba(255, 255, 255, 0.2);
            }
        }

        /* Random text blocks that appear around the screen */
        .text-block {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: white;
            white-space: pre-line;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 6s ease-in-out forwards;
            mask-image: radial-gradient(ellipse 100% 100% at 50% 50%, black 30%, transparent 80%);
            -webkit-mask-image: radial-gradient(ellipse 100% 100% at 50% 50%, black 30%, transparent 80%);
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            80% {
                opacity: 0.7;
            }
            100% {
                opacity: 0;
            }
        }

        /* ===================
           CAMPAIGN DASHBOARD VIEW
           =================== */

        /* STEP 1: GRID LAYOUT
           Easy to modify panel positions and sizes here! */
        .campaign-dashboard {
            width: 100vw;
            height: 100vh;
            background-color: transparent;
            display: grid;
            /* COLUMNS: left-width | center-width | right-width */
            grid-template-columns: 300px 1fr 300px;
            /* ROWS: top-height | main-height */
            grid-template-rows: 52px 1fr;
            /* NAME each grid area */
            grid-template-areas:
                "top-left top-center top-right"
                "left center right";
            gap: 30px;
            padding: 0 30px 30px 30px;  /* 30px spacing from edges (top right bottom left) */
        }

        /* STEP 2: PANEL POSITIONING
           Just assign grid-area + specific sizing */
        .dashboard-top {
            grid-area: top-center;
            width: 25vw;  /* Top panel width */
            justify-self: center;
        }

        .dashboard-left {
            grid-area: left;
            display: grid;
            grid-template-rows: 1fr 1fr;  /* Two equal-height panels */
            gap: 30px;  /* 30px between panels */
            min-height: 0;  /* Allow grid children to shrink below content size */
        }

        .dashboard-right {
            grid-area: right;
            display: grid;
            grid-template-rows: 1fr 1fr;  /* Two equal-height panels */
            gap: 30px;  /* 30px between panels */
            min-height: 0;  /* Allow grid children to shrink below content size */
        }

        /* STEP 3: REUSABLE PANEL STYLING */

        /* Base panel appearance */
        .panel-base {
            background-color: var(--color-bg-panel);
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 0;  /* Allow grid/flex children to shrink below content size */
        }

        /* Chamfered corner utilities (mix and match!) */
        .chamfer-tl {  /* Top-left chamfer */
            clip-path: polygon(
                12px 0, 100% 0, 100% 100%, 0 100%, 0 12px
            );
        }

        .chamfer-tr {  /* Top-right chamfer */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0, 100% 12px, 100% 100%, 0 100%
            );
        }

        .chamfer-bl {  /* Bottom-left chamfer */
            clip-path: polygon(
                0 0, 100% 0, 100% 100%, 12px 100%, 0 calc(100% - 12px)
            );
        }

        .chamfer-br {  /* Bottom-right chamfer */
            clip-path: polygon(
                0 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%
            );
        }

        .chamfer-tr-br {  /* Top-right + Bottom-right */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0,
                100% 12px, 100% calc(100% - 12px),
                calc(100% - 12px) 100%, 0 100%
            );
        }

        .chamfer-tl-bl {  /* Top-left + Bottom-left */
            clip-path: polygon(
                12px 0, 100% 0,
                100% 100%, 12px 100%,
                0 calc(100% - 12px), 0 12px
            );
        }

        .chamfer-bl-br {  /* Bottom-left + Bottom-right */
            clip-path: polygon(
                0 0, 100% 0,
                100% calc(100% - 12px), calc(100% - 12px) 100%,
                12px 100%, 0 calc(100% - 12px)
            );
        }

        .chamfer-tl-tr {  /* Top-left + Top-right */
            clip-path: polygon(
                0 12px, 12px 0,
                calc(100% - 12px) 0, 100% 12px,
                100% 100%, 0 100%
            );
        }

        .chamfer-tr-bl {  /* Top-right + Bottom-left */
            clip-path: polygon(
                0 0, calc(100% - 12px) 0,
                100% 12px, 100% 100%,
                12px 100%, 0 calc(100% - 12px)
            );
        }

        .chamfer-tl-br {  /* Top-left + Bottom-right */
            clip-path: polygon(
                12px 0, 100% 0,
                100% calc(100% - 12px), calc(100% - 12px) 100%,
                0 100%, 0 12px
            );
        }

        /* Border utilities */
        .border-top    { box-shadow: inset 0 2px 0 0 var(--color-border-main); }
        .border-right  { box-shadow: inset -2px 0 0 0 var(--color-border-main); }
        .border-bottom { box-shadow: inset 0 -2px 0 0 var(--color-border-main); }
        .border-left   { box-shadow: inset 2px 0 0 0 var(--color-border-main); }

        /* All borders */
        .border-all {
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        /* Combine borders (common combinations) */
        .border-inner-top-right-bottom {  /* All except left */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main);
        }

        .border-inner-top-left-bottom {  /* All except right */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main);
        }

        .border-inner-left-right-bottom {  /* All except top */
            box-shadow:
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .border-inner-top-left-right {  /* All except bottom */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        /* Diagonal corner lines */
        .corner-line-tl::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr::before {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-bl::after {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* For panels with 2 diagonal corners, use pseudo-classes */
        .corner-line-tr-br::before {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-bl::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-bl::after {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-bl-br::before {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-bl-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-tr::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-tr::after {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr-bl::before {  /* Top-right */
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tr-bl::after {  /* Bottom-left */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom left,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-br::before {  /* Top-left */
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .corner-line-tl-br::after {  /* Bottom-right */
            content: '';
            position: absolute;
            bottom: 0; right: 0;
            width: 12px; height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        /* Panel-specific styles */
        .dashboard-top {
            align-items: center;
            justify-content: center;
        }

        .dashboard-top-content {
            color: var(--color-teal);
            font-size: 18px;
            letter-spacing: 3px;
        }

        /* Panel Headers */
        .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 13px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 10px 5px 10px;
            border-bottom: 1px solid var(--color-border-subtle);
        }

        /* Adjust h3 padding for chamfered corners */
        .chamfer-tr .dashboard-panel-header h3,
        .chamfer-tr-br .dashboard-panel-header h3 {
            padding-right: 22px; /* 10px base + 12px for corner */
        }

        .chamfer-tl .dashboard-panel-header h3,
        .chamfer-tl-bl .dashboard-panel-header h3,
        .chamfer-tl-tr .dashboard-panel-header h3 {
            padding-left: 22px; /* 10px base + 12px for corner */
        }

        .chamfer-tl-tr .dashboard-panel-header h3 {
            padding-right: 22px; /* Both corners */
        }

        /* Panel Content Areas */
        .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            margin-bottom: 2px;
            margin-left: 2px;
            margin-right: 2px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            color: var(--color-text-primary);
            font-size: 12px;
            line-height: 1.6;
        }

        /* Scrollbar styling */
        .dashboard-panel-content::-webkit-scrollbar {
            width: 10px;
        }

        .dashboard-panel-content::-webkit-scrollbar-track {
            background: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            border: none;
            margin-top: 2px;
            margin-bottom: 2px;
        }

        .dashboard-panel-content::-webkit-scrollbar-thumb {
            background: #0f1515;
            border: 1px solid #4a6b6b;
        }

        .dashboard-panel-content::-webkit-scrollbar-thumb:hover {
            background: #1a2525;
        }

        .dashboard-panel-content::-webkit-scrollbar-button {
            display: none;
        }

        /* Right panel subsections */
        .right-section {
            background-color: var(--color-bg-panel-dark);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .right-section .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .right-section .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 11px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 22px 5px 22px;
            border-bottom: 1px solid var(--color-border-subtle);
        }

        .right-section .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            margin: 2px 5px 2px 2px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
            color: var(--color-text-primary);
            font-size: 11px;
            line-height: 1.6;
        }

        /* Star system buttons */
        /* Star system buttons - styled like GM console location rows */
        .star-system-row {
            display: flex;
            align-items: center;
            padding: 0;
            margin: 4px 0;
            border: 1px solid var(--color-border-subtle);
            background-color: var(--color-bg-primary);
            transition: all 0.2s;
        }

        .star-system-row:hover {
            background-color: var(--color-bg-panel-dark);
        }

        .star-system-row.checked {
            border-color: var(--color-active);
            background-color: var(--color-bg-panel-dark);
        }

        .star-system-content {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 8px 6px;
            cursor: pointer;
        }

        .star-system-checkbox {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            border: 1px solid var(--color-teal);
            background-color: var(--color-bg-primary);
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            border-radius: 50%;  /* Make it circular like a radio button */
        }

        .star-system-row.checked .star-system-checkbox {
            background-color: var(--color-active);
            border-color: var(--color-active);
        }

        .star-system-checkbox::after {
            content: '●';
            color: var(--color-bg-primary);
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .star-system-row.checked .star-system-checkbox::after {
            opacity: 1;
        }

        .star-system-name {
            color: var(--color-teal-bright);
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 0.5px;
            flex-grow: 1;
            user-select: none;
        }

        /* System map button for star systems */
        .system-map-btn-container {
            flex-shrink: 0;
            background-color: var(--color-bg-panel-dark);
            border-left: 1px solid var(--color-border-subtle);
            padding: 8px 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 48px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .system-map-btn-container:hover {
            background-color: var(--color-bg-panel);
        }

        .system-map-btn-icon {
            color: var(--color-teal);
            font-size: 16px;
        }

        /* Momentary flash effect for system map button */
        @keyframes flash-system-map {
            0% {
                background-color: var(--color-active);
            }
            100% {
                background-color: var(--color-bg-panel-dark);
            }
        }

        .system-map-btn-container.flashing {
            animation: flash-system-map 0.5s ease-out;
        }

        .system-map-btn-container.flashing .system-map-btn-icon {
            animation: flash-system-map-icon 0.5s ease-out;
        }

        @keyframes flash-system-map-icon {
            0% {
                color: var(--color-bg-primary);
            }
            100% {
                color: var(--color-teal);
            }
        }

        /* System Info Panel */
        .system-info-panel {
            position: absolute;
            right: calc(300px + 30px + 30px);  /* right panel width + gap + margin */
            top: 82px;  /* 52px header + 30px gap to align with star map panel */
            width: 350px;
            height: auto;  /* Dynamic height based on content */
            max-height: calc(100vh - 82px - 30px);  /* Don't exceed viewport minus top offset and bottom margin */
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            background-color: var(--color-bg-panel);
            display: flex;
            flex-direction: column;

            /* Larger bottom-right chamfer (48px), keep top-left at 12px */
            clip-path: polygon(
                12px 0, 100% 0,
                100% calc(100% - 48px), calc(100% - 48px) 100%,
                0 100%, 0 12px
            );

            /* Borders using box-shadow to prevent clipping */
            box-shadow:
                inset 0 2px 0 0 var(--color-border-main),
                inset -2px 0 0 0 var(--color-border-main),
                inset 0 -2px 0 0 var(--color-border-main),
                inset 2px 0 0 0 var(--color-border-main);
        }

        .system-info-panel.visible {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .system-info-panel .dashboard-panel-header {
            padding: 12px 2px 0 2px;
            flex-shrink: 0;
        }

        .system-info-panel .dashboard-panel-header h3 {
            color: var(--color-teal);
            font-size: 13px;
            letter-spacing: 2px;
            margin: 0;
            padding: 0 10px 5px 22px;  /* Extra left padding to avoid top-left chamfer */
            border-bottom: 1px solid var(--color-border-subtle);
        }

        .system-info-panel .dashboard-panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            margin: 2px 5px 2px 2px;
            background-color: #171717;
            background-image: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 2px,
                #1a1a1a 2px,
                #1a1a1a 3px
            );
        }

        #system-info-content {
            line-height: 1.8;
        }

        #system-info-content p {
            margin: 8px 0;
            color: var(--color-text-primary);
            font-size: 12px;
        }

        #system-info-content .info-label {
            color: var(--color-teal);
            font-weight: bold;
            letter-spacing: 1px;
        }

        #system-info-content .info-value {
            color: var(--color-amber);
        }

        /* Indicator boxes along bottom of system info panel */
        .system-info-indicator-boxes {
            position: absolute;
            right: calc(300px + 30px + 30px + 58px);  /* Panel right + space for chamfer (48px) + margin (10px) */
            width: 278px;  /* Exactly 12 boxes: (12 × 14px boxes) + (11 × 10px gaps) = 278px */
            height: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: repeating-linear-gradient(
                to right,
                #6b4a4a 0px,  /* Muted burgundy/wine color */
                #6b4a4a 14px,
                transparent 14px,
                transparent 24px
            );
            pointer-events: none;
        }

        .system-info-indicator-boxes.visible {
            opacity: 0.7;
        }

        /* Rectangle decoration extending from boxes to panel edge */
        .system-info-rectangle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            height: 14px;  /* Same height as indicator boxes */
            background-color: #6b4a4a;
        }

        .system-info-rectangle.visible {
            opacity: 0.6;
        }

        /* Triangle decoration on top of rectangle */
        .system-info-triangle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            height: 35px;  /* Triangle height */
            background-color: #6b4a4a;
            clip-path: polygon(0 100%, 100% 100%, 100% 0);  /* Right triangle: bottom-left, bottom-right, top-right */
        }

        .system-info-triangle.visible {
            opacity: 0.6;
        }

        /* Top-left corner line (12px) */
        .system-info-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
            z-index: 1;
        }

        /* Bottom-right corner line (48px) */
        .system-info-panel::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 48px;
            height: 48px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
            z-index: 1;
        }

        /* ===================
           ENCOUNTER MAP VIEW
           =================== */
        .map-view {
            width: 100vw;
            height: 100vh;
            background-color: var(--color-bg-primary);
            padding: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .map-header {
            color: var(--color-teal);
            font-size: 20px;
            letter-spacing: 3px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--color-border-main);
        }

        .map-info-bar {
            display: flex;
            justify-content: space-between;
            color: var(--color-text-secondary);
            font-size: 11px;
            letter-spacing: 1px;
            padding-bottom: 10px;
        }

        .map-container {
            flex: 1;
            background-color: var(--color-bg-panel-dark);
            border: 2px solid var(--color-border-main);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            clip-path: polygon(
                12px 0, 100% 0, 100% calc(100% - 12px),
                calc(100% - 12px) 100%, 0 100%, 0 12px
            );
            position: relative;
        }

        .map-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .no-map-message {
            color: var(--color-text-muted);
            font-size: 14px;
            letter-spacing: 2px;
            text-align: center;
        }

        /* Corner diagonal lines for angular panels */
        .map-container::before,
        .map-container::after,
        .dashboard-panel::before,
        .dashboard-panel::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: linear-gradient(
                to bottom right,
                transparent calc(50% - 2px),
                var(--color-border-main) calc(50% - 2px),
                var(--color-border-main) calc(50% + 2px),
                transparent calc(50% + 2px)
            );
        }

        .map-container::before {
            top: 0;
            left: 0;
        }

        .map-container::after {
            bottom: 0;
            right: 0;
        }

        /* 3D Star Map Background */
        #starmap-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;  /* Background layer */
            background-color: #000000;
        }

        /* 3D System Map Background */
        #systemmap-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;  /* Background layer */
            background-color: #000000;
        }

        /* Ensure all view content is above the star map */
        .standby-view,
        .campaign-dashboard,
        .map-container,
        .terminal-view {
            position: relative;
            z-index: 10;
        }

        .scanline-overlay {
            z-index: 100;  /* Scanlines on top of everything */
        }
    </style>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body{% if active_view.view_type == 'STANDBY' %} class="standby-mode"{% endif %}>
    <!-- Terminal Header -->
    <div class="terminal-header">
        <div class="terminal-header-left">
            <h1>MOTHERSHIP TERMINAL SYSTEM</h1>
            <div class="subtitle"></div>
        </div>
        <div class="terminal-header-right">
            STATION ACCESS
        </div>
    </div>

    <!-- 3D Star Map Background Canvas -->
    <canvas id="starmap-canvas"></canvas>

    <!-- 3D System Map Canvas (shown when viewing individual star systems) -->
    <canvas id="systemmap-canvas" style="display: none;"></canvas>

    <!-- Scanline overlay covers entire screen -->
    <div class="scanline-overlay"></div>

    <!-- STANDBY VIEW -->
    {% if active_view.view_type == 'STANDBY' %}
    <div class="standby-view" id="standby-container">
        <div class="standby-logo">
            <div class="standby-text" data-text="MOTHERSHIP">MOTHERSHIP</div>
            <div class="standby-subtitle">The Outer Veil</div>
        </div>
    </div>

    <script>
    // Randomize glitch direction on each animation iteration
    (function() {
        const mainText = document.querySelector('.standby-text');
        const subtitle = document.querySelector('.standby-subtitle');

        function randomizeGlitchDirection(element) {
            // Random displacement between -35px and 35px
            const x1 = (Math.random() * 70 - 35).toFixed(0);
            const y1 = (Math.random() * 40 - 20).toFixed(0); // Less vertical range
            const x2 = (Math.random() * 60 - 30).toFixed(0);
            const y2 = (Math.random() * 40 - 20).toFixed(0);
            const x3 = (Math.random() * 40 - 20).toFixed(0);
            const y3 = (Math.random() * 30 - 15).toFixed(0);

            element.style.setProperty('--glitch-x1', `${x1}px`);
            element.style.setProperty('--glitch-y1', `${y1}px`);
            element.style.setProperty('--glitch-x2', `${x2}px`);
            element.style.setProperty('--glitch-y2', `${y2}px`);
            element.style.setProperty('--glitch-x3', `${x3}px`);
            element.style.setProperty('--glitch-y3', `${y3}px`);
        }

        // Randomize on animation iteration (each time animation completes a cycle)
        if (mainText) {
            mainText.addEventListener('animationiteration', () => {
                randomizeGlitchDirection(mainText);
            });
            // Randomize on load
            randomizeGlitchDirection(mainText);
        }

        if (subtitle) {
            subtitle.addEventListener('animationiteration', () => {
                randomizeGlitchDirection(subtitle);
            });
            // Randomize on load
            randomizeGlitchDirection(subtitle);
        }
    })();

    // Random text blocks generator for STANDBY view
    (function() {
        const container = document.getElementById('standby-container');
        if (!container) return;

        // Track active blocks for collision detection
        const activeBlocks = [];

        // Individual line snippets (will be randomly combined)
        const lineSnippets = [
            'SYSTEM ONLINE', 'ALL SYSTEMS NOMINAL', 'STANDBY MODE', 'AWAITING ORDERS',
            'QUANTUM FLUX DETECTED', 'STABILIZING FIELD', 'NEURAL INTERFACE ACTIVE',
            'SYNAPTIC LINK STABLE', 'BIOMETRIC SCAN COMPLETE', 'IDENTITY CONFIRMED',
            'HULL INTEGRITY: 98%', 'MINOR BREACH SEALED', 'LIFE SUPPORT: NOMINAL',
            'O2 LEVELS: OPTIMAL', 'REACTOR CORE: STABLE', 'POWER OUTPUT: 100%',
            'NAVIGATION READY', 'COORDINATES LOCKED', 'COMMS ARRAY: ONLINE',
            'SIGNAL STRENGTH: FULL', 'SENSOR SWEEP: CLEAR', 'NO CONTACTS DETECTED',
            'ENGINES: IDLE', 'FUEL: 87%', 'CARGO BAY: SECURE', 'CONTAINMENT HOLDING',
            'ATMOSPHERIC PRESSURE: STABLE', 'GRAVITY: 1.0G', 'SCANNING...',
            'ANALYSIS IN PROGRESS', 'PROCESSING...', 'DECRYPTING DATA',
            'INITIALIZING...', 'BOOT SEQUENCE ACTIVE', 'CRYO BAY: EMPTY',
            'ALL PODS DORMANT', 'MEDICAL: STANDBY', 'AUTO-DOC READY',
            'WEAPONS: OFFLINE', 'SAFETY PROTOCOLS ENGAGED', 'SHIELDS: CHARGING',
            '42% CAPACITY', 'JUMP DRIVE: READY', 'FTL AVAILABLE',
            'RADIATION LEVELS: SAFE', 'DOSE: 0.3 mSv', 'TARGETING SYSTEMS: OFFLINE',
            'PEACE MODE ACTIVE', 'DRONE BAY: SEALED', '3 UNITS READY',
            'MINING LASER: STANDBY', 'CAPACITOR CHARGED', 'EMERGENCY BEACON: ACTIVE',
            'BROADCASTING SOS', 'WARP CORE: STABLE', 'CONTAINMENT AT 100%',
            'AIRLOCK STATUS: SECURE', 'PRESSURE NOMINAL', 'LABORATORY: SEALED',
            'QUARANTINE ACTIVE', 'BRIDGE ACCESS: GRANTED', 'WELCOME COMMANDER',
            'UNKNOWN SIGNAL DETECTED', 'TRACKING SOURCE', 'HEAT SIGNATURE: ANOMALOUS',
            'INVESTIGATING', 'PROXIMITY ALERT', 'OBJECT AT 200M',
            'SYSTEM DIAGNOSTICS COMPLETE', 'NO ERRORS FOUND', 'FIRMWARE UPDATE AVAILABLE',
            'VERSION 3.7.2', 'BACKUP POWER: 100%', 'BATTERIES FULL',
            'WASTE RECYCLING: ACTIVE', 'EFFICIENCY: 94%', 'FOOD STORES: ADEQUATE',
            '142 DAYS REMAINING', 'WATER PURIFICATION: ONLINE', 'RESERVES: 89%',
            'SUIT TELEMETRY: NOMINAL', 'ALL CREW ACCOUNTED FOR', 'BLACK BOX: RECORDING',
            'FLIGHT DATA LOGGED', 'AUTO-PILOT: ENGAGED', 'COURSE LOCKED',
            'STELLAR CARTOGRAPHY', 'MAP UPDATE: 99%', 'ANOMALY DETECTED',
            'CLASSIFICATION: UNKNOWN', 'TEMPORAL DRIFT: MINIMAL', 'CHRONOMETER SYNCED',
            'EXOTIC MATTER: DETECTED', 'ANALYSIS PENDING', 'VOID EXPOSURE: MINIMAL',
            'CREW SAFETY: GREEN', 'DARK MATTER READINGS', 'THRESHOLD EXCEEDED',
            'SUBSPACE INTERFERENCE', 'COMPENSATING', 'ALIEN ARTIFACT DETECTED',
            'ORIGIN: UNKNOWN', 'DISTRESS CALL RECEIVED', 'INVESTIGATING TRANSMISSION'
        ];

        function getRandomLines() {
            // Random number of lines (1-4)
            const lineCount = Math.floor(Math.random() * 4) + 1;
            const selectedLines = [];

            // Pick random lines without repetition
            const availableLines = [...lineSnippets];
            for (let i = 0; i < lineCount; i++) {
                const randomIndex = Math.floor(Math.random() * availableLines.length);
                selectedLines.push('> ' + availableLines[randomIndex]);
                availableLines.splice(randomIndex, 1);
            }

            return selectedLines.join('\n');
        }

        function checkCollision(x, y, width, height) {
            // Check if this position overlaps with any existing blocks
            for (const block of activeBlocks) {
                if (!(x + width < block.x ||
                      x > block.x + block.width ||
                      y + height < block.y ||
                      y > block.y + block.height)) {
                    return true; // Collision detected
                }
            }
            return false;
        }

        function findSafePosition(width, height) {
            const maxAttempts = 50;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Random position (avoid center where main title is)
                let x = Math.random() * 80 + 10; // 10-90%
                let y = Math.random() * 80 + 10; // 10-90%

                // Avoid center area (30-70% range - larger exclusion zone)
                if (x > 30 && x < 70 && y > 30 && y < 70) {
                    // Push to edges if in center
                    if (Math.random() > 0.5) {
                        x = x < 50 ? x - 35 : x + 35;
                    } else {
                        y = y < 50 ? y - 35 : y + 35;
                    }
                }

                // Check collision
                if (!checkCollision(x, y, width, height)) {
                    return { x, y };
                }
            }

            // If we can't find a safe spot, return null
            return null;
        }

        function createTextBlock() {
            const text = getRandomLines();

            // Estimate size (rough approximation)
            const lineCount = text.split('\n').length;
            const maxLineLength = Math.max(...text.split('\n').map(line => line.length));
            const estimatedWidth = maxLineLength * 0.6; // Rough % of viewport width
            const estimatedHeight = lineCount * 2; // Rough % of viewport height

            // Find safe position
            const position = findSafePosition(estimatedWidth, estimatedHeight);
            if (!position) {
                // If no safe position found, skip this block
                return;
            }

            const block = document.createElement('div');
            block.className = 'text-block';
            block.style.left = position.x + '%';
            block.style.top = position.y + '%';

            container.appendChild(block);

            // Track this block
            const blockData = {
                element: block,
                x: position.x,
                y: position.y,
                width: estimatedWidth,
                height: estimatedHeight
            };
            activeBlocks.push(blockData);

            // Type out text character by character
            let currentText = '';
            let charIndex = 0;

            const typeInterval = setInterval(() => {
                if (charIndex < text.length) {
                    currentText += text[charIndex];
                    block.textContent = currentText;
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                }
            }, 50); // 50ms per character

            // Remove after fade animation completes
            setTimeout(() => {
                block.remove();
                // Remove from active blocks array
                const index = activeBlocks.indexOf(blockData);
                if (index > -1) {
                    activeBlocks.splice(index, 1);
                }
            }, 6000);
        }

        // Create text blocks at random intervals
        function spawnTextBlocks() {
            createTextBlock();

            // Schedule next block (random interval between 400ms and 1000ms - faster spawning)
            const nextDelay = Math.random() * 600 + 400;
            setTimeout(spawnTextBlocks, nextDelay);
        }

        // Start spawning after a short delay
        setTimeout(spawnTextBlocks, 500);
    })();
    </script>

    <!-- CAMPAIGN DASHBOARD VIEW -->
    {% elif active_view.view_type == 'CAMPAIGN_DASHBOARD' %}
    <div class="campaign-dashboard">
        <!-- Top Panel -->
        <div class="dashboard-top panel-base chamfer-bl-br border-all corner-line-bl-br">
            <div class="dashboard-top-content">THE OUTER VEIL CAMPAIGN</div>
        </div>

        <!-- Left Column - Two Panels -->
        <div class="dashboard-left">
            <!-- Left Top Panel - CREW -->
            <div class="panel-base chamfer-tr-bl border-all corner-line-tr-bl">
                <div class="dashboard-panel-header">
                    <h3>CREW</h3>
                </div>
                <div class="dashboard-panel-content">
                    <p>&gt; Dr. Elena Vasquez - Science Officer</p>
                    <p>&gt; Marcus "Wrench" Chen - Engineer</p>
                    <p>&gt; Lt. Sarah Kim - Security</p>
                    <p>&gt; Alex Novak - Pilot</p>
                </div>
            </div>

            <!-- Left Bottom Panel - NOTES -->
            <div class="panel-base chamfer-tr-bl border-all corner-line-tr-bl">
                <div class="dashboard-panel-header">
                    <h3>NOTES</h3>
                </div>
                <div class="dashboard-panel-content">
                    <p>&gt; Investigating anomalous readings</p>
                    <p>&gt; Specimen requires containment</p>
                    <p>&gt; Station comms experiencing intermittent interference</p>
                    <p>&gt; Crew morale declining - recommend shore leave</p>
                    <p>&gt; Unexplained power fluctuations in sector 7</p>
                    <p>&gt; Medical bay reports increased stress cases</p>
                    <p>&gt; Supply chain delays expected - ration accordingly</p>
                    <p>&gt; Scanning unknown vessel at coordinates 45.2, -12.7</p>
                    <p>&gt; Engineering requesting additional hands for repairs</p>
                    <p>&gt; Security alert: unauthorized access attempt logged</p>
                    <p>&gt; Navigation system recalibration scheduled 0800 hours</p>
                    <p>&gt; Atmospheric readings nominal across all decks</p>
                    <p>&gt; Distress beacon detected from mining outpost</p>
                    <p>&gt; Cargo manifest discrepancies under investigation</p>
                    <p>&gt; Life support systems operating at 98% efficiency</p>
                    <p>&gt; Recommend full diagnostic sweep before next jump</p>
                    <p>&gt; Unknown biological signatures detected in hold 3</p>
                    <p>&gt; Command override protocols updated - review required</p>
                </div>
            </div>
        </div>

        <!-- Right Column - Two Panels -->
        <div class="dashboard-right">
            <!-- Right Top Panel - Star Map -->
            <div class="panel-base chamfer-tl-br border-all corner-line-tl-br">
                <div class="dashboard-panel-header">
                    <h3>STAR MAP</h3>
                </div>
                <div class="dashboard-panel-content" id="star-map-panel">
                    {% if star_systems %}
                        {% for system in star_systems %}
                            {% if system.label %}
                                <div class="star-system-row" data-system="{{ system.name }}" data-has-system-map="{{ system.has_system_map }}">
                                    <div class="star-system-content">
                                        <div class="star-system-checkbox"></div>
                                        <div class="star-system-name">{{ system.name }}</div>
                                    </div>
                                    {% if system.has_system_map %}
                                        <div class="system-map-btn-container" title="View system map">
                                            <span class="system-map-btn-icon">▶</span>
                                        </div>
                                    {% endif %}
                                </div>
                            {% endif %}
                        {% endfor %}
                    {% else %}
                        <p>&gt; No star systems found</p>
                    {% endif %}
                </div>
            </div>

            <!-- Right Bottom Panel - STATUS -->
            <div class="panel-base chamfer-tl-br border-all corner-line-tl-br">
                <div class="dashboard-panel-header">
                    <h3>STATUS</h3>
                </div>
                <div class="dashboard-panel-content">
                    <p>&gt; All systems nominal</p>
                    <p>&gt; Course steady</p>
                </div>
            </div>
        </div>

        <!-- System Info Panel (appears when star is selected) -->
        <div id="system-info-panel" class="system-info-panel">
            <div class="dashboard-panel-header">
                <h3 id="system-info-name">SYSTEM INFO</h3>
            </div>
            <div class="dashboard-panel-content">
                <div id="system-info-content">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Indicator boxes (sibling to avoid clip-path) -->
        <div class="system-info-indicator-boxes"></div>

        <!-- Rectangle decoration extending to panel edge -->
        <div class="system-info-rectangle"></div>

        <!-- Triangle decoration on top of rectangle -->
        <div class="system-info-triangle"></div>
    </div>

    <!-- Store star systems data in JavaScript -->
    <script>
    window.starSystemsData = {{ star_systems_json|safe }};
    </script>

    <!-- ENCOUNTER MAP VIEW -->
    {% elif active_view.view_type == 'ENCOUNTER_MAP' and location_data %}
    <div class="map-view">
        <div class="map-header">{{ location_data.name|upper }}</div>
        <div class="map-info-bar">
            <span>LOCATION: {{ location_data.coordinates|default:"UNKNOWN" }}</span>
            <span>TYPE: {{ location_data.type|default:"UNKNOWN"|upper }}</span>
            <span>STATUS: {{ location_data.status|default:"UNKNOWN"|upper }}</span>
        </div>
        <div class="map-container">
            {% if location_data.map.image_path %}
                <img src="/data/{{ location_data.map.image_path }}" alt="{{ location_data.map.name }}" class="map-image">
            {% else %}
                <div class="no-map-message">
                    <p>&gt; NO MAP AVAILABLE</p>
                    <p>&gt; {{ location_data.name|upper }}</p>
                </div>
            {% endif %}
        </div>
    </div>

    <!-- FALLBACK -->
    {% else %}
    <div class="standby-view">
        <div class="no-map-message">
            <p>&gt; TERMINAL STANDBY</p>
            <p>&gt; NO ACTIVE VIEW</p>
        </div>
    </div>
    {% endif %}

    <!-- Auto-refresh script -->
    <script>
    (function() {
        let currentViewState = {
            location_slug: '{{ active_view.location_slug|default:"" }}',
            view_type: '{{ active_view.view_type }}',
            view_slug: '{{ active_view.view_slug|default:"" }}',
            updated_at: '{{ active_view.updated_at|date:"Y-m-d H:i:s" }}'
        };

        function checkForViewChanges() {
            fetch('/api/active-view/')
                .then(response => response.json())
                .then(data => {
                    // Check if view has changed
                    if (data.location_slug !== currentViewState.location_slug ||
                        data.view_type !== currentViewState.view_type ||
                        data.view_slug !== currentViewState.view_slug) {

                        console.log('View changed - reloading with reset flag');
                        // Add reset parameter to indicate this is a view change, not a manual refresh
                        window.location.href = window.location.pathname + '?viewchange=1';
                    }

                    // Update current state
                    currentViewState = {
                        location_slug: data.location_slug,
                        view_type: data.view_type,
                        view_slug: data.view_slug,
                        updated_at: data.updated_at
                    };
                })
                .catch(error => {
                    console.error('Error checking active view:', error);
                });
        }

        // Poll every 2 seconds
        setInterval(checkForViewChanges, 2000);
    })();
    </script>

    <!-- 3D Star Map Initialization -->
    <script>
    // Global star map state (accessible to other scripts)
    window.starMapState = {
        starPositions: new Map(),  // Map of system name to position
        camera: null,
        lookAtTarget: null,
        animating: false,
        animationFrameId: null,  // Store animation frame ID for cancellation
        autoRotate: false,  // Auto-rotate around selected star
        autoRotateSpeed: 0.002  // Rotation speed (radians per frame) - full rotation ~52 seconds
    };

    (function() {
        // Get the canvas
        const canvas = document.getElementById('starmap-canvas');
        if (!canvas) return;

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Array to store stars for animation
        const stars = [];

        // Create camera
        const camera = new THREE.PerspectiveCamera(
            75,  // FOV
            window.innerWidth / window.innerHeight,  // Aspect ratio
            0.1,  // Near plane
            1000  // Far plane
        );
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Store camera reference globally
        window.starMapState.camera = camera;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
        scene.add(ambientLight);

        // Create a simple starburst texture (like in the reference image)
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const centerX = 64;
            const centerY = 64;

            // Draw bright center core with glow
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            coreGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = coreGradient;
            ctx.fillRect(0, 0, 128, 128);

            // Draw simple 4-point cross
            ctx.globalCompositeOperation = 'lighter';
            drawSpike(ctx, centerX, centerY, 0, 50, 3);      // North
            drawSpike(ctx, centerX, centerY, 90, 50, 3);     // East
            drawSpike(ctx, centerX, centerY, 180, 50, 3);    // South
            drawSpike(ctx, centerX, centerY, 270, 50, 3);    // West

            // Apply blur for soft glow
            ctx.filter = 'blur(2px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';

            return new THREE.CanvasTexture(canvas);
        }

        // Helper function to draw a spike/ray
        function drawSpike(ctx, x, y, angle, length, width) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((angle * Math.PI) / 180);

            const gradient = ctx.createLinearGradient(0, 0, 0, length);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-width, length);
            ctx.lineTo(width, length);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Create the star texture once for reuse
        const starTexture = createStarTexture();

        // Create targeting reticle texture (two concentric circles with cross cutout)
        function createReticleTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const centerX = size / 2;
            const centerY = size / 2;

            // Amber color (muted yellow) - #8b7355
            const amberColor = 'rgba(139, 115, 85, 1.0)';

            // Clear canvas
            ctx.clearRect(0, 0, size, size);

            // Use compositing to create cutout effect
            ctx.globalCompositeOperation = 'source-over';

            // Draw outer circle
            ctx.strokeStyle = amberColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
            ctx.stroke();

            // Draw inner circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
            ctx.stroke();

            // Use destination-out to cut out the cross
            ctx.globalCompositeOperation = 'destination-out';

            // Horizontal cross bar
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(centerX - 90, centerY - 4, 180, 8);

            // Vertical cross bar
            ctx.fillRect(centerX - 4, centerY - 90, 8, 180);

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';

            return new THREE.CanvasTexture(canvas);
        }

        const reticleTexture = createReticleTexture();

        // Create selection reticle sprite (initially hidden)
        const selectionReticle = new THREE.Sprite(new THREE.SpriteMaterial({
            map: reticleTexture,
            transparent: true,
            opacity: 0.8,
            depthTest: false,  // Always render on top
            depthWrite: false
        }));
        selectionReticle.scale.set(20, 20, 1);  // Size of the reticle
        selectionReticle.visible = false;  // Hidden by default
        scene.add(selectionReticle);

        // Store reticle reference globally
        window.starMapState.selectionReticle = selectionReticle;

        // Create background star field using sprites (same texture as main stars)
        const starFieldCount = 5000;  // Number of background stars
        const backgroundStars = [];

        for (let i = 0; i < starFieldCount; i++) {
            // Random position in a large sphere
            const radius = 150 + Math.random() * 300;  // Distance from center
            const theta = Math.random() * Math.PI * 2;  // Horizontal angle
            const phi = Math.acos(2 * Math.random() - 1);  // Vertical angle (uniform distribution)

            const position = new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Create sprite with starburst texture
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,  // Random opacity 0.4-0.8
                blending: THREE.AdditiveBlending
            });

            const sprite = new THREE.Sprite(spriteMaterial);

            // Random size variation (smaller than main stars)
            const size = 0.5 + Math.random() * 1.5;  // Size 0.5 to 2.0
            sprite.scale.set(size, size, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            // Store for potential animation
            sprite.userData.baseOpacity = sprite.material.opacity;
            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

            scene.add(sprite);
            backgroundStars.push(sprite);
        }

        function createStar(size, position) {
            // Just use a sprite - no sphere core
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size * 6, size * 6, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            // Store sprite reference for animation
            sprite.userData.baseOpacity = 0.9;
            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

            return sprite;
        }

        // Load star map data and create stars
        fetch('/api/star-map/')
            .then(response => response.json())
            .then(data => {
                console.log('Star map data loaded:', data);

                // Create stars from data
                if (data.systems) {
                    data.systems.forEach(system => {
                        const position = new THREE.Vector3(
                            system.position[0],
                            system.position[1],
                            system.position[2]
                        );

                        const star = createStar(system.size || 1, position);

                        star.userData = {
                            name: system.name,
                            type: system.type
                        };

                        scene.add(star);

                        // Store star for animation
                        stars.push(star);

                        // Store star position globally for camera navigation
                        window.starMapState.starPositions.set(system.name, position);

                        // Add point light at star position for subtle illumination
                        const starLight = new THREE.PointLight(0xFFFFFF, 0.3, 40);  // Pure white
                        starLight.position.copy(position);
                        scene.add(starLight);
                    });

                    console.log(`Loaded ${stars.length} stars for pulsing animation`);
                }

                // Create connection routes
                if (data.routes) {
                    const systemPositions = {};
                    data.systems.forEach(sys => {
                        systemPositions[sys.name] = sys.position;
                    });

                    data.routes.forEach(route => {
                        const fromPos = systemPositions[route.from];
                        const toPos = systemPositions[route.to];

                        if (fromPos && toPos) {
                            // Create start and end points
                            const start = new THREE.Vector3(fromPos[0], fromPos[1], fromPos[2]);
                            const end = new THREE.Vector3(toPos[0], toPos[1], toPos[2]);

                            // Calculate direction and distance
                            const direction = end.clone().sub(start);
                            const distance = direction.length();
                            direction.normalize();

                            // Shorten the line on both ends so it doesn't reach star centers
                            // Move start point away from star by 8 units
                            // Move end point away from star by 8 units
                            const offset = 8;
                            const shortenedStart = start.clone().add(direction.clone().multiplyScalar(offset));
                            const shortenedEnd = end.clone().sub(direction.clone().multiplyScalar(offset));

                            // Only create route if there's enough distance after shortening
                            if (distance > offset * 2) {
                                // Create a curve from start to end (full length for gradient)
                                const curve = new THREE.LineCurve3(start, end);

                                // Create tube geometry with more segments for smooth fade
                                const segments = 64;  // More segments for smooth gradient
                                const tubeGeometry = new THREE.TubeGeometry(
                                    curve,
                                    segments,  // Segments along the length
                                    0.3,       // Tube radius (thickness)
                                    8,         // Radial segments (smoothness)
                                    false      // Not closed
                                );

                                // Add vertex alpha values for fade effect
                                const positions = tubeGeometry.attributes.position;
                                const alphas = [];
                                const fadeDistance = 15;  // Distance over which to fade (in units)

                                // Calculate alpha for each vertex
                                for (let i = 0; i < positions.count; i++) {
                                    const vertex = new THREE.Vector3(
                                        positions.getX(i),
                                        positions.getY(i),
                                        positions.getZ(i)
                                    );

                                    // Calculate distance from both ends
                                    const distFromStart = vertex.distanceTo(start);
                                    const distFromEnd = vertex.distanceTo(end);

                                    // Calculate alpha from both ends (handles overlapping fades)
                                    let alphaFromStart = 1.0;
                                    let alphaFromEnd = 1.0;

                                    if (distFromStart < fadeDistance) {
                                        alphaFromStart = distFromStart / fadeDistance;
                                    }
                                    if (distFromEnd < fadeDistance) {
                                        alphaFromEnd = distFromEnd / fadeDistance;
                                    }

                                    // Use the minimum (most transparent) alpha
                                    const alpha = Math.min(alphaFromStart, alphaFromEnd);

                                    alphas.push(alpha);
                                }

                                tubeGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

                                // Custom shader material for vertex alpha
                                const material = new THREE.ShaderMaterial({
                                    uniforms: {
                                        color: { value: new THREE.Color(route.color || 0x5a7a9a) }
                                    },
                                    vertexShader: `
                                        attribute float alpha;
                                        varying float vAlpha;
                                        void main() {
                                            vAlpha = alpha;
                                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                        }
                                    `,
                                    fragmentShader: `
                                        uniform vec3 color;
                                        varying float vAlpha;
                                        void main() {
                                            gl_FragColor = vec4(color, vAlpha);
                                        }
                                    `,
                                    transparent: true,
                                    depthWrite: false
                                });

                                const tube = new THREE.Mesh(tubeGeometry, material);
                                scene.add(tube);
                            }
                        }
                    });
                }

                // Create nebulae clouds
                if (data.nebulae) {
                    // Create soft cloud texture for nebula particles (diffuse, no bright center)
                    function createNebulaTexture() {
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');

                        // Create soft gradient (visible but not too bright at center)
                        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');    // Soft center
                        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');  // Mid region
                        gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');  // Fade
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');    // Transparent edge

                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 64, 64);

                        return new THREE.CanvasTexture(canvas);
                    }

                    const nebulaTexture = createNebulaTexture();
                    const nebulaParticles = [];  // Store for animation

                    data.nebulae.forEach(nebula => {
                        const position = new THREE.Vector3(
                            nebula.position[0],
                            nebula.position[1],
                            nebula.position[2]
                        );

                        // Create spherical shell of particles
                        // Target radius for bright expansion front
                        const targetRadius = nebula.size * 0.85;
                        const shellThickness = nebula.size * 0.25;

                        for (let i = 0; i < nebula.particle_count; i++) {
                            // Random point on sphere using uniform distribution
                            const theta = Math.random() * Math.PI * 2;  // Azimuth: 0 to 2π
                            const phi = Math.acos(2 * Math.random() - 1);  // Elevation: 0 to π (uniform)

                            // Distance from center (concentrated around target radius)
                            const radiusOffset = (Math.random() - 0.5) * shellThickness;
                            const radius = targetRadius + radiusOffset;

                            // Convert spherical to Cartesian coordinates
                            const x = radius * Math.sin(phi) * Math.cos(theta);
                            const y = radius * Math.sin(phi) * Math.sin(theta);
                            const z = radius * Math.cos(phi);

                            const particlePos = new THREE.Vector3(
                                position.x + x,
                                position.y + y,
                                position.z + z
                            );

                            // Particles closer to target radius are brighter (expansion front)
                            const distanceFromFront = Math.abs(radiusOffset);
                            const brightnessFactor = 1.0 - (distanceFromFront / (shellThickness / 2));
                            const particleOpacity = nebula.opacity * Math.max(0.3, brightnessFactor) * (0.6 + Math.random() * 0.4);

                            const spriteMaterial = new THREE.SpriteMaterial({
                                map: nebulaTexture,
                                color: nebula.color,
                                transparent: true,
                                opacity: particleOpacity,
                                blending: THREE.AdditiveBlending,
                                depthWrite: false
                            });

                            const sprite = new THREE.Sprite(spriteMaterial);

                            // Vary particle size
                            const size = (nebula.size / 5) * (0.5 + Math.random() * 0.8);
                            sprite.scale.set(size, size, 1);
                            sprite.position.copy(particlePos);

                            // Store metadata for animation
                            sprite.userData.nebulaType = nebula.type;
                            sprite.userData.baseOpacity = particleOpacity;
                            sprite.userData.pulseOffset = Math.random() * Math.PI * 2;

                            scene.add(sprite);
                            nebulaParticles.push(sprite);
                        }
                    });
                }

                console.log('Star map rendered');
            })
            .catch(error => {
                console.error('Error loading star map:', error);
            });

        // Animation loop with star pulsing
        function animate() {
            requestAnimationFrame(animate);

            // Pulse stars
            const time = Date.now() * 0.001; // Time in seconds
            stars.forEach(star => {
                if (star.userData.sprite) {
                    // Pulse between 0.4 and 1.0 opacity using sine wave (more dramatic)
                    const pulseSpeed = 2.0; // Speed of pulsing (faster)
                    const pulseAmount = 0.3; // How much to pulse (30% variation)
                    const pulse = Math.sin(time * pulseSpeed + star.userData.pulseOffset) * pulseAmount;

                    // Set opacity between 0.4 and 1.0
                    const newOpacity = 0.7 + pulse;
                    star.userData.sprite.material.opacity = Math.max(0.4, Math.min(1.0, newOpacity));
                }
            });

            // Animate nebula particles based on type
            if (typeof nebulaParticles !== 'undefined') {
                nebulaParticles.forEach(particle => {
                    const type = particle.userData.nebulaType;

                    if (type === 'emission') {
                        // Emission nebulae: Gentle pulsing (flickering ionized gas)
                        const pulseSpeed = 0.5;  // Slow pulse
                        const pulseAmount = 0.15;  // Subtle variation (15%)
                        const pulse = Math.sin(time * pulseSpeed + particle.userData.pulseOffset) * pulseAmount;
                        particle.material.opacity = particle.userData.baseOpacity * (1.0 + pulse);

                    } else if (type === 'planetary') {
                        // Planetary nebulae: Slow rotation around center
                        const angle = time * particle.userData.rotationSpeed;
                        const currentOffset = particle.position.clone().sub(particle.userData.nebulaCenter);
                        const distance = currentOffset.length();

                        // Rotate around Y-axis
                        const rotatedX = currentOffset.x * Math.cos(angle * 0.1) - currentOffset.z * Math.sin(angle * 0.1);
                        const rotatedZ = currentOffset.x * Math.sin(angle * 0.1) + currentOffset.z * Math.cos(angle * 0.1);

                        particle.position.set(
                            particle.userData.nebulaCenter.x + rotatedX,
                            particle.userData.nebulaCenter.y + currentOffset.y,
                            particle.userData.nebulaCenter.z + rotatedZ
                        );

                    } else if (type === 'reflection') {
                        // Reflection nebulae: Very subtle shimmer
                        const pulseSpeed = 0.3;
                        const pulseAmount = 0.08;  // Very subtle (8%)
                        const pulse = Math.sin(time * pulseSpeed + particle.userData.pulseOffset) * pulseAmount;
                        particle.material.opacity = particle.userData.baseOpacity * (1.0 + pulse);
                    }
                    // Dark nebulae: No animation (static dust clouds)
                });
            }

            // Auto-rotate camera around selected star
            if (window.starMapState.autoRotate && !window.starMapState.animating) {
                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                // Get current angle
                let theta = Math.atan2(offset.x, offset.z);

                // Increment angle for rotation
                theta += window.starMapState.autoRotateSpeed;

                // Keep current elevation (phi)
                const phi = Math.acos(offset.y / radius);

                // Calculate new position
                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Track where camera is looking (center point for rotation)
        const lookAtTarget = new THREE.Vector3(0, 0, 0);

        // Store lookAtTarget reference globally
        window.starMapState.lookAtTarget = lookAtTarget;

        // Camera animation function
        function animateCameraToTarget(targetPosition, duration = 2000) {
            // Cancel any ongoing animation
            if (window.starMapState.animationFrameId) {
                cancelAnimationFrame(window.starMapState.animationFrameId);
                window.starMapState.animationFrameId = null;
            }

            window.starMapState.animating = true;

            // Use current camera position as start (for smooth interruption)
            const startPosition = camera.position.clone();
            const startLookAt = lookAtTarget.clone();
            const startTime = Date.now();

            // Calculate optimal camera position (offset from target)
            const distance = 80;  // Distance from target
            const angle = Math.atan2(startPosition.x - startLookAt.x, startPosition.z - startLookAt.z);
            const endPosition = new THREE.Vector3(
                targetPosition.x + Math.sin(angle) * distance,
                targetPosition.y + 30,  // Slight elevation
                targetPosition.z + Math.cos(angle) * distance
            );

            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Easing function (ease-in-out)
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Interpolate camera position
                camera.position.lerpVectors(startPosition, endPosition, eased);

                // Interpolate lookAt target
                lookAtTarget.lerpVectors(startLookAt, targetPosition, eased);
                camera.lookAt(lookAtTarget);

                if (progress < 1) {
                    window.starMapState.animationFrameId = requestAnimationFrame(updateCamera);
                } else {
                    window.starMapState.animating = false;
                    window.starMapState.animationFrameId = null;
                }
            }

            updateCamera();
        }

        // Make animation function globally accessible
        window.starMapState.animateCameraToTarget = animateCameraToTarget;

        // Simple mouse wheel zoom
        let zoomSpeed = 5;      // Units to zoom per scroll
        let minDistance = 20;   // Minimum distance from center
        let maxDistance = 300;  // Maximum distance from center

        window.addEventListener('wheel', (event) => {
            // Check if mouse is over a panel or scrollable content
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');

            // If over a panel, allow normal scrolling
            if (isPanel) {
                // Don't call preventDefault() - let the browser handle scrolling
                return;
            }

            // Otherwise, zoom the galaxy map
            event.preventDefault();

            // Disable auto-rotation when user zooms
            window.starMapState.autoRotate = false;

            // Calculate direction from camera to target
            const direction = lookAtTarget.clone().sub(camera.position).normalize();
            const currentDistance = camera.position.distanceTo(lookAtTarget);

            // Zoom in or out
            if (event.deltaY < 0) {
                // Zoom in
                const newDistance = currentDistance - zoomSpeed;
                if (newDistance >= minDistance) {
                    camera.position.add(direction.multiplyScalar(zoomSpeed));
                }
            } else {
                // Zoom out
                const newDistance = currentDistance + zoomSpeed;
                if (newDistance <= maxDistance) {
                    camera.position.add(direction.multiplyScalar(-zoomSpeed));
                }
            }
        }, { passive: false });

        // Touch pinch zoom (for mobile/tablet) - attach to window
        let lastTouchDistance = 0;

        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                event.preventDefault();

                // Disable auto-rotation when user pinch zooms
                window.starMapState.autoRotate = false;

                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const distance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                const delta = lastTouchDistance - distance;
                lastTouchDistance = distance;

                // Apply zoom using directional approach (same as wheel zoom)
                const direction = lookAtTarget.clone().sub(camera.position).normalize();
                const currentDistance = camera.position.distanceTo(lookAtTarget);

                if (delta > 0) {
                    // Pinch in (zoom out)
                    const newDistance = currentDistance + zoomSpeed;
                    if (newDistance <= maxDistance) {
                        camera.position.add(direction.multiplyScalar(-zoomSpeed));
                    }
                } else if (delta < 0) {
                    // Pinch out (zoom in)
                    const newDistance = currentDistance - zoomSpeed;
                    if (newDistance >= minDistance) {
                        camera.position.add(direction.multiplyScalar(zoomSpeed));
                    }
                }
            }
        }, { passive: false });

        // Mouse and touch rotation controls
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let rotateSpeed = 0.005;

        // Mouse rotation
        window.addEventListener('mousedown', (event) => {
            if (event.button === 0) {  // Left click only
                isDragging = true;
                // Disable auto-rotation when user manually rotates
                window.starMapState.autoRotate = false;
                previousPosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;

            const deltaX = event.clientX - previousPosition.x;
            const deltaY = event.clientY - previousPosition.y;

            // Rotate camera around center
            const offset = camera.position.clone().sub(lookAtTarget);
            const radius = offset.length();

            // Convert to spherical coordinates
            let theta = Math.atan2(offset.x, offset.z);
            let phi = Math.acos(offset.y / radius);

            // Update angles
            theta -= deltaX * rotateSpeed;
            phi -= deltaY * rotateSpeed;

            // Clamp phi to prevent flipping
            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            // Convert back to cartesian
            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            camera.position.copy(lookAtTarget).add(offset);
            camera.lookAt(lookAtTarget);

            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch rotation (single finger drag) - attach to window
        let isTouching = false;

        window.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                // Check if touching a panel or button
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel, .star-system-row');
                const isButton = target.closest('button, .system-map-btn-container, .show-btn-container');
                if (isPanel || isButton) return;

                isTouching = true;
                // Disable auto-rotation when user manually rotates
                window.starMapState.autoRotate = false;
                previousPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (isTouching && event.touches.length === 1) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) {
                    isTouching = false;
                    return;
                }

                event.preventDefault();

                const touch = event.touches[0];
                const deltaX = touch.clientX - previousPosition.x;
                const deltaY = touch.clientY - previousPosition.y;

                // Same rotation logic as mouse
                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / radius);

                theta -= deltaX * rotateSpeed;
                phi -= deltaY * rotateSpeed;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);

                previousPosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isTouching = false;
        });

        // Enable auto-rotation by default when nothing is selected
        // Wait a bit to ensure everything is initialized
        setTimeout(() => {
            // Only enable if no system is currently selected
            const hasSelectedSystem = localStorage.getItem('selected_star_system');
            if (!hasSelectedSystem && window.starMapState) {
                window.starMapState.autoRotate = true;
                console.log('Auto-rotation enabled (no system selected)');
            }
        }, 500);
    })();
    </script>

    <!-- System Map (Solar System View) Script -->
    <script>
    // Global state for system map
    window.systemMapState = {
        scene: null,
        camera: null,
        renderer: null,
        planets: [],
        orbits: [],
        star: null,
        currentSystem: null,
        animationFrameId: null,
        startTime: Date.now(),
        controlsInitialized: false,
        speedMultiplier: 10  // Default, will be calculated per-system
    };

    // Initialize system map scene
    function initSystemMap() {
        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas) return;

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        window.systemMapState.scene = scene;

        // Create camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 180);
        camera.lookAt(0, 0, 0);
        window.systemMapState.camera = camera;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        window.systemMapState.renderer = renderer;

        // Add ambient light (dim)
        const ambientLight = new THREE.AmbientLight(0x222244, 0.2);
        scene.add(ambientLight);

        // Create star texture for background starfield
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const centerX = 64;
            const centerY = 64;

            // Draw bright center core with glow
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            coreGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = coreGradient;
            ctx.fillRect(0, 0, 128, 128);

            // Draw simple 4-point cross
            ctx.globalCompositeOperation = 'lighter';
            drawSpike(ctx, centerX, centerY, 0, 50, 3);      // North
            drawSpike(ctx, centerX, centerY, 90, 50, 3);     // East
            drawSpike(ctx, centerX, centerY, 180, 50, 3);    // South
            drawSpike(ctx, centerX, centerY, 270, 50, 3);    // West

            // Apply blur for soft glow
            ctx.filter = 'blur(2px)';
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';

            return new THREE.CanvasTexture(canvas);
        }

        function drawSpike(ctx, x, y, angle, length, width) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((angle * Math.PI) / 180);

            const gradient = ctx.createLinearGradient(0, 0, 0, length);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-width, length);
            ctx.lineTo(width, length);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        const starTexture = createStarTexture();

        // Create background star field
        const starFieldCount = 5000;
        const backgroundStars = [];

        for (let i = 0; i < starFieldCount; i++) {
            // Random position in a large sphere
            const radius = 150 + Math.random() * 300;  // Distance from center
            const theta = Math.random() * Math.PI * 2;  // Horizontal angle
            const phi = Math.acos(2 * Math.random() - 1);  // Vertical angle (uniform distribution)

            const position = new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            // Create sprite with starburst texture
            const spriteMaterial = new THREE.SpriteMaterial({
                map: starTexture,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,  // Random opacity 0.4-0.8
                blending: THREE.AdditiveBlending
            });

            const sprite = new THREE.Sprite(spriteMaterial);

            // Random size variation (smaller than main stars)
            const size = 0.5 + Math.random() * 1.5;  // Size 0.5 to 2.0
            sprite.scale.set(size, size, 1);
            sprite.position.copy(position);

            // Random rotation for variety
            sprite.material.rotation = Math.random() * Math.PI * 2;

            scene.add(sprite);
            backgroundStars.push(sprite);
        }

        console.log('System map initialized with', starFieldCount, 'background stars');
    }

    // Load and display system map
    async function loadSystemMap(systemSlug) {
        try {
            const response = await fetch(`/api/system-map/${systemSlug}/`);
            if (!response.ok) {
                throw new Error(`Failed to load system map: ${response.statusText}`);
            }

            const data = await response.json();
            console.log('System map data loaded:', data);

            // Store current system
            window.systemMapState.currentSystem = data;

            // Clear existing objects
            clearSystemMap();

            // Initialize scene if not already done
            if (!window.systemMapState.scene) {
                initSystemMap();
            }

            // Render the star
            renderStar(data.star);

            // Render planets and orbits
            if (data.bodies) {
                data.bodies.forEach(body => {
                    renderPlanet(body);
                    // Render orbits by default unless explicitly disabled
                    if (!data.orbits || data.orbits.show !== false) {
                        renderOrbit(body, data.orbits || {});
                    }
                });
            }

            // Calculate speed multiplier based on fastest planet
            // Target: fastest planet completes 1 orbit in 10 seconds
            if (window.systemMapState.planets.length > 0) {
                const minOrbitalPeriod = Math.min(...window.systemMapState.planets.map(p => p.orbitalPeriod));
                window.systemMapState.speedMultiplier = minOrbitalPeriod / 10;
                console.log(`Speed multiplier for ${data.star.name}: ${window.systemMapState.speedMultiplier.toFixed(2)} (fastest planet: ${minOrbitalPeriod} days)`);
            }

            // Apply camera settings from data
            if (data.camera) {
                const cam = window.systemMapState.camera;
                cam.position.set(...data.camera.position);
                cam.lookAt(...data.camera.lookAt);
                if (data.camera.fov) {
                    cam.fov = data.camera.fov;
                    cam.updateProjectionMatrix();
                }
            }

            // Show system map, hide galaxy map
            showSystemMap();

            // Initialize controls if not already done
            if (!window.systemMapState.controlsInitialized) {
                initSystemMapControls();
                window.systemMapState.controlsInitialized = true;
            }

            // Start animation
            if (!window.systemMapState.animationFrameId) {
                animateSystemMap();
            }

        } catch (error) {
            console.error('Error loading system map:', error);
        }
    }

    // Render central star
    function renderStar(starData) {
        const scene = window.systemMapState.scene;

        // Create star sphere
        const starGeometry = new THREE.SphereGeometry(starData.size || 4, 32, 32);
        const starMaterial = new THREE.MeshBasicMaterial({
            color: starData.color || 0xFFFFAA
        });
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.position.set(0, 0, 0);
        scene.add(star);

        // Add point light at star position
        const starLight = new THREE.PointLight(
            starData.light_color || starData.color || 0xFFFFAA,
            starData.corona_intensity || 1.5,
            500
        );
        starLight.position.set(0, 0, 0);
        scene.add(starLight);

        // Add glow effect
        const glowGeometry = new THREE.SphereGeometry(starData.size * 1.5 || 6, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: starData.color || 0xFFFFAA,
            transparent: true,
            opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.set(0, 0, 0);
        scene.add(glow);

        window.systemMapState.star = { star, glow, light: starLight };
    }

    // Render a planet
    function renderPlanet(bodyData) {
        const scene = window.systemMapState.scene;

        // Create circle texture for planet outline
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // Draw solid black circle background
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(32, 32, 28, 0, Math.PI * 2);
        ctx.fill();

        // Draw teal circle outline on top
        ctx.strokeStyle = '#5a7a7a';  // Teal to match UI
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(32, 32, 28, 0, Math.PI * 2);
        ctx.stroke();

        const texture = new THREE.CanvasTexture(canvas);

        // Create sprite with circle texture (automatically faces camera)
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthWrite: true,  // Ensure sprite writes to depth buffer to occlude objects behind it
            depthTest: true
        });

        const planet = new THREE.Sprite(spriteMaterial);
        const size = (bodyData.size || 1) * 2;  // Double size to maintain visibility
        planet.scale.set(size, size, 1);

        // Calculate initial position based on orbital_angle
        const angle = (bodyData.orbital_angle || 0) * (Math.PI / 180);
        const x = Math.cos(angle) * bodyData.orbital_radius;
        const z = Math.sin(angle) * bodyData.orbital_radius;

        // Apply orbital inclination
        const inclinationRad = (bodyData.inclination || 0) * (Math.PI / 180);
        planet.position.x = x * Math.cos(inclinationRad);
        planet.position.y = x * Math.sin(inclinationRad);
        planet.position.z = z;

        scene.add(planet);

        // Store planet data for animation
        window.systemMapState.planets.push({
            mesh: planet,
            orbitalRadius: bodyData.orbital_radius,
            orbitalPeriod: bodyData.orbital_period || 365,
            initialAngle: angle,
            inclination: bodyData.inclination || 0,  // Store inclination in degrees
            name: bodyData.name,
            clickable: bodyData.clickable || false,
            locationSlug: bodyData.location_slug
        });
    }

    // Render orbital path
    function renderOrbit(bodyData, orbitSettings) {
        const scene = window.systemMapState.scene;

        const curve = new THREE.EllipseCurve(
            0, 0,
            bodyData.orbital_radius, bodyData.orbital_radius,
            0, 2 * Math.PI,
            false,
            0
        );

        const points = curve.getPoints(128);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({
            color: orbitSettings.color || 0x5a7a7a,
            transparent: true,
            opacity: orbitSettings.opacity || 0.45
        });

        const orbit = new THREE.Line(geometry, material);

        // Rotate to XZ plane
        orbit.rotation.x = Math.PI / 2;

        // Apply orbital inclination (tilt around Y axis)
        const inclination = bodyData.inclination || 0;  // Inclination in degrees
        orbit.rotation.y = inclination * (Math.PI / 180);  // Convert to radians

        scene.add(orbit);

        window.systemMapState.orbits.push(orbit);
    }

    // Animation loop for system map
    function animateSystemMap() {
        window.systemMapState.animationFrameId = requestAnimationFrame(animateSystemMap);

        const scene = window.systemMapState.scene;
        const camera = window.systemMapState.camera;
        const renderer = window.systemMapState.renderer;

        if (!scene || !camera || !renderer) return;

        // Animate planets along their orbits
        const currentTime = Date.now();
        const elapsedSeconds = (currentTime - window.systemMapState.startTime) / 1000;

        window.systemMapState.planets.forEach(planetData => {
            // Calculate current angle based on orbital period
            // Use system-specific speed multiplier (calculated so fastest planet orbits once per 5 seconds)
            const orbitalSpeed = (2 * Math.PI) / planetData.orbitalPeriod * window.systemMapState.speedMultiplier;
            const currentAngle = planetData.initialAngle + (orbitalSpeed * elapsedSeconds);

            // Calculate position in orbital plane (before inclination)
            const x = Math.cos(currentAngle) * planetData.orbitalRadius;
            const z = Math.sin(currentAngle) * planetData.orbitalRadius;

            // Apply orbital inclination
            const inclinationRad = planetData.inclination * (Math.PI / 180);

            // Rotate position around Y axis by inclination angle
            planetData.mesh.position.x = x * Math.cos(inclinationRad);
            planetData.mesh.position.y = x * Math.sin(inclinationRad);
            planetData.mesh.position.z = z;

            // Rotate planet on its axis
            planetData.mesh.rotation.y += 0.01;
        });

        renderer.render(scene, camera);
    }

    // Clear system map
    function clearSystemMap() {
        const scene = window.systemMapState.scene;
        if (!scene) return;

        // Remove all planets
        window.systemMapState.planets.forEach(p => scene.remove(p.mesh));
        window.systemMapState.planets = [];

        // Remove all orbits
        window.systemMapState.orbits.forEach(o => scene.remove(o));
        window.systemMapState.orbits = [];

        // Remove star
        if (window.systemMapState.star) {
            scene.remove(window.systemMapState.star.star);
            scene.remove(window.systemMapState.star.glow);
            scene.remove(window.systemMapState.star.light);
            window.systemMapState.star = null;
        }
    }

    // Show system map, hide galaxy map
    function showSystemMap() {
        document.getElementById('starmap-canvas').style.display = 'none';
        document.getElementById('systemmap-canvas').style.display = 'block';
    }

    // Hide system map, show galaxy map
    function hideSystemMap() {
        document.getElementById('systemmap-canvas').style.display = 'none';
        document.getElementById('starmap-canvas').style.display = 'block';

        // Stop animation
        if (window.systemMapState.animationFrameId) {
            cancelAnimationFrame(window.systemMapState.animationFrameId);
            window.systemMapState.animationFrameId = null;
        }
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        if (window.systemMapState.camera && window.systemMapState.renderer) {
            window.systemMapState.camera.aspect = window.innerWidth / window.innerHeight;
            window.systemMapState.camera.updateProjectionMatrix();
            window.systemMapState.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });

    // Add camera controls for system map
    function initSystemMapControls() {
        const canvas = document.getElementById('systemmap-canvas');
        if (!canvas) {
            console.error('System map canvas not found!');
            return;
        }

        console.log('Attaching controls to systemmap-canvas, display:', canvas.style.display);

        let lookAtTarget = new THREE.Vector3(0, 0, 0);
        const minDistance = 60;
        const maxDistance = 300;
        const zoomSpeed = 0.1;
        const rotateSpeed = 0.005;

        // Mouse wheel zoom - attach to window so it works anywhere
        window.addEventListener('wheel', (event) => {
            // Only handle wheel events when system map is visible
            if (canvas.style.display !== 'block') return;

            // Check if mouse is over a panel or scrollable content
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');

            // If over a panel, allow normal scrolling
            if (isPanel) {
                // Don't call preventDefault() - let the browser handle scrolling
                return;
            }

            // Otherwise, zoom the system map
            event.preventDefault();

            const camera = window.systemMapState.camera;
            if (!camera) return;

            const delta = event.deltaY;
            const offset = camera.position.clone().sub(lookAtTarget);
            let distance = offset.length();

            if (delta > 0) {
                distance *= (1 + zoomSpeed);
            } else {
                distance *= (1 - zoomSpeed);
            }

            distance = Math.max(minDistance, Math.min(maxDistance, distance));
            offset.normalize().multiplyScalar(distance);
            camera.position.copy(lookAtTarget).add(offset);
        }, { passive: false });

        // Mouse drag rotation - attach to window
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };

        window.addEventListener('mousedown', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            // Don't start dragging if clicking on UI panels or interactive elements
            const target = event.target;
            const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .star-system-row, .system-info-panel, .dashboard-panel-content');
            const isButton = target.closest('button, .system-map-btn-container, .show-btn-container');

            if (isPanel || isButton) {
                console.log('Click on UI element, not starting drag');
                return;
            }

            console.log('Starting drag rotation');
            isDragging = true;
            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging || canvas.style.display !== 'block') return;

            const camera = window.systemMapState.camera;
            if (!camera) return;

            const deltaX = event.clientX - previousPosition.x;
            const deltaY = event.clientY - previousPosition.y;

            const offset = camera.position.clone().sub(lookAtTarget);
            const radius = offset.length();

            let theta = Math.atan2(offset.x, offset.z);
            let phi = Math.acos(offset.y / radius);

            theta -= deltaX * rotateSpeed;
            phi -= deltaY * rotateSpeed;

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            camera.position.copy(lookAtTarget).add(offset);
            camera.lookAt(lookAtTarget);

            previousPosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch controls - attach to window
        let isTouching = false;

        window.addEventListener('touchstart', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (event.touches.length === 1) {
                // Check if touching a panel or button
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                const isButton = target.closest('button, .system-map-btn-container, .show-btn-container');
                if (isPanel || isButton) return;

                isTouching = true;
                previousPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        });

        window.addEventListener('touchmove', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (isTouching && event.touches.length === 1) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) {
                    isTouching = false;
                    return;
                }

                event.preventDefault();

                const camera = window.systemMapState.camera;
                if (!camera) return;

                const touch = event.touches[0];
                const deltaX = touch.clientX - previousPosition.x;
                const deltaY = touch.clientY - previousPosition.y;

                const offset = camera.position.clone().sub(lookAtTarget);
                const radius = offset.length();

                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / radius);

                theta -= deltaX * rotateSpeed;
                phi -= deltaY * rotateSpeed;

                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                offset.x = radius * Math.sin(phi) * Math.sin(theta);
                offset.y = radius * Math.cos(phi);
                offset.z = radius * Math.sin(phi) * Math.cos(theta);

                camera.position.copy(lookAtTarget).add(offset);
                camera.lookAt(lookAtTarget);

                previousPosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isTouching = false;
        });

        // Pinch zoom for mobile - attach to window
        let lastTouchDistance = 0;

        window.addEventListener('touchstart', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        window.addEventListener('touchmove', (event) => {
            // Only handle when system map is visible
            if (canvas.style.display !== 'block') return;

            if (event.touches.length === 2) {
                // Check if touching a panel
                const target = event.touches[0].target;
                const isPanel = target.closest('.panel-base, .panel-wrapper, .panel-content, .dashboard-panel-content, .system-info-panel');
                if (isPanel) return;

                event.preventDefault();

                const camera = window.systemMapState.camera;
                if (!camera) return;

                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const delta = distance - lastTouchDistance;
                const offset = camera.position.clone().sub(lookAtTarget);
                let dist = offset.length();

                if (delta < 0) {
                    dist *= (1 + zoomSpeed);
                } else {
                    dist *= (1 - zoomSpeed);
                }

                dist = Math.max(minDistance, Math.min(maxDistance, dist));
                offset.normalize().multiplyScalar(dist);
                camera.position.copy(lookAtTarget).add(offset);

                lastTouchDistance = distance;
            }
        }, { passive: false });

        console.log('System map controls initialized');
    }
    </script>

    <!-- Star System Selection Script -->
    <script>
    (function() {
        // Typewriter effect for system info panel
        function typewriteContent(element, html, speed = 15) {
            return new Promise((resolve) => {
                // Create a temporary div to parse the HTML and extract text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // Clear the element
                element.innerHTML = '';

                // We'll build up the content with proper HTML structure
                let currentHTML = '';
                let charIndex = 0;
                const fullText = tempDiv.textContent;

                function typeNextChar() {
                    if (charIndex < fullText.length) {
                        // Get the next character
                        const char = fullText[charIndex];
                        charIndex++;

                        // Rebuild HTML up to current position
                        currentHTML = '';
                        let textSoFar = fullText.substring(0, charIndex);
                        let textIndex = 0;

                        // Parse through original HTML structure and insert characters
                        function buildHTML(node) {
                            if (node.nodeType === Node.TEXT_NODE) {
                                const nodeText = node.textContent;
                                const charsToShow = Math.min(nodeText.length, Math.max(0, textSoFar.length - textIndex));
                                textIndex += nodeText.length;
                                return nodeText.substring(0, charsToShow);
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                const tagName = node.tagName.toLowerCase();
                                const className = node.className ? ` class="${node.className}"` : '';
                                let innerHTML = '';

                                for (let child of node.childNodes) {
                                    innerHTML += buildHTML(child);
                                }

                                if (innerHTML.length > 0) {
                                    return `<${tagName}${className}>${innerHTML}</${tagName}>`;
                                }
                                return '';
                            }
                            return '';
                        }

                        currentHTML = '';
                        textIndex = 0;
                        for (let child of tempDiv.childNodes) {
                            currentHTML += buildHTML(child);
                        }

                        element.innerHTML = currentHTML;

                        setTimeout(typeNextChar, speed);
                    } else {
                        resolve();
                    }
                }

                typeNextChar();
            });
        }

        // Helper function to position indicator boxes, rectangle, and triangle below the panel
        function updateIndicatorBoxesPosition() {
            const infoPanel = document.getElementById('system-info-panel');
            const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
            const rectangle = document.querySelector('.system-info-rectangle');
            const triangle = document.querySelector('.system-info-triangle');

            if (infoPanel && indicatorBoxes && infoPanel.classList.contains('visible')) {
                const panelRect = infoPanel.getBoundingClientRect();
                const boxesRect = indicatorBoxes.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const boxesTop = panelRect.bottom + 5;

                indicatorBoxes.style.top = boxesTop + 'px';

                // Position rectangle from right edge of boxes to right edge of panel
                if (rectangle) {
                    rectangle.style.top = boxesTop + 'px';
                    // Right edge: same as panel (360px from viewport right)
                    rectangle.style.right = 'calc(300px + 30px + 30px)';  // 360px
                    // Width: from right edge of boxes to right edge of panel, with 10px gap
                    const panelRightEdge = viewportWidth - 360;  // Panel's right edge from left
                    const boxesRightEdge = boxesRect.right;       // Boxes' right edge from left
                    const rectangleWidth = panelRightEdge - boxesRightEdge - 10;  // 10px gap like between boxes
                    rectangle.style.width = rectangleWidth + 'px';

                    // Position triangle on top of rectangle
                    if (triangle) {
                        const triangleHeight = 35;  // Match CSS height
                        const triangleWidth = 35;   // Same as height for isosceles right triangle
                        triangle.style.top = (boxesTop - triangleHeight - 5) + 'px';  // 5px gap between triangle and rectangle
                        triangle.style.right = 'calc(300px + 30px + 30px)';  // Right edge aligned with panel
                        triangle.style.width = triangleWidth + 'px';  // Equal to height for equal legs
                    }
                }
            }
        }

        // Set up ResizeObserver to reposition indicator boxes when panel resizes
        const systemInfoPanel = document.getElementById('system-info-panel');
        if (systemInfoPanel) {
            const resizeObserver = new ResizeObserver(entries => {
                updateIndicatorBoxesPosition();
            });
            resizeObserver.observe(systemInfoPanel);
        }

        // Also update on window resize
        window.addEventListener('resize', updateIndicatorBoxesPosition);

        // Handle star system radio button selection (only one at a time)
        const starSystemRows = document.querySelectorAll('.star-system-row');

        starSystemRows.forEach(row => {
            // Get the content area for system selection
            const contentArea = row.querySelector('.star-system-content');
            if (contentArea) {
                contentArea.addEventListener('click', function() {
                    // Get the system name from the parent row
                    const systemName = row.dataset.system;

                    // If this system is already checked, uncheck it
                    if (row.classList.contains('checked')) {
                        row.classList.remove('checked');
                    // Remove from localStorage (no system selected)
                    localStorage.removeItem('selected_star_system');
                    console.log('No star system selected');

                    // Re-enable auto-rotation around center
                    if (window.starMapState) {
                        window.starMapState.autoRotate = true;
                    }

                    // Hide selection reticle
                    if (window.starMapState && window.starMapState.selectionReticle) {
                        window.starMapState.selectionReticle.visible = false;
                    }

                    // Hide system info panel, indicator boxes, and rectangle
                    const infoPanel = document.getElementById('system-info-panel');
                    if (infoPanel) {
                        infoPanel.classList.remove('visible');
                    }
                    const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
                    if (indicatorBoxes) {
                        indicatorBoxes.classList.remove('visible');
                    }
                    const rectangle = document.querySelector('.system-info-rectangle');
                    if (rectangle) {
                        rectangle.classList.remove('visible');
                    }
                    const triangle = document.querySelector('.system-info-triangle');
                    if (triangle) {
                        triangle.classList.remove('visible');
                    }

                    // Animate camera back to origin (0, 0, 0)
                    if (window.starMapState && window.starMapState.animateCameraToTarget) {
                        window.starMapState.animateCameraToTarget(new THREE.Vector3(0, 0, 0));
                    }
                    return;
                }

                    // Uncheck all other systems
                    starSystemRows.forEach(otherRow => {
                        otherRow.classList.remove('checked');
                    });

                    // Check this system
                    row.classList.add('checked');

                    // Store selected system in localStorage for persistence
                    localStorage.setItem('selected_star_system', systemName);

                    console.log(`Star system ${systemName} selected`);

                    // Get system data and populate info panel
                    if (window.starSystemsData && window.starSystemsData[systemName]) {
                        const systemData = window.starSystemsData[systemName];
                        const infoPanel = document.getElementById('system-info-panel');
                        const infoPanelName = document.getElementById('system-info-name');
                        const infoPanelContent = document.getElementById('system-info-content');

                        if (infoPanel && infoPanelName && infoPanelContent) {
                            // Check if panel is already visible
                            const wasVisible = infoPanel.classList.contains('visible');

                            // Build info content HTML
                            let contentHTML = '';

                            // Type
                            if (systemData.type) {
                                contentHTML += '<p><span class="info-label">TYPE:</span> <span class="info-value">' +
                                    systemData.type.toUpperCase() + '</span></p>';
                            }

                            // Description
                            if (systemData.description) {
                                contentHTML += '<p><span class="info-label">DESCRIPTION:</span> <span class="info-value">' +
                                    systemData.description + '</span></p>';
                            }

                            // Population
                            if (systemData.population) {
                                contentHTML += '<p><span class="info-label">POPULATION:</span> <span class="info-value">' +
                                    systemData.population + '</span></p>';
                            }

                            // Position coordinates
                            if (systemData.position) {
                                contentHTML += '<p><span class="info-label">COORDINATES:</span> <span class="info-value">' +
                                    systemData.position.join(', ') + '</span></p>';
                            }

                            // Location slug
                            if (systemData.location_slug) {
                                contentHTML += '<p><span class="info-label">LOCATION ID:</span> <span class="info-value">' +
                                    systemData.location_slug + '</span></p>';
                            }

                            // System map availability
                            if (systemData.has_system_map) {
                                contentHTML += '<p><span class="info-label">SYSTEM MAP:</span> <span class="info-value">AVAILABLE</span></p>';
                            }

                            // Update content with typewriter effect
                            async function updatePanel() {
                                const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');

                                if (wasVisible) {
                                    // Fade out old content
                                    infoPanelContent.style.opacity = '0';
                                    infoPanelContent.style.transition = 'opacity 0.3s ease';

                                    // Wait for fade out
                                    await new Promise(resolve => setTimeout(resolve, 300));
                                } else {
                                    // Show panel, indicator boxes, rectangle, and triangle first so fade-in happens while typing
                                    infoPanel.classList.add('visible');
                                    if (indicatorBoxes) {
                                        indicatorBoxes.classList.add('visible');
                                        // Show rectangle element
                                        const rectangle = document.querySelector('.system-info-rectangle');
                                        if (rectangle) rectangle.classList.add('visible');
                                        // Show triangle element
                                        const triangle = document.querySelector('.system-info-triangle');
                                        if (triangle) triangle.classList.add('visible');

                                        // Position boxes, rectangle, and triangle with a small delay for panel to start rendering
                                        setTimeout(() => {
                                            updateIndicatorBoxesPosition();
                                        }, 50);
                                    }
                                }

                                // Update header
                                infoPanelName.textContent = systemData.name.toUpperCase();

                                // Reset opacity and typewrite new content
                                infoPanelContent.style.opacity = '1';
                                await typewriteContent(infoPanelContent, contentHTML);

                                // Update indicator boxes position after content is loaded (in case height changed)
                                if (indicatorBoxes && wasVisible) {
                                    setTimeout(() => {
                                        updateIndicatorBoxesPosition();
                                    }, 50);
                                }
                            }

                            updatePanel();
                        }
                    }

                    // Animate camera to selected star system
                    if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                        const position = window.starMapState.starPositions.get(systemName);
                        if (position) {
                            // Show and position selection reticle
                            if (window.starMapState.selectionReticle) {
                                window.starMapState.selectionReticle.position.copy(position);
                                window.starMapState.selectionReticle.visible = true;
                            }

                            // Enable auto-rotation around the selected star
                            window.starMapState.autoRotate = true;

                            // Animate camera
                            window.starMapState.animateCameraToTarget(position);
                            console.log(`Animating camera to ${systemName} at position:`, position);
                        } else {
                            console.warn(`Position not found for system: ${systemName}`);
                        }
                    }
                });
            }

            // Handle system map button click
            const systemMapBtn = row.querySelector('.system-map-btn-container');
            if (systemMapBtn) {
                systemMapBtn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent row click event

                    // Flash animation
                    this.classList.add('flashing');
                    setTimeout(() => {
                        this.classList.remove('flashing');
                    }, 500);

                    // Get system name and location slug
                    const systemName = row.dataset.system;
                    console.log(`System map button clicked for: ${systemName}`);

                    // Get location slug from starSystemsData
                    if (window.starSystemsData && window.starSystemsData[systemName]) {
                        const locationSlug = window.starSystemsData[systemName].location_slug;
                        if (locationSlug) {
                            loadSystemMap(locationSlug);
                        } else {
                            console.error(`No location_slug found for system: ${systemName}`);
                        }
                    } else {
                        console.error(`System data not found for: ${systemName}`);
                    }
                });
            }
        });

        // Check if this is a view change from GM console (not a manual refresh)
        const urlParams = new URLSearchParams(window.location.search);
        const isViewChange = urlParams.get('viewchange') === '1';
        const currentViewType = '{{ active_view.view_type }}';

        // Remove the viewchange parameter from URL (clean up)
        if (isViewChange) {
            window.history.replaceState({}, '', window.location.pathname);
        }

        // Only reset to default state if dashboard was just selected from GM console
        if (isViewChange && currentViewType === 'CAMPAIGN_DASHBOARD') {
            // Clear localStorage
            localStorage.removeItem('selected_star_system');

            // Uncheck all systems
            starSystemRows.forEach(row => {
                row.classList.remove('checked');
            });

            // Hide all UI elements
            const infoPanel = document.getElementById('system-info-panel');
            if (infoPanel) {
                infoPanel.classList.remove('visible');
            }
            const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
            if (indicatorBoxes) {
                indicatorBoxes.classList.remove('visible');
            }
            const rectangle = document.querySelector('.system-info-rectangle');
            if (rectangle) {
                rectangle.classList.remove('visible');
            }
            const triangle = document.querySelector('.system-info-triangle');
            if (triangle) {
                triangle.classList.remove('visible');
            }

            // Hide selection reticle
            if (window.starMapState && window.starMapState.selectionReticle) {
                window.starMapState.selectionReticle.visible = false;
            }

            // Reset camera to center after a short delay to allow star map to load
            setTimeout(() => {
                if (window.starMapState && window.starMapState.animateCameraToTarget) {
                    window.starMapState.animateCameraToTarget(new THREE.Vector3(0, 0, 0), 1000);
                    console.log('Dashboard loaded via GM console - reset to default view');

                    // Re-enable auto-rotation after camera returns to center
                    setTimeout(() => {
                        if (window.starMapState) {
                            window.starMapState.autoRotate = true;
                        }
                    }, 1500);  // Wait for animation to complete
                }
            }, 500);
        }

        // Restore selected system from localStorage on page load (if not resetting)
        const selectedSystem = localStorage.getItem('selected_star_system');

        if (selectedSystem && !(isViewChange && currentViewType === 'CAMPAIGN_DASHBOARD')) {
            // Find and check the stored system
            starSystemRows.forEach(row => {
                if (row.dataset.system === selectedSystem) {
                    row.classList.add('checked');
                } else {
                    row.classList.remove('checked');
                }
            });

            // Populate and show info panel for selected system
            if (window.starSystemsData && window.starSystemsData[selectedSystem]) {
                const systemData = window.starSystemsData[selectedSystem];
                const infoPanel = document.getElementById('system-info-panel');
                const infoPanelName = document.getElementById('system-info-name');
                const infoPanelContent = document.getElementById('system-info-content');

                if (infoPanel && infoPanelName && infoPanelContent) {
                    // Build info content HTML
                    let contentHTML = '';

                    if (systemData.type) {
                        contentHTML += '<p><span class="info-label">TYPE:</span> <span class="info-value">' +
                            systemData.type.toUpperCase() + '</span></p>';
                    }
                    if (systemData.description) {
                        contentHTML += '<p><span class="info-label">DESCRIPTION:</span> <span class="info-value">' +
                            systemData.description + '</span></p>';
                    }
                    if (systemData.population) {
                        contentHTML += '<p><span class="info-label">POPULATION:</span> <span class="info-value">' +
                            systemData.population + '</span></p>';
                    }
                    if (systemData.position) {
                        contentHTML += '<p><span class="info-label">COORDINATES:</span> <span class="info-value">' +
                            systemData.position.join(', ') + '</span></p>';
                    }
                    if (systemData.location_slug) {
                        contentHTML += '<p><span class="info-label">LOCATION ID:</span> <span class="info-value">' +
                            systemData.location_slug + '</span></p>';
                    }
                    if (systemData.has_system_map) {
                        contentHTML += '<p><span class="info-label">SYSTEM MAP:</span> <span class="info-value">AVAILABLE</span></p>';
                    }

                    // Update panel with typewriter effect
                    async function initPanel() {
                        infoPanelName.textContent = systemData.name.toUpperCase();
                        await typewriteContent(infoPanelContent, contentHTML);
                        infoPanel.classList.add('visible');

                        // Show indicator boxes, rectangle, and triangle
                        const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
                        if (indicatorBoxes) {
                            indicatorBoxes.classList.add('visible');
                        }
                        const rectangle = document.querySelector('.system-info-rectangle');
                        if (rectangle) {
                            rectangle.classList.add('visible');
                        }
                        const triangle = document.querySelector('.system-info-triangle');
                        if (triangle) {
                            triangle.classList.add('visible');
                        }

                        // Position the elements
                        setTimeout(() => {
                            updateIndicatorBoxesPosition();
                        }, 50);
                    }

                    initPanel();
                }
            }

            // Wait for star map to load, then animate to selected system
            setTimeout(() => {
                if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                    const position = window.starMapState.starPositions.get(selectedSystem);
                    if (position) {
                        // Show and position selection reticle
                        if (window.starMapState.selectionReticle) {
                            window.starMapState.selectionReticle.position.copy(position);
                            window.starMapState.selectionReticle.visible = true;
                        }

                        // Enable auto-rotation around the selected star
                        window.starMapState.autoRotate = true;

                        // Animate camera
                        window.starMapState.animateCameraToTarget(position, 3000);  // Slower initial animation
                        console.log(`Restoring view to ${selectedSystem}`);
                    }
                }
            }, 1000);  // Wait 1 second for star map to load
        } else if (starSystemRows.length > 0 && !(isViewChange && currentViewType === 'CAMPAIGN_DASHBOARD')) {
            // If no stored selection, select the first system by default (unless we're resetting)
            const firstSystemName = starSystemRows[0].dataset.system;
            starSystemRows[0].classList.add('checked');

            // Populate and show info panel for first system
            if (window.starSystemsData && window.starSystemsData[firstSystemName]) {
                const systemData = window.starSystemsData[firstSystemName];
                const infoPanel = document.getElementById('system-info-panel');
                const infoPanelName = document.getElementById('system-info-name');
                const infoPanelContent = document.getElementById('system-info-content');

                if (infoPanel && infoPanelName && infoPanelContent) {
                    // Build info content HTML
                    let contentHTML = '';

                    if (systemData.type) {
                        contentHTML += '<p><span class="info-label">TYPE:</span> <span class="info-value">' +
                            systemData.type.toUpperCase() + '</span></p>';
                    }
                    if (systemData.description) {
                        contentHTML += '<p><span class="info-label">DESCRIPTION:</span> <span class="info-value">' +
                            systemData.description + '</span></p>';
                    }
                    if (systemData.population) {
                        contentHTML += '<p><span class="info-label">POPULATION:</span> <span class="info-value">' +
                            systemData.population + '</span></p>';
                    }
                    if (systemData.position) {
                        contentHTML += '<p><span class="info-label">COORDINATES:</span> <span class="info-value">' +
                            systemData.position.join(', ') + '</span></p>';
                    }
                    if (systemData.location_slug) {
                        contentHTML += '<p><span class="info-label">LOCATION ID:</span> <span class="info-value">' +
                            systemData.location_slug + '</span></p>';
                    }
                    if (systemData.has_system_map) {
                        contentHTML += '<p><span class="info-label">SYSTEM MAP:</span> <span class="info-value">AVAILABLE</span></p>';
                    }

                    // Update panel with typewriter effect
                    async function initPanel() {
                        infoPanelName.textContent = systemData.name.toUpperCase();
                        await typewriteContent(infoPanelContent, contentHTML);
                        infoPanel.classList.add('visible');

                        // Show indicator boxes, rectangle, and triangle
                        const indicatorBoxes = document.querySelector('.system-info-indicator-boxes');
                        if (indicatorBoxes) {
                            indicatorBoxes.classList.add('visible');
                        }
                        const rectangle = document.querySelector('.system-info-rectangle');
                        if (rectangle) {
                            rectangle.classList.add('visible');
                        }
                        const triangle = document.querySelector('.system-info-triangle');
                        if (triangle) {
                            triangle.classList.add('visible');
                        }

                        // Position the elements
                        setTimeout(() => {
                            updateIndicatorBoxesPosition();
                        }, 50);
                    }

                    initPanel();
                }
            }

            // Animate to first system
            setTimeout(() => {
                if (window.starMapState && window.starMapState.starPositions && window.starMapState.animateCameraToTarget) {
                    const position = window.starMapState.starPositions.get(firstSystemName);
                    if (position) {
                        // Show and position selection reticle
                        if (window.starMapState.selectionReticle) {
                            window.starMapState.selectionReticle.position.copy(position);
                            window.starMapState.selectionReticle.visible = true;
                        }

                        // Enable auto-rotation around the selected star
                        window.starMapState.autoRotate = true;

                        // Animate camera
                        window.starMapState.animateCameraToTarget(position, 3000);
                        console.log(`Initial view: ${firstSystemName}`);
                    }
                }
            }, 1000);
        }
    })();
    </script>
</body>
</html>
