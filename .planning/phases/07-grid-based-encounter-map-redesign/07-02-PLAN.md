---
phase: 07-grid-based-encounter-map-redesign
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/components/domain/encounter/EncounterMapRenderer.tsx
  - src/components/domain/encounter/EncounterMapRenderer.css
  - src/components/domain/encounter/EncounterMapDisplay.tsx
autonomous: true
requirements: [GRID-03, GRID-04, GRID-05, GRID-06, GRID-09]

must_haves:
  truths:
    - "Grid maps render rooms as touching wall-aligned rectangles, not floating boxes"
    - "Room interiors show a scanline floor texture distinguishing floor from void"
    - "Background shows faint dark grid lines in the void outside rooms"
    - "Walls render in amber tones (#8b7355), walls between adjacent rooms are solid"
    - "Internal edges shared between rects of the same room are not drawn (open floor)"
    - "Room labels appear centered in room bounding box, only when room is revealed, only for named rooms"
    - "GM view dims hidden rooms (opacity 0.25); player view hides them entirely"
    - "GM can click directly on a room to toggle reveal/hide (hit targets are transparent rects)"
    - "Door symbols render on wall edges using the same renderDoorSymbol function as before"
    - "Pan/zoom/touch controls work identically to the old renderer"
    - "isGridEncounterMap branch added to EncounterMapDisplay to route new maps to new renderer (both single-deck and multi-deck paths check isGridEncounterMap before casting)"
    - "npm run typecheck passes with 0 errors"
  artifacts:
    - path: "src/components/domain/encounter/EncounterMapRenderer.tsx"
      provides: "Grid-based SVG renderer with wall-segment algorithm, floor texture, GM click-to-reveal"
      min_lines: 400
    - path: "src/components/domain/encounter/EncounterMapRenderer.css"
      provides: "Updated CSS for amber walls, floor texture, dimmed GM rooms, click-target rects"
    - path: "src/components/domain/encounter/EncounterMapDisplay.tsx"
      provides: "isGridEncounterMap routing branch before existing isEncounterMap branch"
  key_links:
    - from: "EncounterMapDisplay.tsx"
      to: "GridEncounterMapRenderer"
      via: "isGridEncounterMap(mapData) guard before isEncounterMap(mapData)"
      pattern: "isGridEncounterMap"
    - from: "EncounterMapDisplay.tsx isMultiDeckMap branch"
      to: "GridEncounterMapRenderer or legacy EncounterMapRenderer"
      via: "isGridEncounterMap(deckData) conditional — grid decks use new renderer, old-format decks fall back to old renderer"
      pattern: "isGridEncounterMap\\(deckData\\)"
    - from: "EncounterMapRenderer.tsx computeRoomWalls()"
      to: "SVG <line> wall segments"
      via: "edge-set exclusion algorithm (count === 1)"
      pattern: "edgeCounts"
    - from: "EncounterMapRenderer.tsx handleRoomClick"
      to: "onRoomToggle prop callback"
      via: "isGM guard, getRoomAtPoint() hit test"
      pattern: "onRoomToggle"
---

<objective>
Rewrite EncounterMapRenderer.tsx render logic for the grid-based map format, update CSS for the new visual style, and add isGridEncounterMap routing in EncounterMapDisplay.

Purpose: This is the core visual deliverable of Phase 7 — replacing the floating-room node-graph renderer with a true grid-based wall-segment renderer. The old renderer is removed; this new renderer handles only GridEncounterMapData.
Output: GridEncounterMapRenderer (still exported as EncounterMapRenderer for compatibility), updated CSS, EncounterMapDisplay routing.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-grid-based-encounter-map-redesign/07-RESEARCH.md
@.planning/phases/07-grid-based-encounter-map-redesign/07-01-SUMMARY.md
@src/types/encounterMap.ts
@src/components/domain/encounter/EncounterMapRenderer.tsx
@src/components/domain/encounter/EncounterMapRenderer.css
@src/components/domain/encounter/EncounterMapDisplay.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite EncounterMapRenderer.tsx for grid-based maps</name>
  <files>src/components/domain/encounter/EncounterMapRenderer.tsx</files>
  <action>
Replace the render logic in EncounterMapRenderer.tsx. Keep the following UNCHANGED:
- All pan/zoom state and handlers (handleWheel, handleMouseDown, handleMouseMove, handleMouseUp, handleResetView, handleTouchStart, touchMoveHandler, handleTouchEnd, and all associated useEffect/useRef hooks)
- The renderDoorSymbol() function — it takes (x, y, doorType, doorStatus, style, orientation, key) and renders SVG door graphics. Keep it exactly as-is.
- TokenLayer integration (token layer rendering at the bottom of the SVG stack)
- TokenPopup rendering outside SVG
- COLORS constant and CONNECTION_STYLES constant (reuse for door rendering)
- LevelIndicator, LegendPanel overlays
- MIN_ZOOM, MAX_ZOOM constants

What CHANGES:
1. **Props interface**: Change mapData type from EncounterMapData to GridEncounterMapData. Add `onRoomToggle?: (roomId: string, visible: boolean) => void` prop.

2. **SVG dimensions**: Replace the old `grid.width * unitSize` calculation with the `computeBoundingBox()` function:
   ```typescript
   const unitSize = mapData.unit_size ?? 40;

   function computeBoundingBox(rooms: GridRoom[], us: number, padding = 2) {
     let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
     for (const room of rooms) {
       for (const rect of room.rects) {
         minX = Math.min(minX, rect.x);
         minY = Math.min(minY, rect.y);
         maxX = Math.max(maxX, rect.x + rect.w);
         maxY = Math.max(maxY, rect.y + rect.h);
       }
     }
     if (!isFinite(minX)) { minX = 0; minY = 0; maxX = 10; maxY = 10; }
     return {
       originX: (minX - padding) * us,
       originY: (minY - padding) * us,
       svgWidth: (maxX - minX + padding * 2) * us,
       svgHeight: (maxY - minY + padding * 2) * us,
     };
   }

   const { originX, originY, svgWidth, svgHeight } = useMemo(
     () => computeBoundingBox(mapData.rooms, unitSize),
     [mapData.rooms, unitSize]
   );
   ```
   IMPORTANT: Always compute bounding box from ALL rooms regardless of visibility (see RESEARCH pitfall #6).

3. **Wall-segment algorithm** (`computeRoomWalls`):
   ```typescript
   interface Edge { x1: number; y1: number; x2: number; y2: number; }

   function computeRoomWalls(rects: GridRect[], us: number): Edge[] {
     const edgeCounts = new Map<string, number>();
     const addEdges = (rect: GridRect) => {
       for (let cx = rect.x; cx < rect.x + rect.w; cx++) {
         const top = `H:${cx}:${rect.y}`;
         const bot = `H:${cx}:${rect.y + rect.h}`;
         edgeCounts.set(top, (edgeCounts.get(top) || 0) + 1);
         edgeCounts.set(bot, (edgeCounts.get(bot) || 0) + 1);
       }
       for (let cy = rect.y; cy < rect.y + rect.h; cy++) {
         const left = `V:${rect.x}:${cy}`;
         const right = `V:${rect.x + rect.w}:${cy}`;
         edgeCounts.set(left, (edgeCounts.get(left) || 0) + 1);
         edgeCounts.set(right, (edgeCounts.get(right) || 0) + 1);
       }
     };
     for (const rect of rects) addEdges(rect);
     const walls: Edge[] = [];
     for (const [key, count] of edgeCounts) {
       if (count !== 1) continue;
       const [orient, gxStr, gyStr] = key.split(':');
       const gx = parseInt(gxStr), gy = parseInt(gyStr);
       if (orient === 'H') {
         walls.push({ x1: gx * us, y1: gy * us, x2: (gx + 1) * us, y2: gy * us });
       } else {
         walls.push({ x1: gx * us, y1: gy * us, x2: gx * us, y2: (gy + 1) * us });
       }
     }
     return walls;
   }
   ```

4. **Label position helper**:
   ```typescript
   function getRoomLabelPosition(rects: GridRect[], us: number): { x: number; y: number } {
     const minX = Math.min(...rects.map(r => r.x));
     const minY = Math.min(...rects.map(r => r.y));
     const maxX = Math.max(...rects.map(r => r.x + r.w));
     const maxY = Math.max(...rects.map(r => r.y + r.h));
     return { x: ((minX + maxX) / 2) * us, y: ((minY + maxY) / 2) * us };
   }
   ```

5. **Door position helper**:
   ```typescript
   function getDoorSVGPosition(
     rects: GridRect[], door: DoorDef, us: number
   ): { x: number; y: number; orientation: 'horizontal' | 'vertical' } {
     if (door.wall === 'north' || door.wall === 'south') {
       const wallY = door.wall === 'north'
         ? Math.min(...rects.map(r => r.y)) * us
         : Math.max(...rects.map(r => r.y + r.h)) * us;
       // Find exterior wall cells along north/south edge, sorted by x
       const targetY = door.wall === 'north'
         ? Math.min(...rects.map(r => r.y))
         : Math.max(...rects.map(r => r.y + r.h));
       const wallRects = rects.filter(r =>
         door.wall === 'north' ? r.y === targetY : r.y + r.h === targetY
       );
       const cells = wallRects.flatMap(r =>
         Array.from({ length: r.w }, (_, i) => r.x + i)
       ).sort((a, b) => a - b);
       const cellX = cells[door.position] ?? cells[0] ?? 0;
       return { x: (cellX + 0.5) * us, y: wallY, orientation: 'horizontal' };
     } else {
       const wallX = door.wall === 'west'
         ? Math.min(...rects.map(r => r.x)) * us
         : Math.max(...rects.map(r => r.x + r.w)) * us;
       const targetX = door.wall === 'west'
         ? Math.min(...rects.map(r => r.x))
         : Math.max(...rects.map(r => r.x + r.w));
       const wallRects = rects.filter(r =>
         door.wall === 'west' ? r.x === targetX : r.x + r.w === targetX
       );
       const cells = wallRects.flatMap(r =>
         Array.from({ length: r.h }, (_, i) => r.y + i)
       ).sort((a, b) => a - b);
       const cellY = cells[door.position] ?? cells[0] ?? 0;
       return { x: wallX, y: (cellY + 0.5) * us, orientation: 'vertical' };
     }
   }
   ```

6. **isRoomVisible** — same logic as before: `roomVisibility?.[roomId] !== false` (defaults visible).

7. **GM click-to-reveal**:
   ```typescript
   const getRoomAtPoint = useCallback((svgX: number, svgY: number): GridRoom | null => {
     const gridX = Math.floor(svgX / unitSize);
     const gridY = Math.floor(svgY / unitSize);
     return mapData.rooms.find(room =>
       room.rects.some(r =>
         gridX >= r.x && gridX < r.x + r.w &&
         gridY >= r.y && gridY < r.y + r.h
       )
     ) ?? null;
   }, [mapData.rooms, unitSize]);
   ```

   The click handler on the invisible hit-target rects calls:
   ```typescript
   const handleRoomClick = useCallback((room: GridRoom) => {
     if (!isGM || !onRoomToggle) return;
     onRoomToggle(room.id, !isRoomVisible(room.id));
   }, [isGM, onRoomToggle, isRoomVisible]);
   ```

   Note: The old `selectedRoom` state is no longer needed (click now toggles visibility, not selection). Remove it.

8. **renderRoom** function (new):
   ```typescript
   const renderRoom = (room: GridRoom) => {
     const visible = isRoomVisible(room.id);
     // GM sees all rooms, players only see revealed rooms
     if (!isGM && !visible) return null;
     const roomOpacity = isGM && !visible ? 0.25 : 1.0;
     const walls = computeRoomWalls(room.rects, unitSize);
     const label = room.name ? getRoomLabelPosition(room.rects, unitSize) : null;

     return (
       <g key={room.id} className="encounter-map__room-group" opacity={roomOpacity}>
         {/* Floor fill — one scanline-textured rect per room rect */}
         {room.rects.map((rect, i) => (
           <rect
             key={`floor-${i}`}
             x={rect.x * unitSize}
             y={rect.y * unitSize}
             width={rect.w * unitSize}
             height={rect.h * unitSize}
             fill="url(#floor-scanline)"
             className="encounter-map__floor"
           />
         ))}

         {/* Exterior wall segments — amber lines */}
         {walls.map((wall, i) => (
           <line
             key={`wall-${i}`}
             x1={wall.x1} y1={wall.y1}
             x2={wall.x2} y2={wall.y2}
             stroke="#8b7355"
             strokeWidth={1.5}
             strokeLinecap="square"
             className="encounter-map__wall"
           />
         ))}

         {/* Invisible click targets — GM only (transparent rects for reliable hit detection) */}
         {isGM && room.rects.map((rect, i) => (
           <rect
             key={`hit-${i}`}
             x={rect.x * unitSize}
             y={rect.y * unitSize}
             width={rect.w * unitSize}
             height={rect.h * unitSize}
             fill="transparent"
             style={{ cursor: onRoomToggle ? 'pointer' : 'default' }}
             onClick={() => handleRoomClick(room)}
             className="encounter-map__room"
           />
         ))}

         {/* Room label — centered, only for named rooms, only when visible */}
         {label && visible && (
           <text
             x={label.x}
             y={label.y}
             className="encounter-map__room-label"
             textAnchor="middle"
             dominantBaseline="middle"
           >
             {room.name}
           </text>
         )}
       </g>
     );
   };
   ```

9. **SVG defs** — add at top of SVG output (inside the svg element, before all room groups):
   ```tsx
   <defs>
     <pattern
       id="map-bg-grid"
       width={unitSize} height={unitSize}
       patternUnits="userSpaceOnUse"
       x={originX} y={originY}
     >
       <path
         d={`M ${unitSize} 0 L 0 0 0 ${unitSize}`}
         fill="none" stroke="#141e1e" strokeWidth={0.5}
       />
     </pattern>
     <pattern
       id="floor-scanline"
       width={unitSize} height={unitSize}
       patternUnits="userSpaceOnUse"
       x={originX} y={originY}
     >
       <line
         x1={0} y1={Math.floor(unitSize / 2)}
         x2={unitSize} y2={Math.floor(unitSize / 2)}
         stroke="#182020" strokeWidth={0.5}
       />
     </pattern>
   </defs>

   {/* Background grid — fills entire viewBox */}
   <rect
     x={originX} y={originY}
     width={svgWidth} height={svgHeight}
     fill="url(#map-bg-grid)"
   />
   ```

10. **Door rendering**: After all room groups, render door symbols for all rooms with doors:
    ```tsx
    {/* Door symbols — rendered above room floors and walls */}
    <g className="encounter-map__doors">
      {mapData.rooms.flatMap(room =>
        (room.doors || []).map((door, i) => {
          // Only render door if room is visible (or GM view)
          if (!isGM && !isRoomVisible(room.id)) return null;
          const pos = getDoorSVGPosition(room.rects, door, unitSize);
          const style = CONNECTION_STYLES[door.type] || CONNECTION_STYLES.standard;
          return renderDoorSymbol(
            pos.x, pos.y, door.type, door.status, style, pos.orientation,
            `door-${room.id}-${i}`
          );
        })
      )}
    </g>
    ```

11. **viewBox** — update to account for computed bounding box origin:
    ```
    viewBox={`${originX} ${originY} ${svgWidth} ${svgHeight}`}
    ```

12. **Remove** all old node-graph code: getConnectionEdge, generateOrthogonalPath, renderConnectionPath, renderConnectionDoors, renderTerminal, renderPoi, allConnections, visibleConnectionLines, visibleDoors, allRoomMap, roomMap. Remove POI_ICONS constant. Remove getEffectiveDoorStatus (no longer needed — doors now on rooms with their own status). Remove tooltip state and room hover handlers (no tooltip in grid renderer). Remove selectedRoom state.

13. **handleMouseDown exemption** — update to exempt new room hit-target class:
    The existing check `target.closest('.encounter-map__room')` already works since we keep that class on the hit-target rects. No change needed.

14. **TokenLayer props** — TokenLayer receives `mapRooms`. Pass `mapData.rooms` directly. Plan 03 will update the TokenLayer prop type to `(RoomData | GridRoom)[]`, which accepts GridRoom[]. Until then, TypeScript will accept the pass-through because the type narrowing from isGridEncounterMap is sufficient — do NOT add `@ts-expect-error` or any cast here. If a type error does surface at this call site, use `mapData.rooms as unknown as RoomData[]` as a last resort, but prefer letting Plan 03 fix it atomically.
  </action>
  <verify>cd /home/gjohnson/mothership/charon && npm run typecheck 2>&1 | grep -E "error TS|0 errors" | head -10</verify>
  <done>npm run typecheck passes (0 errors). EncounterMapRenderer.tsx renders grid rooms with wall segments, floor texture, dim-hidden logic, GM click targets, and door symbols. The old connection-based rendering code is removed.</done>
</task>

<task type="auto">
  <name>Task 2: Update CSS and EncounterMapDisplay routing</name>
  <files>
    src/components/domain/encounter/EncounterMapRenderer.css
    src/components/domain/encounter/EncounterMapDisplay.tsx
  </files>
  <action>
**EncounterMapRenderer.css updates:**

Keep existing CSS classes that are still used (encounter-map-renderer, encounter-map-renderer__svg, encounter-map__token, encounter-map__door and all door sub-classes, encounter-map__door-spark animation, encounter-map__reset-btn, encounter-map__overlays, encounter-map__level-indicator, encounter-map__legend).

Add/update these classes:

```css
/* Room wall lines — amber blueprint aesthetic */
.encounter-map__wall {
  shape-rendering: crispEdges;
}

/* Room floor fill — dark floor distinct from void */
.encounter-map__floor {
  /* fill is set inline via url(#floor-scanline) */
}

/* GM hit target overlay — transparent, cursor pointer handled inline */
.encounter-map__room {
  /* Keep existing class — used for mousedown exemption check */
}

/* Room label text */
.encounter-map__room-label {
  font-family: 'Cascadia Code', 'Courier New', monospace;
  font-size: 9px;
  fill: #4a6b6b;
  letter-spacing: 0.05em;
  pointer-events: none;
  user-select: none;
}

/* Room group — opacity applied inline for GM dim effect */
.encounter-map__room-group {
  transition: opacity 0.2s ease;
}
```

Remove any old CSS rules that reference:
- `.encounter-map__room--OPERATIONAL`, `.encounter-map__room--WARNING`, etc. (status-based room coloring — gone)
- `.encounter-map__path-line` (connection path lines — gone)
- `.encounter-map__connection-paths` (gone)
- `.encounter-map__terminal` (removed — terminals may return in future but not in this renderer)
- `.encounter-map__poi` (removed similarly)

Keep the existing background color on `.encounter-map-renderer` (bgPrimary: #0a0a0a).

**EncounterMapDisplay.tsx updates:**

Add a new import at the top:
```typescript
import {
  GridEncounterMapData,
  isGridEncounterMap,
} from '../../../types/encounterMap';
```

Add a new prop to EncounterMapDisplayProps:
```typescript
/** Callback when GM clicks a room to toggle visibility */
onRoomToggle?: (roomId: string, visible: boolean) => void;
```

Add the isGridEncounterMap routing branch BEFORE the existing `isEncounterMap` check:
```typescript
// NEW: Grid-based encounter map (Phase 7 format)
if (mapData && isGridEncounterMap(mapData)) {
  return (
    <EncounterMapRenderer
      mapData={mapData as GridEncounterMapData}
      roomVisibility={roomVisibility}
      currentLevel={currentLevel}
      totalLevels={totalLevels}
      deckName={deckName}
      tokens={tokens}
      isGM={isGM}
      onRoomToggle={onRoomToggle}
      onTokenMove={onTokenMove}
      onTokenRemove={onTokenRemove}
      onTokenStatusToggle={onTokenStatusToggle}
    />
  );
}
```

Note: The multi-deck map branch also needs to check `isGridEncounterMap` for the current_deck. Update the `isMultiDeckMap` branch to apply an explicit format check before choosing a renderer — do NOT cast unconditionally:

```typescript
if (mapData && isMultiDeckMap(mapData)) {
  const multiDeckData = mapData as MultiDeckMapData;
  const deckData = multiDeckData.current_deck;
  const effectiveVisibility = roomVisibility || multiDeckData.room_visibility || {};
  const commonProps = {
    roomVisibility: effectiveVisibility,
    currentLevel,
    totalLevels,
    deckName,
    tokens,
    isGM,
    onRoomToggle,
    onTokenMove,
    onTokenRemove,
    onTokenStatusToggle,
  };

  // IMPORTANT: check the deck's own format before choosing a renderer.
  // Old-format multi-deck maps (if any exist outside the rebuilt files) must
  // still fall through to the old EncounterMapRenderer with EncounterMapData.
  if (isGridEncounterMap(deckData)) {
    return (
      <EncounterMapRenderer
        mapData={deckData as GridEncounterMapData}
        {...commonProps}
      />
    );
  } else if (isEncounterMap(deckData)) {
    return (
      <EncounterMapRenderer
        mapData={deckData as EncounterMapData}
        {...commonProps}
      />
    );
  }
  // If deck format is unrecognized, fall through to null/loading state below.
}
```

The existing `isEncounterMap` branch (for top-level single-deck old-format maps) remains after this block. Do not remove it.
  </action>
  <verify>cd /home/gjohnson/mothership/charon && npm run typecheck 2>&1 | grep -E "error TS|0 errors" | head -10</verify>
  <done>npm run typecheck passes (0 errors). EncounterMapDisplay.tsx has isGridEncounterMap branch before isEncounterMap branch. CSS is updated with new classes and old node-graph classes removed.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `cd /home/gjohnson/mothership/charon && npm run typecheck` — 0 errors
2. `cd /home/gjohnson/mothership/charon && npm run build` — production build succeeds
3. Grep for removed symbols: `grep -r "getConnectionEdge\|generateOrthogonalPath\|renderConnectionPath" src/components/domain/encounter/EncounterMapRenderer.tsx` — should return nothing
4. Grep confirms new symbols: `grep -n "computeRoomWalls\|getDoorSVGPosition\|floor-scanline\|onRoomToggle" src/components/domain/encounter/EncounterMapRenderer.tsx` — all present
5. Grep confirms routing: `grep -n "isGridEncounterMap" src/components/domain/encounter/EncounterMapDisplay.tsx` — present
</verification>

<success_criteria>
- EncounterMapRenderer.tsx uses wall-segment algorithm and renders grid rooms
- Background void shows faint grid pattern; room interiors show scanline texture
- Walls amber, room labels teal monospace, centered, visibility-gated
- GM can click rooms to trigger onRoomToggle; hidden rooms dimmed at 0.25 opacity
- Door symbols render on wall edges (not on connection paths)
- EncounterMapDisplay routes grid maps to the new renderer
- npm run typecheck and npm run build both pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-grid-based-encounter-map-redesign/07-02-SUMMARY.md`
</output>
