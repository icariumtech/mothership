---
phase: 05-real-time-push-architecture
plan: "02"
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - terminal/views.py
autonomous: true
requirements:
  - RTMA-01
  - RTMA-02

must_haves:
  truths:
    - "Every GM write action immediately pushes an SSE event to all connected clients"
    - "No write endpoint calls active_view.save() or ActiveView.get_current()"
    - "All 17 write endpoints read/write from active_view_store and call broadcaster.announce()"
    - "Read-only endpoints (map data, ship status, terminal data) read from active_view_store"
    - "display_view_react passes state dict to template without ORM dependency"
  artifacts:
    - path: "terminal/views.py"
      provides: "All views migrated to active_view_store + broadcaster"
      contains: "broadcaster.announce"
  key_links:
    - from: "terminal/views.py (api_switch_view)"
      to: "terminal/sse_broadcaster.py"
      via: "broadcaster.announce(payload)"
      pattern: "broadcaster\\.announce\\("
    - from: "terminal/views.py (all write endpoints)"
      to: "terminal/active_view_store.py"
      via: "update_state(**kwargs)"
      pattern: "update_state\\("
---

<objective>
Migrate all 17 write endpoints in views.py from SQLite ActiveView ORM to the in-memory store + SSE broadcaster. Every state mutation now instantly pushes to all connected SSE clients.

Purpose: This is the core of the real-time architecture — without this step, the SSE endpoint delivers initial state but never pushes updates.
Output: `terminal/views.py` fully migrated — no ORM writes to ActiveView, all mutations via `update_state()` + `broadcaster.announce()`, broadcast payload built via `build_active_view_payload()`.
</objective>

<execution_context>
@/home/gjohnson/.claude/get-shit-done/workflows/execute-plan.md
@/home/gjohnson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-push-architecture/05-CONTEXT.md
@.planning/phases/05-real-time-push-architecture/05-RESEARCH.md
@.planning/phases/05-real-time-push-architecture/05-01-SUMMARY.md
@terminal/views.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate all write endpoints from ActiveView ORM to active_view_store + broadcaster</name>
  <files>terminal/views.py</files>
  <action>
Read the current `terminal/views.py` fully before editing. The file is ~2000 lines. The migration pattern is identical for all 17 write endpoints:

**Old pattern (remove):**
```python
from terminal.models import ActiveView
active_view = ActiveView.get_current()
active_view.some_field = new_value
active_view.save()
```

**New pattern (replace with):**
```python
from terminal.active_view_store import update_state, get_state
from terminal.sse_broadcaster import broadcaster
from terminal.views import build_active_view_payload  # (or just call it directly if in same file)

new_state = update_state(some_field=new_value)
payload = build_active_view_payload(new_state)
broadcaster.announce(payload)
```

Since `build_active_view_payload` and `broadcaster` are both defined/imported at module level after Plan 01, just call them directly — no local import needed in each function.

Add top-level imports at the top of views.py (after existing imports):
```python
from terminal.active_view_store import get_state, update_state
from terminal.sse_broadcaster import broadcaster
```

**Complete list of write endpoints to migrate (17 total):**

1. `api_switch_view` — sets view_type, location_slug, view_slug, overlay fields, charon_active_channel, encounter_active_portraits, encounter_room_visibility, encounter_level, encounter_deck_id
   - This is the most complex endpoint. It currently builds encounter room visibility from DataLoader, then saves. After migration: compute all the same values, call `update_state(view_type=..., location_slug=..., ...)` with ALL fields at once (one call), then announce.
   - Remove `active_view.updated_by = request.user` (no equivalent in store — not needed for SSE)

2. `api_show_terminal` — sets overlay_location_slug, overlay_terminal_slug

3. `api_hide_terminal` — clears overlay fields (set to empty strings)

4. `api_charon_switch_mode` — sets charon_mode

5. `api_charon_set_location` — sets charon_location_path

6. `api_charon_toggle_dialog` — toggles charon_dialog_open

7. `api_encounter_switch_level` — sets encounter_level, encounter_deck_id

8. `api_encounter_toggle_room` — updates encounter_room_visibility dict (read current, mutate, write back)
   - Pattern: `current = get_state(); rooms = dict(current['encounter_room_visibility']); rooms[room_id] = not rooms.get(room_id, False); new_state = update_state(encounter_room_visibility=rooms); broadcaster.announce(build_active_view_payload(new_state))`

9. `api_encounter_room_visibility` (POST bulk) — replaces encounter_room_visibility entirely

10. `api_encounter_set_door_status` — updates encounter_door_status dict (same read-mutate-write pattern)

11. `api_encounter_place_token` — adds token to encounter_tokens dict

12. `api_encounter_move_token` — updates token position in encounter_tokens dict

13. `api_encounter_remove_token` — removes token from encounter_tokens dict

14. `api_encounter_update_token_status` — updates token status array in encounter_tokens dict

15. `api_encounter_clear_tokens` — sets encounter_tokens to {}

16. `api_encounter_toggle_portrait` — add/remove NPC ID from encounter_active_portraits list

17. `api_ship_toggle_system` — updates ship_system_overrides dict

**For read-only views that currently call `ActiveView.get_current()` (no announce needed):**

- `api_encounter_map_data` — reads encounter_room_visibility, encounter_deck_id from store
- `api_encounter_all_decks` — reads encounter_room_visibility from store
- `api_ship_status` — reads ship_system_overrides from store
- `api_charon_conversation` — reads charon_mode, charon_active_channel, charon_location_path from store
- `api_charon_generate` — reads charon_mode from store
- `api_charon_channel_conversation` — reads charon_active_channel from store
- `api_charon_channel_submit` — reads charon_active_channel from store
- `display_view_react` — reads state via `get_state()`, passes to template as plain dict

For `display_view_react`: The view currently passes `active_view` (ORM object) to the template context and the template calls `active_view.some_field`. After migration, pass `active_view=get_state()` so the template reads from a plain dict. Also check `get_charon_location_path()` helper at top of file — it currently accepts an ActiveView ORM object; update it to accept a state dict (read from dict keys instead of object attributes).

**Pitfall: `api_encounter_toggle_portrait` clears portraits on location switch** — this logic currently reads `active_view.encounter_active_portraits`. In the store pattern, read `get_state()['encounter_active_portraits']` instead.

**Pitfall: `api_switch_view` computes encounter_room_visibility from DataLoader** — this existing logic is complex (loads all room IDs and sets visibility to False). Do NOT simplify — copy the full logic, just replace `active_view.encounter_room_visibility` reads/writes with store operations.

After all migrations, run a grep to confirm no `active_view.save()` or `ActiveView.get_current()` calls remain (except in migration files and __pycache__):
```bash
grep -n "active_view\.save\(\)\|ActiveView\.get_current\(\)\|from terminal\.models import ActiveView" terminal/views.py
```
  </action>
  <verify>
```bash
cd /home/gjohnson/mothership/charon

# 1. No ORM write patterns remain
grep -n "active_view\.save()\|ActiveView\.get_current()\|from terminal\.models import ActiveView" terminal/views.py && echo "FAIL: ORM references remain" || echo "PASS: No ORM references"

# 2. All 17 announce calls present
ANNOUNCE_COUNT=$(grep -c "broadcaster\.announce" terminal/views.py)
echo "broadcaster.announce call count: $ANNOUNCE_COUNT (expect 17)"

# 3. Django system check passes
python manage.py check

# 4. Write endpoints respond correctly (server must be running)
# Test api_switch_view with curl to verify it returns success JSON
# Manual test: curl -X POST http://127.0.0.1:8000/api/gm/switch-view/ -H "Content-Type: application/json" -d '{"view_type": "STANDBY"}' -b "sessionid=..."
```
  </verify>
  <done>All 17 write endpoints use `update_state()` + `broadcaster.announce(build_active_view_payload(state))`. Zero `active_view.save()` or `ActiveView.get_current()` calls remain in views.py. `python manage.py check` passes. All read-only endpoints read from `get_state()` instead of ORM.</done>
</task>

</tasks>

<verification>
Complete migration check:
```bash
cd /home/gjohnson/mothership/charon

# ORM leak check
echo "=== ORM references ==="
grep -n "active_view\.save\|ActiveView\.get_current\|models import ActiveView" terminal/views.py | grep -v "migration\|#"

# Store + broadcast usage
echo "=== update_state calls ==="
grep -c "update_state(" terminal/views.py

echo "=== broadcaster.announce calls ==="
grep -c "broadcaster.announce" terminal/views.py

# Health check
python manage.py check
```
</verification>

<success_criteria>
- Zero `active_view.save()` or `ActiveView.get_current()` calls in `terminal/views.py`
- `broadcaster.announce()` called in all 17 write endpoints (count >= 17)
- `update_state()` called in all 17 write endpoints (count >= 17)
- `python manage.py check` passes
- `get_active_view_json` returns correct JSON from in-memory store (no `updated_at` field — clients no longer use it for change detection)
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-push-architecture/05-02-SUMMARY.md`
</output>
